# 코파일럿 버그 수정 최적화 가이드라인

이 문서는 코파일럿(및 유사 AI 코드 보조 도구)이 버그를 수정할 때 따라야 할 최적화된 방법과 가이드라인을 상세하게 기술한 것이다.  
목표는 _완벽하게_ 코드 버그를 수정하면서, 수정 후 기존 코드나 기능이 사라지지 않도록 보장하는 것이다.  
특히 TypeScript의 `any` 오류 및 자주 발생하는 문제들을 중심으로, 공식 문서나 최선의 수정 방법을 활용해 아래와 같이 100개 이상의 규칙을 정리하였다.

> **참고**: 이 가이드라인은 코드베이스의 일관성을 유지하고 안정적인 수정 결과를 내기 위한 권장사항이며, 실제 프로젝트 상황에 맞게 유연하게 적용할 수 있다.

---

## 1. 일반 원칙
1. **전체 컨텍스트 파악**: 버그를 수정하기 전에, 문제가 발생한 코드의 전체 흐름과 의도를 파악한다.  
   _참고_: [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)
2. **변경 전 백업**: 중요한 변경 작업을 시작하기 전에 항상 현재 상태의 백업(예: git branch 생성, stash 사용)을 진행한다.
3. **최소 변경 원칙**: 버그 수정 시, 기존 코드의 기능이나 로직에 영향을 주지 않도록 최소한의 변경만 실시한다.
4. **문서 및 주석 확인**: 수정할 코드에 이미 작성된 주석이나 문서를 확인하여 기능 의도를 명확히 이해한다.
5. **공식 문서 참조**: 타입 관련 오류나 기능 수정 시 반드시 공식 문서(예: TypeScript, ESLint, Next.js 문서)를 참고한다.
6. **테스트 기반 수정**: 수정 전후로 관련 테스트 코드가 있다면, 반드시 테스트를 통과하는지 확인한다.
7. **협업 통신**: 팀 내 리뷰를 통해 수정 사항을 공유하고, 충돌 가능성을 최소화한다.

---

## 2. any 및 타입 관련 오류 수정
8. **any 오류 근본 해결**: `any` 타입 사용을 피하고, 보다 구체적인 타입을 명시한다.  
   _참고_: [TypeScript: Avoiding 'any'](https://www.typescriptlang.org/docs/handbook/basic-types.html#any)
9. **타입 단언 사용 자제**: 가능하면 `as any` 또는 `as unknown` 사용을 최소화하고, 올바른 타입을 정의한다.
10. **타입 선언 파일 업데이트**: 프로젝트 내 타입 선언(`.d.ts`)을 최신 상태로 유지하여 올바른 타입이 반영되도록 한다.
11. **타입 가드 작성**: 필요한 경우 사용자 정의 타입 가드를 작성하여 any를 구체적인 타입으로 변환한다.
12. **ESLint 규칙 활성화**: `@typescript-eslint/no-explicit-any` 등 규칙을 활성화하여 any 사용을 사전에 감지한다.
13. **타입 체커 활용**: VS Code의 내장 타입 체커와 TSC를 수시로 실행하여 타입 오류를 조기에 발견한다.

---

## 3. 코드 수정 후 기능 손실 방지
14. **기능 회귀 테스트**: 수정 후 반드시 기능 회귀 테스트를 수행하여, 기존 기능이 손실되지 않았는지 확인한다.
15. **커밋 전 스냅샷**: 변경 사항을 커밋하기 전에 diff를 확인하여, 불필요한 코드 누락이 없는지 검토한다.
16. **자동화된 빌드 및 테스트**: CI/CD 파이프라인에 빌드 및 테스트를 포함하여, 모든 변경 사항이 안정적인지 확인한다.
17. **코드 리뷰 절차**: 동료의 코드를 리뷰하여, 수정된 코드가 다른 부분에 영향을 주지 않는지 검증한다.
18. **스냅샷 백업**: 중요한 변경 이전에 코드 스냅샷을 생성해놓고, 문제가 발생하면 즉시 롤백할 수 있도록 한다.
19. **리펙토링 주석 추가**: 수정한 부분에 대해서는 이유와 변경 전후의 동작을 명확하게 주석으로 기록한다.
20. **유닛 테스트 추가**: 수정한 기능에 대해 새로운 유닛 테스트를 추가하여, 동일한 문제가 재발하지 않도록 한다.

---

## 4. 구체적 버그 사례 및 수정 가이드

### a. any 관련 오류 사례
21. **사례**:  
    ```typescript
    function processData(data: any) {
      // ...
    }
    ```  
    **수정**: 구체적 타입을 명시한다.
22. _수정 예시_:  
    ```typescript
    interface Data {
      id: number;
      name: string;
    }
    function processData(data: Data): void {
      // ...
    }
    ```
23. **공식 문서**: [TypeScript: Basic Types](https://www.typescriptlang.org/docs/handbook/basic-types.html)

### b. 불필요한 any 사용 제거
24. **사례**:  
    ```typescript
    let result: any = computeSomething();
    console.log(result);
    ```  
    **수정**: 함수 반환 타입을 명확하게 지정.
25. _수정 예시_:  
    ```typescript
    function computeSomething(): number {
      return 42;
    }
    let result: number = computeSomething();
    console.log(result);
    ```
26. **공식 문서**: [Avoiding the any type](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html)

### c. 타입 불일치 오류
27. **사례**:  
    ```typescript
    let map: Map<string, string> = new Map<string, unknown>();  // 오류 발생
    ```  
    **수정**: 올바른 타입을 사용하거나 타입 단언을 통해 변환.
28. _수정 예시_:  
    ```typescript
    let map: Map<string, unknown> = new Map();
    let strMap: Map<string, string> = new Map();
    const value = map.get("key") as string;
    strMap.set("key", value);
    ```
29. **공식 문서**: [TypeScript: Type Assertions](https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions)

### d. 모듈 종속성 오류
30. **사례**: Import 충돌, 중복 import 문제 등  
    **수정**: 모듈 이름을 명확히 하고, 로컬 선언과 충돌하지 않도록 import 별칭 사용.
31. _수정 예시_:  
    ```typescript
    import { getData as importedGetData } from './data';
    function getData() {
      // 로컬 구현
    }
    ```
32. **공식 문서**: [TypeScript Modules](https://www.typescriptlang.org/docs/handbook/modules.html)

### e. ESLint 경고 (unused vars, no-unused-vars)
33. **사례**: 사용되지 않는 변수 `_error` 등  
    **수정**: 해당 변수를 실제로 사용하거나, 앞에 언더스코어(_)를 붙여 ESLint 규칙에 맞춘다.
34. _수정 예시_:  
    ```typescript
    try {
       // 코드 수행
    } catch (_error) {
       console.error(_error);
    }
    ```
35. **공식 문서**: [ESLint: no-unused-vars](https://eslint.org/docs/rules/no-unused-vars)

### f. 기타 일반적인 버그 수정 지침 (각 항목은 계속)
36. **항상 최신 문서 참조**: 오류 발생 시 공식 문서와 커뮤니티 포럼에서 해결 방법을 찾아본다.
37. **코드 포맷팅 일관성 유지**: Prettier, ESLint 등의 도구를 사용하여 코드 스타일을 유지한다.
38. **타입 검사 강화**: `strict` 옵션을 활성화하여 모든 타입 오류를 미리 잡는다.
39. **함수 책임 분리**: 한 함수에 너무 많은 기능이 있다면, 책임을 분리하여 단일 책임 원칙(SRP)을 준수한다.
40. **반복된 코드 리팩토링**: DRY 원칙을 적용하여 중복 코드를 제거한다.
41. **모듈 테스트**: 각 모듈이 독립적으로 테스트되도록 유닛 테스트를 작성한다.
42. **협업 시 코드 주석 적극 활용**: 다른 팀원이 이해하기 쉽도록 수정 이유 및 변경 사항을 주석으로 남긴다.
43. **버전 관리 활용**: 커밋 메시지에 수정 이유와 변경사항을 명확히 기록하여 추후 리뷰 시 참고할 수 있도록 한다.
44. **의존성 업데이트**: 사용하는 라이브러리나 프레임워크의 최신 버전을 확인하고 업데이트한다.
45. **리팩토링 후 반드시 실행 테스트**: 수정한 코드는 반드시 로컬 및 CI 환경에서 실행 테스트를 거친다.
46. **IDE의 기능 활용**: VS Code의 IntelliSense, 디버깅, 코드 분석 도구를 적극 활용하여 수정 효과를 극대화한다.
47. **대규모 변경 전 스냅샷 찍기**: 중요한 변경 작업 전에는 항상 스냅샷(예: git tag, branch)으로 백업해 둔다.
48. **코드 리뷰 요청**: 혼자 수정하지 말고, 팀원에게 리뷰를 요청하여 빠진 부분이 없는지 확인한다.
49. **문맥 고려**: 수정 대상 코드 주변의 문맥을 충분히 고려하여, 다른 파일이나 모듈의 영향을 고려한다.
50. **명확한 변수 및 함수 네이밍**: 변수와 함수 이름을 명확하게 작성하여 코드 가독성을 높인다.
51. **API 문서 참조**: 사용하는 라이브러리나 프레임워크의 API 문서를 참조하여, 올바른 함수 사용법을 준수한다.
52. **테스트 케이스 기반 수정**: 실패한 테스트 케이스를 기반으로 수정하되, 기존 테스트를 깨지 않도록 주의한다.
53. **에러 처리 강화**: try-catch 구문을 통해 예상치 못한 에러를 처리하고, 충분한 로그를 남긴다.
54. **코드 스멜 제거**: 정적 분석 도구를 활용하여 코드 스멜을 제거한다.
55. **리팩토링 도구 활용**: IDE의 리팩토링 도구를 사용하여 안전하게 코드를 개선한다.
56. **의존성 주입(Dependency Injection) 패턴 사용**: 테스트 및 유지보수를 용이하게 하기 위해 DI 패턴을 적용한다.
57. **데드 코드 제거**: 사용하지 않는 코드와 주석은 정리하여 가독성을 높인다.
58. **설계 패턴 적용 검토**: 상황에 맞게 싱글턴, 팩토리, 전략 등 설계 패턴을 적용하여 구조를 개선한다.
59. **코드 재사용성 고려**: 모듈화와 코드 재사용성에 중점을 두어, 중복 코드를 피한다.
60. **로깅 레벨 설정**: 디버깅 시 필요한 로깅 레벨을 적절히 설정하여, 불필요한 로그 출력은 제거한다.
61. **미래 확장 고려**: 수정 작업을 할 때, 미래의 확장성을 고려하여 인터페이스를 설계한다.
62. **형식 안전성 점검**: 항상 형식 안전성을 보장할 수 있도록, null 체크, 옵셔널 체이닝 등을 적극 활용한다.
63. **버그 재현 과정 문서화**: 버그 발생 시 재현 과정을 문서화하여, 수정 후 동일한 문제가 재발하지 않도록 한다.
64. **CLI 도구 활용**: Git, ESLint, Prettier 등의 CLI 도구를 활용하여 수정 전후 차이를 확인한다.
65. **코드 주석 업데이트**: 수정한 코드와 관련된 주석을 반드시 최신 상태로 업데이트한다.
66. **문서와 코드 동기화**: 코드 변경 사항을 프로젝트 문서에도 반영하여, 전체적인 일관성을 유지한다.
67. **자동화된 배포 파이프라인 테스트**: 코드 수정 후 CI/CD 파이프라인을 통해 자동 테스트 및 빌드를 확인한다.
68. **Git 스쿼시(squash)**: 여러 개의 작은 커밋을 하나의 논리 단위로 합쳐서 이력을 깔끔하게 관리한다.
69. **중간 커밋 태그 사용**: 주요 수정 사항 전후에 태그를 붙여 나중에 쉽게 비교할 수 있도록 한다.
70. **이슈 추적 시스템 활용**: Jira, GitHub Issues 등 이슈 트래킹 시스템과 연동하여 수정한 내용을 기록한다.
71. **코드 콘벤션 준수**: 팀에서 정한 코드 콘벤션을 철저히 준수하여, 코드 일관성을 유지한다.
72. **함수/메서드 길이 제한**: 한 함수 또는 메서드가 너무 길어지지 않도록, 적절히 분할하여 관리한다.
73. **문맥 검증**: 리팩토링 후, 여러 파일에 걸쳐 참조되는 코드가 정상적으로 동작하는지 검증한다.
74. **타입스크립트 strict 옵션 활성화**: `strict: true`를 설정하여, 잠재적 타입 오류를 미리 잡는다.
75. **모듈 별 로깅 기능 강화**: 각 모듈에 대해 별도의 로깅 기능을 구현하여, 버그 발생 시 원인을 쉽게 추적할 수 있게 한다.
76. **성능 프로파일링 도구 사용**: 성능 저하가 의심되면 프로파일러(예: Chrome DevTools, Node.js profiler)로 성능을 점검한다.
77. **스마트 캐시 전략**: 자주 변하지 않는 데이터는 캐시하여, 불필요한 재처리를 줄인다.
78. **동시성 처리 주의**: 비동기 코드 수정 시, race condition을 방지하기 위해 적절한 동기화 메커니즘을 적용한다.
79. **상호참조 문서 생성**: 프로젝트 내 모듈 간 의존성을 시각화한 다이어그램을 생성하여, 구조를 명확히 이해한다.
80. **코드 트랜스파일러 검사**: TypeScript 컴파일러 경고 및 오류를 무시하지 않고 수정하여, 모든 파일이 예상대로 트랜스파일되는지 확인한다.
81. **자동 리팩토링 툴 활용**: IDE와 연동된 자동 리팩토링 도구를 활용해 반복적인 코드를 일관되게 개선한다.
82. **타입 및 인터페이스 일관성 유지**: 다양한 파일에서 사용되는 타입과 인터페이스가 일치하는지 점검한다.
83. **프로젝트 설정 문서화**: tsconfig.json, next.config.ts/js 등 주요 설정 파일의 변경 사항 및 이유를 기록한다.
84. **환경 변수 관리**: 프로젝트에서 사용하는 모든 환경 변수를 명확히 기록하고 관리한다.
85. **외부 라이브러리 업그레이드**: 종종 버그는 오래된 라이브러리에서 발생하므로, 정기적으로 최신 버전으로 업그레이드한다.
86. **리팩토링 전후 성능 비교**: 수정 전후에 성능 테스트를 진행하여, 성능 저하가 발생하지 않았음을 확인한다.
87. **오류 발생 시 스택 트레이스 분석**: 에러 발생 시, 스택 트레이스를 꼼꼼히 분석하여 근본 원인을 파악한다.
88. **커뮤니티 및 포럼 활용**: 동일한 문제에 대한 해결책을 GitHub, Stack Overflow, TypeScript 커뮤니티 등에서 참고한다.
89. **고급 디버깅 기법 적용**: 브레이크포인트, watch 표현식, 로그 출력 등을 활용하여 문제를 상세히 분석한다.
90. **코드 커버리지 확충**: 테스트 커버리지를 높여, 변경 사항이 다른 부분에 미치는 영향을 최소화한다.
91. **프로젝트 빌드 설정 최적화**: Webpack, Rollup, Next.js 설정 등을 점검하여, 빌드 및 번들 과정에서의 문제를 제거한다.
92. **ESLint와 Prettier 설정 동기화**: 팀의 코드 스타일과 문법 검사를 ESLint, Prettier와 일관되게 맞춰서 적용한다.
93. **CI/CD 파이프라인 강화**: 자동 테스트, 린트, 빌드 등이 실패하지 않도록 CI/CD 파이프라인을 잘 관리한다.
94. **코드 배포 전 검토 프로세스**: 실제 배포 전에 코드 리뷰와 QA 프로세스를 통해 수정 사항을 최종 점검한다.
95. **수정 후 문서 업데이트**: 코드 변경과 함께 관련 문서를 최신 상태로 유지하여, 전체적인 정보 누락을 방지한다.
96. **개발 도구 업데이트 확인**: 사용 중인 IDE, 빌드 도구, CLI 도구의 최신 업데이트를 확인하고 적용한다.
97. **오픈 소스 사례 참고**: 비슷한 문제를 해결한 오픈 소스 사례나 GitHub 레포를 참고하여 모범 사례를 적용한다.
98. **효과적인 커밋 메시지 작성**: 커밋 메시지를 통해 무엇을 수정했는지 명확히 기술하여, 추후 문제 해결 시 도움이 되도록 한다.
99. **변경 사항의 영향 범위 확인**: 수정한 코드가 프로젝트 전체에 미치는 영향을 분석하여, 관련 모듈 및 파일에도 문제가 없는지 검증한다.
100. **최종 검증 후 롤백 계획 수립**: 모든 테스트와 리뷰가 완료된 후에도 문제가 발생할 경우를 대비하여 빠른 롤백 계획을 마련해 둔다.

---

## 참고 자료 및 출처

- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)
- [ESLint Official Documentation](https://eslint.org/docs/latest/rules/no-unused-vars)
- [Prettier Documentation](https://prettier.io/docs/en/index.html)
- [Git Best Practices](https://git-scm.com/book/en/v2)
- [Next.js Configuration Documentation](https://nextjs.org/docs/api-reference/next.config.js/introduction)
- [Effective Code Review Guidelines](https://www.atlassian.com/agile/code-reviews)
- [CI/CD Best Practices](https://www.atlassian.com/continuous-delivery/ci-vs-cd)

---

이 가이드라인을 통해 코파일럿이 버그를 수정할 때 반드시 참고해야 할 사항들을 체계적으로 정리할 수 있으며, 수정 후 코드 누락 등의 문제 없이 안정적인 변경을 보장할 수 있다.  
필요에 따라 추가적인 규칙을 보완해도 좋고, 프로젝트 환경에 맞게 유연하게 적용하면 된다.
