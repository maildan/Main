# Loop 프로젝트 분석: 아키텍처 및 개발 가이드

## 1. 프로젝트 개요

Loop는 Electron을 기반으로 구축된 고급 데스크톱 애플리케이션으로, 사용자의 타이핑 패턴과 애플리케이션 사용 통계를 추적하고 분석하도록 설계되었습니다. 이 크로스 플랫폼 도구는 UI를 위한 웹 기술(Next.js/React)을 활용하는 동시에 성능이 중요한 작업을 위해 Rust 기반 네이티브 모듈을 사용합니다.

### 주요 기능

- **실시간 키스트로크 추적**: 사용자의 모든 키보드 입력을 정확하게 캡처하고 분석합니다.
- **애플리케이션 사용 모니터링**: 실행 중인 애플리케이션과 각 애플리케이션에서 소비한 시간을 추적합니다.
- **타이핑 통계 분석**: WPM(분당 단어 수), KPM(분당 키 입력 수), 정확도 등을 실시간으로 계산합니다.
- **타이핑 행동의 패턴 인식**: 사용자의 타이핑 습관과 패턴을 분석하여 인사이트를 제공합니다.
- **메모리 최적화 및 성능 관리**: 장시간 사용 시에도 시스템 리소스를 효율적으로 관리합니다.
- **다중 모드 인터페이스**: 전체 화면과 미니 뷰 모드 간 전환이 가능한 유연한 UI를 제공합니다.
- **시스템 트레이 통합**: 백그라운드에서 실행되면서 시스템 트레이를 통해 쉽게 접근할 수 있습니다.

Loop는 웹 기술과 네이티브 데스크톱 기능을 효과적으로 통합하여 높은 성능을 제공하는 동시에 사용자 친화적인 인터페이스를 유지합니다. 특히 성능이 중요한 작업에 Rust를 활용하고, UI 부분은 React의 컴포넌트 기반 접근 방식을 사용하여 최적의 사용자 경험을 제공합니다.

## 2. 아키텍처

Loop는 웹 기술과 네이티브 데스크톱 기능을 결합한 하이브리드 아키텍처를 따릅니다:

### 주요 아키텍처 패턴

- **Electron 멀티 프로세스**: 메인(Node.js) 프로세스와 렌더러(Chromium) 프로세스 간의 명확한 분리
- **컨텍스트 브리지**: 프리로드 스크립트를 통한 프로세스 간 안전한 통신
- **네이티브 모듈**: Rust 기반의 성능이 중요한 작업과 JavaScript 폴백(fallback) 메커니즘
- **워커 스레딩**: CPU 집약적 작업을 위한 백그라운드 처리
- **컴포넌트 기반 UI**: 상태 관리 로직을 위한 훅을 포함한 React 컴포넌트
- **관심사 분리**: 데이터 처리, UI, 시스템 통합 간의 명확한 경계

### 데이터 흐름

```
사용자 입력/시스템 이벤트 → 메인 프로세스 → Rust 네이티브 모듈 → 메인 프로세스
                                   ↓
                            워커 스레드 ⟷ 메인 프로세스
                                   ↓
                            렌더러 프로세스 → React 컴포넌트
                                   ↓
                          데이터베이스, 시스템 API
```

이 아키텍처 모델에서는:

1. 모든 사용자 입력과 시스템 이벤트가 메인 프로세스에서 처리됩니다.
2. 성능이 중요한 작업은 Rust 네이티브 모듈로 위임됩니다.
3. CPU 집약적인 연산은 워커 스레드에서 비동기적으로 처리됩니다.
4. UI 렌더링과 사용자 상호작용은 렌더러 프로세스에서 관리됩니다.
5. 데이터 지속성과 시스템 수준 작업은 각각 데이터베이스와 시스템 API를 통해 처리됩니다.

이 아키텍처의 주요 장점은 사용자 인터페이스의 응답성을 유지하면서도 리소스를 효율적으로 관리할 수 있다는 점입니다. 워커 스레드와 네이티브 모듈을 사용하여 무거운 계산 작업을 메인 UI 스레드에서 분리함으로써, Loop는 장시간 사용하더라도 일관된 성능을 제공합니다.

## 3. 디렉토리 구조

```
loop/
├── .github/              # GitHub Actions 워크플로우
├── .husky/               # Git 훅(pre-commit)
├── .vscode/              # VS Code 설정
├── docs/                 # 프로젝트 문서
│   ├── ci-cd-guide.md    # CI/CD 설정 가이드
│   ├── eslint-guide.md   # ESLint 구성 가이드
│   └── code-guidelines.md # 코딩 표준
├── native-modules/       # Rust 네이티브 코드
│   ├── src/              # Rust 소스 파일
│   │   ├── lib.rs        # 진입점
│   │   ├── memory/       # 메모리 최적화 모듈
│   │   └── worker/       # 워커 스레드 구현
│   ├── Cargo.toml        # Rust 의존성
│   └── target/           # 컴파일된 출력물
├── prisma/               # 데이터베이스 스키마
│   └── schema.prisma     # Prisma 스키마 정의
├── scripts/              # 자동화 스크립트
│   ├── setup-cicd.js     # CI/CD 설정
│   ├── setup-eslint.js   # ESLint 구성
│   ├── setup-dev.js      # 개발 환경 설정
│   └── fix-eslint-errors.js # 린팅 자동화
├── src/                  # 애플리케이션 소스 코드
│   ├── app/              # Next.js 애플리케이션(렌더러)
│   │   ├── components/   # React 컴포넌트
│   │   ├── hooks/        # 커스텀 React 훅
│   │   ├── utils/        # 클라이언트 측 유틸리티
│   │   ├── api/          # Next.js API 라우트
│   │   ├── globals.css   # 전역 스타일
│   │   ├── page.tsx      # 메인 페이지
│   │   └── layout.tsx    # 루트 레이아웃
│   ├── main/             # Electron 메인 프로세스
│   │   ├── workers/      # 워커 스레드 관리
│   │   ├── stats.js      # 타이핑 통계 코어
│   │   ├── settings.js   # 애플리케이션 설정
│   │   ├── memory-manager.js # 메모리 최적화
│   │   ├── ipc-handlers.js # IPC 메시지 핸들러
│   │   ├── window.js     # 창 관리
│   │   ├── tray.js       # 시스템 트레이 기능
│   │   └── constants.js  # 전역 상수
│   ├── server/           # 서버 측 로직
│   │   ├── native/       # 네이티브 모듈 래퍼
│   │   │   └── utils/    # 네이티브 모듈용 유틸리티
│   │   └── fallback/     # JavaScript 폴백
│   └── types/            # TypeScript 타입 정의
├── .eslintrc.js          # ESLint 구성(레거시)
├── eslint.config.mjs     # ESLint 구성(신규)
├── main.cjs              # Electron 진입점
├── preload.js            # Electron 프리로드 스크립트
├── next.config.js        # Next.js 구성
├── tsconfig.json         # TypeScript 구성
└── package.json          # 프로젝트 메타데이터 및 스크립트
```

이 디렉토리 구조는 다음과 같은 원칙을 따릅니다:

1. **관심사 분리**: 메인 프로세스 코드, 렌더러 코드, 네이티브 모듈, 스크립트가 명확하게 분리되어 있습니다.
2. **모듈성**: 각 기능은 자체 디렉토리에 캡슐화되어 있어 독립적으로 개발하고 테스트할 수 있습니다.
3. **기술 분리**: TypeScript/JavaScript 코드와 Rust 코드가 명확하게 분리되어 있습니다.
4. **구성 중앙화**: 모든 구성 파일이 프로젝트 루트에 위치하여 쉽게 접근할 수 있습니다.

이 구조를 통해 개발자는 애플리케이션의 다양한 부분을 독립적으로 작업할 수 있으며, 코드베이스 탐색이 직관적입니다.

## 4. 기술 스택

### 코어 프레임워크 및 런타임
- **Electron**: 데스크톱 애플리케이션 셸 및 Node.js 런타임
- **Next.js**: 렌더러 프로세스를 위한 React 프레임워크
- **Node.js**: 메인 프로세스를 위한 JavaScript 런타임

### 언어
- **TypeScript**: 프론트엔드(UI) 및 타입 정의를 위한 정적 타이핑
- **JavaScript**: 메인 프로세스 로직 및 워커 스레드
- **Rust**: N-API를 통한 고성능 네이티브 작업

### 데이터베이스 및 스토리지
- **MySQL**: 관계형 데이터베이스(Prisma 사용)
- **Prisma ORM**: 타입 안전 데이터베이스 클라이언트

### UI 프레임워크 및 스타일링
- **React**: 컴포넌트 기반 UI 라이브러리
- **CSS Modules**: 컴포넌트 범위 스타일링
- **Tailwind CSS**: 유틸리티 우선 CSS 프레임워크

### 네이티브 모듈 통합
- **N-API**: Node.js 네이티브 애드온 API
- **Cargo**: Rust 빌드 시스템 및 패키지 관리자

### 빌드 및 개발 도구
- **Yarn**: 패키지 관리자
- **Electron Builder**: 애플리케이션 패키징
- **ESLint**: 코드 린팅
- **Prettier**: 코드 포맷팅
- **Jest**: 테스팅 프레임워크

### 주요 라이브러리
- **active-win**: 활성 창 감지
- **uiohook-napi**: 저수준 키보드/마우스 이벤트 리스닝
- **worker_threads**: Node.js 워커 스레드 관리

## 5. 주요 컴포넌트

### 메인 프로세스(src/main/)

#### 코어 서비스

**stats.js**: 타이핑 통계 추적의 핵심
- `startTracking`/`stopTracking`: 추적 라이프사이클 제어
- `processKeyInput`: 원시 키보드 입력 처리
- `updateAndSendStats`: 주기적으로 통계를 계산하고 전송
- `analyzeTypingPattern`: 워커 스레드에 패턴 분석 요청

**memory-manager.js**: 메모리 최적화
- `process.memoryUsage()` 또는 네이티브 함수를 통한 메모리 사용량 모니터링
- 가비지 컬렉션 및 메모리 최적화 트리거

**workers/index.js**: 백그라운드 처리
- 워커 풀 초기화 및 관리
- 사용 가능한 워커에 태스크 배포
- 네이티브 vs JavaScript 워커 풀 폴백 로직

**settings.js**: 구성 관리
- 사용자 환경설정 로드/저장
- 창 모드 및 기타 설정 적용

**window.js**: Electron 창 관리
- 메인 및 미니뷰 창 생성 및 관리
- 창 상태 지속성(크기, 위치) 처리

#### IPC 통신

**ipc-handlers.js**: 프로세스 간 통신
- 렌더러 요청에 대한 핸들러 등록
- 요청을 적절한 모듈로 라우팅

### 렌더러 프로세스(src/app/)

#### UI 컴포넌트

**React 컴포넌트**: 모듈식 UI 요소
- 통계 디스플레이 및 시각화
- 설정 패널
- 미니뷰 모드 컴포넌트

#### 커스텀 훅

- **useElectronApi**: 프리로드에서 노출된 API에 안전하게 접근
- **useTypingStats**: 타이핑 통계 상태 및 로직 관리
- **useResponsive**: 반응형 디자인 처리
- **useSettings**: 애플리케이션 설정 관리

### 프리로드 스크립트(preload.js)

- 메인 및 렌더러 프로세스 간의 안전한 브리지
- `contextBridge`를 통해 제어된 API 표면 노출
- IPC 메시징 및 이벤트 구독 처리

### 네이티브 모듈(native-modules/ & src/server/native/)

- **Rust 구현**: 고성능 코드
- **JavaScript 래퍼**: 오류 처리 및 폴백 메커니즘
- **성능 메트릭**: 네이티브 함수 실행 시간 추적

## 6. 개발 워크플로우 및 컨벤션

### 개발 환경 설정

```bash
# 의존성 설치
yarn

# 개발 모드에서 실행(Next.js + Electron)
yarn dev

# Next.js 개발 서버만 실행
yarn dev:next

# Electron만 실행
yarn dev:electron
```

### 코드 조직화 규칙

#### 모듈 경계:
- 메인 프로세스 코드는 `src/main/`에 위치해야 함
- 렌더러 프로세스 코드는 `src/app/`에 위치해야 함
- 네이티브 모듈 통합은 `src/server/native/`에 위치해야 함
- 타입 정의는 `src/types/`에 위치해야 함

#### 파일 명명:
- React 컴포넌트: PascalCase(예: `TypingChart.tsx`)
- 훅: camelCase, "use" 접두사 사용(예: `useTypingStats.ts`)
- 메인 프로세스 파일: kebab-case(예: `memory-manager.js`)
- CSS 모듈: 컴포넌트 이름과 일치하며 `.module.css` 접미사 사용

#### 컴포넌트 구조:
- 훅을 사용한 함수형 컴포넌트
- TypeScript 인터페이스로 정의된 props
- 파일 끝에 default export

#### CSS/스타일링:
- 컴포넌트별 스타일을 위한 CSS 모듈 사용
- 앱 전체 스타일을 위한 `globals.css` 사용
- 다크 모드 호환성 유지

#### 코드 스타일 가이드라인:
- ESLint 및 Prettier 구성 준수
- 의미 있는 변수 및 함수 이름 사용
- 함수에 JSDoc 주석 추가
- try/catch로 명시적 오류 처리
- 로깅 유틸리티를 사용한 적절한 로깅

### 커밋 가이드라인

- Husky pre-commit 훅을 사용한 린팅
- 컨벤셔널 커밋 형식 준수
- 해당될 경우 이슈 번호 참조

## 7. 빌드 및 배포 프로세스

```bash
# 빌드 프로세스 흐름
yarn build:native  # Rust 네이티브 모듈 빌드
yarn build         # Next.js 애플리케이션 빌드
yarn package       # Electron Builder로 패키징
```

### Electron Builder 구성

- `package.json`의 build 섹션에 애플리케이션 메타데이터
- 플랫폼별 구성(Windows, macOS, Linux)
- 빌드된 네이티브 모듈 및 컴파일된 Next.js 앱 포함

### CI/CD 파이프라인

- GitHub Actions 워크플로우 또는 GitLab CI
- 테스트 → 빌드 → 배포 단계
- 특정 브랜치에 대한 자동화된 릴리스

## 8. 성능 최적화 전략

### 메모리 관리

- 앱이 비활성 상태일 때 백그라운드 메모리 사용량 감소
- 워커 스레드 메모리 모니터링 및 최적화
- 네이티브 모듈 가비지 컬렉션 헬퍼
- 메모리 집약적 작업에서 재사용 가능한 버퍼

### 워커 스레딩

- CPU 집약적 작업을 별도 스레드로 오프로드
- 복잡한 계산 중에도 UI 블로킹 방지
- CPU 코어 수에 기반한 최적의 크기를 가진 워커 풀

### 네이티브 모듈 통합

- 성능이 중요한 코드 경로에 Rust 사용
- 네이티브 모듈을 사용할 수 없을 때 JavaScript 폴백
- 중요 함수에 대한 성능 측정

### 폴백 메커니즘

- 네이티브 모듈 로드 실패 시 우아한 성능 저하
- 중요 네이티브 함수의 JavaScript 구현
- 폴백 발생에 대한 상세 로깅

## 9. 고급 기능

### 미니뷰 모드

- 통계가 포함된 컴팩트한 플로팅 창
- 항상 위에 표시 기능
- 다양한 시각화 모드

### 메모리 최적화 컨트롤

- 사용자 구성 가능한 메모리 임계값
- 수동 최적화 트리거
- 메모리 사용량 시각화

### 타이핑 패턴 분석

- 자주 사용되는 시퀀스에 대한 N-그램 분석
- 타이핑 리듬 감지 및 분류
- 애플리케이션별 통계 세분화

## 10. 코딩 표준

### TypeScript 사용

- 엄격한 타입 검사
- 컴포넌트 props용 인터페이스
- 네이티브 모듈 인터페이스용 타입 정의
- 특정 상황을 제외하고 `any` 타입 사용 회피

### 오류 처리

- 모든 비동기 작업에 대한 try/catch 블록
- 심각도 수준이 있는 구조화된 로깅
- 중요 함수를 위한 폴백 메커니즘

### 테스팅 가이드라인

- 단위 테스트를 위한 Jest
- 컴포넌트 테스트를 위한 React Testing Library
- Electron/네이티브 의존성 모킹

### 문서화

- 공개 함수를 위한 JSDoc 주석
- 주요 디렉토리에 대한 README 파일
- `/docs`의 아키텍처 문서
- 복잡한 기능에 대한 코드 예제

## 11. 결론

Loop는 웹 기술과 네이티브 데스크톱 기능을 효과적으로 연결하는 Electron 애플리케이션의 정교한 구현을 보여줍니다. 이 아키텍처는, 성능 유지보수성 및 사용자 경험에 대한 신중한 고려를 보여줍니다.

성능이 중요한 작업에는 Rust를 사용하고 UI에는 웹 기술의 유연성을 활용하는 하이브리드 접근 방식은 두 세계의 장점을 모두 제공합니다. 이 접근 방식은 워커 스레딩 및 메모리 최적화 전략과 결합되어 Loop가 리소스 집약적인 작업을 효율적으로 처리할 수 있게 합니다.

잘 구조화된 코드베이스, 포괄적인 문서화, 자동화된 워크플로우는 지속적인 개발과 유지보수를 위한 견고한 기반을 제공합니다.

## 12. 성능 모니터링 및 프로파일링

Loop 애플리케이션은 성능에 중점을 두고 있으며, 이를 위해 다양한 모니터링 및 프로파일링 도구를 통합했습니다:

### 실시간 성능 모니터링

- **메모리 사용량 추적**: 실시간으로 힙 메모리, 외부 메모리, 전체 시스템 메모리 사용량을 모니터링합니다.
- **CPU 사용량**: 주요 연산 및 백그라운드 프로세스의 CPU 사용률을 추적합니다.
- **이벤트 루프 지연**: 메인 스레드의 이벤트 루프 지연을 측정하여 UI 응답성을 모니터링합니다.

### 성능 프로파일링

- **함수 실행 시간 측정**: 각 중요 함수의 실행 시간을 측정하여 성능 병목 현상을 식별합니다.
- **네이티브 코드 프로파일링**: Rust 코드에 내장된 프로파일링 도구를 통해 네이티브 모듈의 성능을 분석합니다.
- **메모리 누수 감지**: 장기 실행 테스트를 통해 메모리 누수를 식별하고 해결합니다.

### 자동화된 성능 테스트

- **벤치마크 스위트**: 주요 기능에 대한 자동화된 벤치마크 테스트를 실행합니다.
- **성능 회귀 테스트**: 새 코드 변경사항이 기존 성능 지표를 저하시키지 않는지 확인합니다.
- **로드 테스트**: 대량의 데이터와 높은 입력 빈도로 시스템을 테스트합니다.

이러한 도구와 프로세스를 통해 Loop는 지속적인 성능 최적화와 안정성을 보장합니다.

## 13. 확장성 및 플러그인 아키텍처

Loop는 미래 확장을 고려하여 설계되었으며, 다음과 같은 확장 메커니즘을 포함합니다:

### 플러그인 시스템

- **플러그인 API**: 타사 개발자가 추가 기능을 개발할 수 있는 문서화된 API
- **동적 로딩**: 런타임에 플러그인을 로드하고 언로드할 수 있는 기능
- **샌드박스 실행**: 플러그인이 안전한 환경에서 실행되도록 보장

### 커스텀 시각화

- **차트 확장 포인트**: 사용자 정의 데이터 시각화 컴포넌트 추가 지원
- **테마 API**: 시각적 테마를 사용자 정의하기 위한 스타일링 훅
- **데이터 내보내기**: 외부 도구에서 분석할 수 있는 표준 형식으로 데이터 내보내기

### 통합 API

- **웹훅**: 외부 시스템에 이벤트 및 데이터 전송
- **REST API**: 다른 애플리케이션과의 통합을 위한 데이터 액세스 엔드포인트
- **확장 가능한 데이터 모델**: 추가 메타데이터 및 사용자 정의 필드 저장 지원

이러한 확장성 기능은 Loop를 다양한 사용 사례에 적응할 수 있는 유연한 플랫폼으로 만듭니다.

## 14. 보안 고려사항

보안은 Loop의 설계 및 구현에서 핵심 고려사항입니다:

### 데이터 보안

- **데이터 암호화**: 저장된 모든 개인 데이터는 업계 표준 알고리즘을 사용하여 암호화됩니다.
- **최소 권한**: 애플리케이션은 필요한 최소한의 시스템 권한으로 실행됩니다.
- **안전한 IPC**: 프로세스 간 통신은 안전한 메시징 패턴을 사용합니다.

### 코드 보안

- **입력 검증**: 모든 사용자 입력과 외부 데이터는 처리 전에 검증됩니다.
- **정기적인 보안 감사**: 코드베이스는 잠재적 취약점에 대해 정기적으로 검토됩니다.
- **의존성 스캐닝**: 모든 타사 라이브러리가 알려진 보안 취약점을 포함하지 않는지 확인합니다.

### 개인정보 보호

- **데이터 최소화**: 필요한 데이터만 수집하고 저장합니다.
- **익명화 옵션**: 사용자가 수집된 데이터를 익명화할 수 있습니다.
- **데이터 삭제**: 사용자가 저장된 모든 개인 데이터를 삭제할 수 있는 기능을 제공합니다.

Loop의 보안 설계는 사용자 데이터를 보호하는 동시에 필요한 모든 기능을 제공하는 균형을 맞추는 것을 목표로 합니다.

## 15. 향후 개발 로드맵

Loop의 미래 개발 방향은 다음과 같은 주요 영역에 초점을 맞추고 있습니다:

### 단기 계획 (0-6개월)

- **성능 최적화**: 메모리 사용량 및 CPU 효율성 개선
- **크로스 플랫폼 향상**: Linux 지원 강화 및 플랫폼별 버그 수정
- **분석 기능 확장**: 더 심층적인 타이핑 패턴 분석 및 보고서 추가

### 중기 계획 (6-12개월)

- **클라우드 동기화**: 여러 장치에서 설정 및 통계 동기화
- **협업 기능**: 팀 대시보드 및 그룹 분석 도구
- **AI 지원 인사이트**: 타이핑 행동에 대한 머신 러닝 기반 분석 및 추천

### 장기 계획 (12개월 이상)

- **확장된 플러그인 에코시스템**: 타사 개발자를 위한 포괄적인 SDK
- **엔터프라이즈 통합**: 기업 환경에서의 대규모 배포 및 관리 도구
- **개인화된 학습 경로**: 사용자의 타이핑 효율성 향상을 위한 맞춤형 연습 및 학습 모듈

이 로드맵은 사용자 피드백과 기술 발전에 따라 조정될 예정입니다.

## 16. 기술적 도전과 해결책

Loop 개발 과정에서 직면한 주요 기술적 도전과 그 해결책:

### 1. 저수준 키보드 이벤트 캡처

**도전**: 운영 체제 수준에서 키보드 이벤트를 효율적이고 안정적으로 캡처하기

**해결책**:
- uiohook-napi 라이브러리의 사용자 정의 버전 개발
- Rust로 작성된 최적화된 키 이벤트 처리 모듈
- 이벤트 큐 구현으로 이벤트 손실 방지

### 2. 장기 실행 중 메모리 누수

**도전**: 장시간 실행 중 JavaScript 및 Electron 프로세스의 메모리 누수

**해결책**:
- 주기적인 가비지 컬렉션 트리거
- 정교한 메모리 사용량 모니터링 시스템
- 메모리 집약적 객체 풀링 및 재사용
- 네이티브 모듈에 메모리 자동 최적화 루틴 구현

### 3. 크로스 플랫폼 호환성

**도전**: Windows, macOS, Linux에서 일관된 사용자 경험 제공

**해결책**:
- 플랫폼별 코드 경로를 위한 추상화 레이어
- 플랫폼별 차이를 처리하기 위한 자동 감지 및 적응 메커니즘
- 각 OS에 맞는 최적화된 네이티브 모듈 빌드 자동화

### 4. 실시간 데이터 처리 및 시각화

**도전**: 지연 없이 대량의 타이핑 데이터 처리 및 시각화

**해결책**:
- 데이터 집계를 위한 효율적인 알고리즘
- 점진적 렌더링 기법을 활용한 React 컴포넌트
- 시각화를 위한 WebGL 가속 활용
- 워커 스레드를 활용한 백그라운드 데이터 처리

이러한 도전과 해결책은 Loop의 기술적 성숙도를 높이고 사용자 경험을 향상시켰습니다.