[{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\ClientLayout.tsx","messages":[{"ruleId":"no-undef","severity":2,"message":"'React' is not defined.","line":8,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":8,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":16,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":22,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'CustomEvent' is not defined.","line":29,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":33,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":33,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'EventListener' is not defined.","line":33,"column":72,"nodeType":"Identifier","messageId":"undef","endLine":33,"endColumn":85},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":36,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":36,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'EventListener' is not defined.","line":36,"column":77,"nodeType":"Identifier","messageId":"undef","endLine":36,"endColumn":90}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { useState, useEffect } from 'react';\r\n\r\nexport function ClientLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  const [darkMode, setDarkMode] = useState(false);\r\n  \r\n  useEffect(() => {\r\n    // 로컬 스토리지에서 다크 모드 설정 불러오기\r\n    const loadDarkModeFromStorage = () => {\r\n      try {\r\n        const savedSettings = localStorage.getItem('app-settings');\r\n        if (savedSettings) {\r\n          const settings = JSON.parse(savedSettings);\r\n          setDarkMode(settings.darkMode || false);\r\n        }\r\n      } catch (e) {\r\n        console.error('설정 파싱 오류:', e);\r\n      }\r\n    };\r\n    \r\n    loadDarkModeFromStorage();\r\n    \r\n    // 이벤트 리스너 설정\r\n    const handleDarkModeChange = (e: CustomEvent) => {\r\n      setDarkMode(e.detail.enabled);\r\n    };\r\n    \r\n    window.addEventListener('darkModeChanged', handleDarkModeChange as EventListener);\r\n    \r\n    return () => {\r\n      window.removeEventListener('darkModeChanged', handleDarkModeChange as EventListener);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div data-theme={darkMode ? 'dark' : 'light'}>\r\n      {children}\r\n    </div>\r\n  );\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\api\\db-test\\route.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":13,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":13,"endColumn":12}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\r\nimport pool from '@/lib/mysql';\r\n\r\nexport async function GET() {\r\n  try {\r\n    const [rows] = await pool.query('SELECT 1+1 AS result');\r\n    return NextResponse.json({ \r\n      success: true, \r\n      message: 'DB 연결 성공', \r\n      result: rows \r\n    }, { status: 200 });\r\n  } catch (error: unknown) {\r\n    console.error('DB 연결 오류:', error);\r\n    return NextResponse.json(\r\n      { success: false, error: String(error) },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\api\\getLogs\\route.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'LogEntry' is defined but never used.","line":5,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'LogEntry' is defined but never used.","line":5,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":31,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":31,"endColumn":12}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\r\nimport pool from '@/lib/mysql';\r\n\r\n// 로그 항목 인터페이스 정의\r\ninterface LogEntry {\r\n  id?: number;\r\n  timestamp: string;\r\n  keyCount: number;\r\n  typingTime: number;\r\n  totalChars: number;\r\n  totalWords: number;\r\n  accuracy: number;\r\n  application: string;\r\n  browser?: string;\r\n  website?: string;\r\n}\r\n\r\n// \"force-dynamic\" 제거 - electron 환경에서는 필요하지 않음\r\n// export const dynamic = 'force-dynamic'; \r\n\r\nexport async function GET() {\r\n  try {\r\n    // SQL 쿼리 직접 실행\r\n    const [rows] = await pool.query(`\r\n      SELECT * FROM typing_logs \r\n      ORDER BY timestamp DESC\r\n    `);\r\n    \r\n    return NextResponse.json({ success: true, logs: rows }, { status: 200 });\r\n  } catch (error: unknown) {\r\n    console.error('DB 조회 오류:', error);\r\n    \r\n    // 에러 발생 시 빈 배열 반환\r\n    return NextResponse.json(\r\n      { success: true, logs: [] },\r\n      { status: 200 }\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\api\\init-db\\route.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":12,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":12}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\r\nimport { initializeDatabase } from '@/lib/mysql';\r\n\r\nexport async function GET() {\r\n  try {\r\n    await initializeDatabase();\r\n    return NextResponse.json({ \r\n      success: true, \r\n      message: 'DB 초기화 성공' \r\n    }, { status: 200 });\r\n  } catch (error: unknown) {\r\n    console.error('DB 초기화 오류:', error);\r\n    return NextResponse.json(\r\n      { success: false, error: String(error) },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\api\\logs\\learn\\route.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'Request' is not defined.","line":20,"column":37,"nodeType":"Identifier","messageId":"undef","endLine":20,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":61,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":61,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":80,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":80,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":110,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":110,"endColumn":12}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 로그 학습 API 엔드포인트\r\n */\r\n\r\nimport { NextResponse } from 'next/server';\r\nimport { \r\n  LearningModelType, \r\n  learnMemoryUsagePatterns,\r\n  learnUserBehaviorPatterns,\r\n  learnErrorPatterns,\r\n  combineRecommendations\r\n} from '@/app/utils/log-learning';\r\n\r\n/**\r\n * 로그 데이터에서 학습을 수행합니다.\r\n * \r\n * @param request - POST 요청\r\n * @returns 학습 결과\r\n */\r\nexport async function POST(request: Request) {\r\n  try {\r\n    const body = await request.json();\r\n    const { modelTypes, options } = body;\r\n    \r\n    // 요청된 모델 타입 확인\r\n    if (!modelTypes || !Array.isArray(modelTypes) || modelTypes.length === 0) {\r\n      return NextResponse.json(\r\n        { success: false, error: '학습할 모델 타입이 지정되지 않았습니다.' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n    \r\n    const results = [];\r\n    const errors = [];\r\n    \r\n    // 요청된 모든 모델 타입에 대해 학습 수행\r\n    for (const modelType of modelTypes) {\r\n      try {\r\n        let result;\r\n        \r\n        switch (modelType) {\r\n          case LearningModelType.MEMORY_OPTIMIZATION:\r\n            result = await learnMemoryUsagePatterns(options?.memory);\r\n            break;\r\n            \r\n          case LearningModelType.USER_BEHAVIOR:\r\n            result = await learnUserBehaviorPatterns(options?.user);\r\n            break;\r\n            \r\n          case LearningModelType.ERROR_PREDICTION:\r\n            result = await learnErrorPatterns(options?.error);\r\n            break;\r\n            \r\n          default:\r\n            errors.push(`지원하지 않는 모델 타입: ${modelType}`);\r\n            continue;\r\n        }\r\n        \r\n        results.push(result);\r\n      } catch (error) {\r\n        console.error(`${modelType} 모델 학습 중 오류:`, error);\r\n        errors.push(`${modelType} 학습 오류: ${error instanceof Error ? error.message : String(error)}`);\r\n      }\r\n    }\r\n    \r\n    // 통합 추천사항 생성\r\n    let combinedRecommendations = [];\r\n    if (results.length > 1) {\r\n      combinedRecommendations = combineRecommendations(results);\r\n    }\r\n    \r\n    return NextResponse.json({\r\n      success: true,\r\n      results,\r\n      combinedRecommendations: combinedRecommendations.length > 0 ? combinedRecommendations : undefined,\r\n      errors: errors.length > 0 ? errors : undefined,\r\n      timestamp: Date.now()\r\n    });\r\n  } catch (error) {\r\n    console.error('로그 학습 중 오류:', error);\r\n    \r\n    return NextResponse.json(\r\n      { \r\n        success: false, \r\n        error: error instanceof Error ? error.message : '로그 학습 중 알 수 없는 오류가 발생했습니다.' \r\n      },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * 학습 진행 상태를 조회합니다.\r\n * \r\n * @returns 학습 상태\r\n */\r\nexport async function GET() {\r\n  try {\r\n    // 학습 상태 정보를 반환합니다.\r\n    // 실제 구현에서는 학습 진행 상태를 추적하는 로직이 필요합니다.\r\n    return NextResponse.json({\r\n      success: true,\r\n      status: {\r\n        isLearning: false,  // 현재 학습 중인지 여부\r\n        lastLearningTime: null,  // 마지막 학습 완료 시간\r\n        availableModels: Object.values(LearningModelType)  // 사용 가능한 모델 타입\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('학습 상태 조회 중 오류:', error);\r\n    \r\n    return NextResponse.json(\r\n      { success: false, error: '학습 상태 조회 중 오류가 발생했습니다.' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\api\\logs\\save\\route.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'Request' is not defined.","line":16,"column":37,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":45,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":45,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":71,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":71,"endColumn":30}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 로그 저장 API 엔드포인트\r\n */\r\n\r\nimport { NextResponse } from 'next/server';\r\nimport { writeFile, mkdir } from 'fs/promises';\r\nimport { join, dirname } from 'path';\r\nimport { LogEntry } from '@/app/utils/log-utils';\r\n\r\n/**\r\n * 로그를 저장합니다.\r\n * \r\n * @param request - POST 요청\r\n * @returns 저장 결과\r\n */\r\nexport async function POST(request: Request) {\r\n  try {\r\n    // 요청 검증\r\n    if (!request.body) {\r\n      return NextResponse.json(\r\n        { success: false, error: '요청 본문이 없습니다.' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n    \r\n    // 로그 데이터 파싱\r\n    const logEntry = await request.json() as LogEntry;\r\n    \r\n    if (!logEntry.type || !logEntry.timestamp) {\r\n      return NextResponse.json(\r\n        { success: false, error: '필수 로그 필드가 누락되었습니다.' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n    \r\n    // 로그 저장\r\n    const savedLog = await saveLogToFile(logEntry);\r\n    \r\n    return NextResponse.json({\r\n      success: true,\r\n      message: '로그가 성공적으로 저장되었습니다.',\r\n      data: savedLog\r\n    });\r\n  } catch (error) {\r\n    console.error('로그 저장 중 오류:', error);\r\n    \r\n    return NextResponse.json(\r\n      { \r\n        success: false, \r\n        error: error instanceof Error ? error.message : '로그 저장 중 알 수 없는 오류가 발생했습니다.' \r\n      },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * 로그를 파일 시스템에 저장합니다.\r\n * \r\n * @param logEntry - 저장할 로그 엔트리\r\n * @returns 저장된 로그 엔트리\r\n */\r\nasync function saveLogToFile(logEntry: LogEntry): Promise<LogEntry> {\r\n  // 로그 저장 디렉토리 경로 생성\r\n  const date = new Date(logEntry.timestamp);\r\n  const year = date.getFullYear();\r\n  const month = (date.getMonth() + 1).toString().padStart(2, '0');\r\n  const day = date.getDate().toString().padStart(2, '0');\r\n  \r\n  // 로그 파일 저장 경로 구성 (public 폴더 하위에 저장)\r\n  const logDir = join(process.cwd(), 'public', 'logs', logEntry.type, `${year}-${month}-${day}`);\r\n  \r\n  // 디렉토리가 없으면 생성\r\n  try {\r\n    await mkdir(dirname(logDir), { recursive: true });\r\n  } catch (error) {\r\n    // 디렉토리가 이미 존재하면 무시\r\n  }\r\n  \r\n  // 파일명 생성 (timestamp + id)\r\n  const fileName = `${logEntry.timestamp}-${logEntry.id || Date.now()}.json`;\r\n  const filePath = join(logDir, fileName);\r\n  \r\n  // 로그를 JSON 형식으로 저장\r\n  await writeFile(filePath, JSON.stringify(logEntry, null, 2), 'utf-8');\r\n  \r\n  return {\r\n    ...logEntry,\r\n    id: logEntry.id || `${Date.now()}-${Math.random().toString(36).substring(2, 10)}`\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\api\\logs\\search\\route.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'Request' is not defined.","line":16,"column":36,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":19,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":19,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":51,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":51,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":82,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":82,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":148,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":148,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":153,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":153,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":158,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":158,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":172,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":172,"endColumn":12}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 로그 검색 API 엔드포인트\r\n */\r\n\r\nimport { NextResponse } from 'next/server';\r\nimport { readdir, readFile } from 'fs/promises';\r\nimport { join } from 'path';\r\nimport { LogEntry, LogSearchOptions, LogType } from '@/app/utils/log-utils';\r\n\r\n/**\r\n * 로그를 검색합니다.\r\n * \r\n * @param request - GET 요청\r\n * @returns 검색 결과\r\n */\r\nexport async function GET(request: Request) {\r\n  try {\r\n    // URL에서 검색 옵션 추출\r\n    const { searchParams } = new URL(request.url);\r\n    const options: LogSearchOptions = {\r\n      type: searchParams.get('type') as LogType || undefined,\r\n      startTime: searchParams.get('startTime') ? parseInt(searchParams.get('startTime')) : undefined,\r\n      endTime: searchParams.get('endTime') ? parseInt(searchParams.get('endTime')) : undefined,\r\n      query: searchParams.get('query') || undefined,\r\n      limit: searchParams.get('limit') ? parseInt(searchParams.get('limit')) : 100,\r\n      offset: searchParams.get('offset') ? parseInt(searchParams.get('offset')) : 0,\r\n      sessionId: searchParams.get('sessionId') || undefined\r\n    };\r\n    \r\n    // 태그 처리 (여러 개 가능)\r\n    const tags = searchParams.getAll('tag');\r\n    if (tags.length > 0) {\r\n      options.tags = tags;\r\n    }\r\n    \r\n    // 여러 타입 처리\r\n    const types = searchParams.getAll('type');\r\n    if (types.length > 1) {\r\n      options.type = types as LogType[];\r\n    }\r\n    \r\n    // 로그 검색\r\n    const logs = await searchLogsFromFiles(options);\r\n    \r\n    return NextResponse.json({\r\n      success: true,\r\n      count: logs.length,\r\n      data: logs\r\n    });\r\n  } catch (error) {\r\n    console.error('로그 검색 중 오류:', error);\r\n    \r\n    return NextResponse.json(\r\n      { \r\n        success: false, \r\n        error: error instanceof Error ? error.message : '로그 검색 중 알 수 없는 오류가 발생했습니다.' \r\n      },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * 파일 시스템에서 로그를 검색합니다.\r\n * \r\n * @param options - 검색 옵션\r\n * @returns 검색된 로그 엔트리 배열\r\n */\r\nasync function searchLogsFromFiles(options: LogSearchOptions): Promise<LogEntry[]> {\r\n  try {\r\n    // 검색할 로그 타입 결정\r\n    const types = Array.isArray(options.type) \r\n      ? options.type \r\n      : options.type \r\n        ? [options.type] \r\n        : Object.values(LogType);\r\n    \r\n    const allLogs: LogEntry[] = [];\r\n    \r\n    // 각 타입별로 로그 검색\r\n    for (const type of types) {\r\n      const typeDir = join(process.cwd(), 'public', 'logs', type);\r\n      \r\n      try {\r\n        // 디렉토리 목록 가져오기 (날짜별 폴더)\r\n        const dateDirs = await readdir(typeDir);\r\n        \r\n        // 날짜 범위 필터링\r\n        const filteredDirs = dateDirs.filter(dirName => {\r\n          // YYYY-MM-DD 형식의 디렉토리만 처리\r\n          if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(dirName)) return false;\r\n          \r\n          if (options.startTime || options.endTime) {\r\n            const [year, month, day] = dirName.split('-').map(Number);\r\n            const dirDate = new Date(year, month - 1, day).getTime();\r\n            \r\n            if (options.startTime && dirDate < options.startTime) return false;\r\n            if (options.endTime && dirDate > options.endTime) return false;\r\n          }\r\n          \r\n          return true;\r\n        });\r\n        \r\n        // 각 날짜 디렉토리에서 로그 파일 가져오기\r\n        for (const dateDir of filteredDirs) {\r\n          const logsDir = join(typeDir, dateDir);\r\n          \r\n          try {\r\n            const logFiles = await readdir(logsDir);\r\n            \r\n            // 각 로그 파일 처리\r\n            for (const file of logFiles) {\r\n              if (!file.endsWith('.json')) continue;\r\n              \r\n              try {\r\n                const logContent = await readFile(join(logsDir, file), 'utf-8');\r\n                const logEntry = JSON.parse(logContent) as LogEntry;\r\n                \r\n                // 시간 범위 필터링\r\n                if (options.startTime && logEntry.timestamp < options.startTime) continue;\r\n                if (options.endTime && logEntry.timestamp > options.endTime) continue;\r\n                \r\n                // 세션 ID 필터링\r\n                if (options.sessionId && logEntry.sessionId !== options.sessionId) continue;\r\n                \r\n                // 태그 필터링\r\n                if (options.tags && options.tags.length > 0) {\r\n                  if (!logEntry.tags || !options.tags.some(tag => logEntry.tags.includes(tag))) {\r\n                    continue;\r\n                  }\r\n                }\r\n                \r\n                // 검색 쿼리 필터링\r\n                if (options.query) {\r\n                  const query = options.query.toLowerCase();\r\n                  const content = (logEntry.content || '').toLowerCase();\r\n                  const metadata = logEntry.metadata \r\n                    ? JSON.stringify(logEntry.metadata).toLowerCase() \r\n                    : '';\r\n                  \r\n                  if (!content.includes(query) && !metadata.includes(query)) {\r\n                    continue;\r\n                  }\r\n                }\r\n                \r\n                allLogs.push(logEntry);\r\n              } catch (error) {\r\n                console.error(`로그 파일 읽기 오류 (${file}):`, error);\r\n                // 개별 파일 오류는 무시하고 계속 진행\r\n              }\r\n            }\r\n          } catch (error) {\r\n            console.error(`날짜 디렉토리 처리 중 오류 (${dateDir}):`, error);\r\n            // 개별 디렉토리 오류는 무시하고 계속 진행\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error(`타입 디렉토리 처리 중 오류 (${type}):`, error);\r\n        // 디렉토리가 없거나 접근할 수 없는 경우 무시하고 계속 진행\r\n      }\r\n    }\r\n    \r\n    // 결과를 타임스탬프 기준 최신순으로 정렬\r\n    allLogs.sort((a, b) => b.timestamp - a.timestamp);\r\n    \r\n    // 페이징 처리\r\n    const offset = options.offset || 0;\r\n    const limit = options.limit || 100;\r\n    \r\n    return allLogs.slice(offset, offset + limit);\r\n  } catch (error) {\r\n    console.error('파일 시스템 로그 검색 중 오류:', error);\r\n    throw error;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\api\\native\\gpu\\acceleration\\route.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'headers' is defined but never used.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'headers' is defined but never used.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":17},{"ruleId":"no-unused-vars","severity":2,"message":"'request' is defined but never used.","line":5,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'request' is defined but never used. Allowed unused args must match /^_/u.","line":5,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":34},{"ruleId":"no-unused-vars","severity":2,"message":"'settings' is assigned a value but never used.","line":56,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":56,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'settings' is assigned a value but never used.","line":56,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":56,"endColumn":21}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { enableGpuAcceleration, disableGpuAcceleration, getGpuAccelerationStatus } from '@/app/utils/gpu-acceleration';\r\nimport { headers } from 'next/headers';\r\n\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    const status = await getGpuAccelerationStatus();\r\n    \r\n    return NextResponse.json({ \r\n      success: true, \r\n      enabled: status.enabled,\r\n      available: status.available,\r\n      info: status.info || null\r\n    });\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : String(error);\r\n    \r\n    return NextResponse.json({\r\n      success: false,\r\n      enabled: false,\r\n      error: errorMessage\r\n    }, { status: 500 });\r\n  }\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const requestData = await request.json();\r\n    const enableAcceleration = requestData.enable === true;\r\n    \r\n    let result;\r\n    if (enableAcceleration) {\r\n      result = await enableGpuAcceleration();\r\n    } else {\r\n      result = await disableGpuAcceleration();\r\n    }\r\n    \r\n    return NextResponse.json({\r\n      success: true,\r\n      enabled: result.enabled,\r\n      message: result.message || null\r\n    });\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : String(error);\r\n    \r\n    return NextResponse.json({\r\n      success: false,\r\n      error: errorMessage\r\n    }, { status: 500 });\r\n  }\r\n}\r\n\r\nexport async function PUT(request: NextRequest) {\r\n  try {\r\n    const requestData = await request.json();\r\n    const { settings } = requestData;\r\n    \r\n    // 설정 적용 로직 구현 (임시)\r\n    const success = true;\r\n    const message = '설정이 적용되었습니다';\r\n    \r\n    return NextResponse.json({\r\n      success,\r\n      message\r\n    });\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : String(error);\r\n    \r\n    return NextResponse.json({\r\n      success: false,\r\n      error: errorMessage\r\n    }, { status: 500 });\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\api\\native\\gpu\\route.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":22,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Request' is not defined.","line":32,"column":37,"nodeType":"Identifier","messageId":"undef","endLine":32,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":62,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":62,"endColumn":12}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\r\n\r\n// GPU 정보 조회\r\nexport async function GET() {\r\n  try {\r\n    // 서버 측 네이티브 모듈 가져오기\r\n    const nativeModule = await import('../../../../server/native');\r\n    \r\n    // GPU 가용성 확인\r\n    const isAvailable = nativeModule.default.isGpuAccelerationAvailable();\r\n    \r\n    // GPU 정보 가져오기\r\n    const gpuInfo = nativeModule.default.getGpuInfo();\r\n    \r\n    return NextResponse.json({\r\n      success: true,\r\n      available: isAvailable,\r\n      gpuInfo,\r\n      timestamp: Date.now()\r\n    });\r\n  } catch (error) {\r\n    console.error('GPU 정보 가져오기 오류:', error);\r\n    return NextResponse.json({\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'GPU 정보를 가져오는 중 오류가 발생했습니다',\r\n      timestamp: Date.now()\r\n    }, { status: 500 });\r\n  }\r\n}\r\n\r\n// GPU 계산 작업 수행\r\nexport async function POST(request: Request) {\r\n  try {\r\n    const body = await request.json();\r\n    \r\n    // 서버 측 네이티브 모듈 가져오기\r\n    const nativeModule = await import('../../../../server/native');\r\n    \r\n    // GPU 가용성 확인\r\n    const isAvailable = nativeModule.default.isGpuAccelerationAvailable();\r\n    \r\n    if (!isAvailable) {\r\n      return NextResponse.json({\r\n        success: false,\r\n        error: 'GPU 가속화를 사용할 수 없습니다',\r\n        timestamp: Date.now()\r\n      }, { status: 400 });\r\n    }\r\n    \r\n    // GPU 계산 수행\r\n    const result = await nativeModule.default.performGpuComputation(\r\n      body.data || '{}',\r\n      body.computationType || 'matrix'\r\n    );\r\n    \r\n    return NextResponse.json({\r\n      success: true,\r\n      result,\r\n      timestamp: Date.now()\r\n    });\r\n  } catch (error) {\r\n    console.error('GPU 계산 오류:', error);\r\n    return NextResponse.json({\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'GPU 계산을 수행하는 중 오류가 발생했습니다',\r\n      timestamp: Date.now()\r\n    }, { status: 500 });\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\api\\native\\gpu\\settings\\route.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'request' is defined but never used.","line":6,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'request' is defined but never used. Allowed unused args must match /^_/u.","line":6,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'require' is not defined.","line":9,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":21,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":21,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'require' is not defined.","line":39,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":39,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":49,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":49,"endColumn":12}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\n\r\n/**\r\n * GPU 설정 가져오기 API\r\n */\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    // 서버 측에서 네이티브 모듈 불러오기\r\n    const nativeModule = require('../../../../../../../native-modules');\r\n    \r\n    // GPU 설정 가져오기\r\n    const settingsJson = nativeModule.get_gpu_settings_json();\r\n    const settings = JSON.parse(settingsJson);\r\n    \r\n    return NextResponse.json({\r\n      success: true,\r\n      settings,\r\n      timestamp: Date.now()\r\n    });\r\n  } catch (error) {\r\n    console.error('GPU 설정 가져오기 API 오류:', error);\r\n    return NextResponse.json({\r\n      success: false,\r\n      settings: null,\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\r\n      timestamp: Date.now()\r\n    }, { status: 500 });\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 설정 업데이트 API\r\n */\r\nexport async function PUT(request: NextRequest) {\r\n  try {\r\n    const settingsJson = await request.text();\r\n    \r\n    // 서버 측에서 네이티브 모듈 불러오기\r\n    const nativeModule = require('../../../../../../../native-modules');\r\n    \r\n    // GPU 설정 업데이트\r\n    const success = nativeModule.update_gpu_settings_json(settingsJson);\r\n    \r\n    return NextResponse.json({\r\n      success,\r\n      timestamp: Date.now()\r\n    });\r\n  } catch (error) {\r\n    console.error('GPU 설정 업데이트 API 오류:', error);\r\n    return NextResponse.json({\r\n      success: false,\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\r\n      timestamp: Date.now()\r\n    }, { status: 500 });\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\api\\native\\memory\\route.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":28,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":28,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Request' is not defined.","line":42,"column":37,"nodeType":"Identifier","messageId":"undef","endLine":42,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":68,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":68,"endColumn":12}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 메모리 정보를 제공하는 API 라우트\r\n */\r\n\r\nimport { NextResponse } from 'next/server';\r\nimport { optimizeMemory } from '../../../utils/memory-optimizer';\r\nimport { getMemoryUsage } from '../../../utils/memory/memory-info';\r\nimport { formatBytes } from '../../../utils/common-utils';\r\nimport { OptimizationLevel } from '../../../../types';\r\n\r\n/**\r\n * GET 핸들러 - 메모리 사용량 정보 조회\r\n */\r\nexport async function GET() {\r\n  try {\r\n    const memoryInfo = await getMemoryUsage();\r\n    \r\n    return NextResponse.json({\r\n      success: true,\r\n      data: {\r\n        ...memoryInfo,\r\n        heapUsedFormatted: formatBytes(memoryInfo.heapUsed),\r\n        heapTotalFormatted: formatBytes(memoryInfo.heapTotal),\r\n        rssFormatted: formatBytes(memoryInfo.rss)\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching memory info:', error);\r\n    return NextResponse.json(\r\n      {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * POST 핸들러 - 메모리 최적화 요청 처리\r\n */\r\nexport async function POST(request: Request) {\r\n  try {\r\n    const { level = 'medium', emergency = false } = await request.json();\r\n    \r\n    // 최적화 레벨 검증\r\n    const optimizationLevel = Object.values(OptimizationLevel).includes(level as OptimizationLevel)\r\n      ? level as OptimizationLevel\r\n      : OptimizationLevel.MEDIUM;\r\n    \r\n    // 메모리 최적화 실행\r\n    const result = await optimizeMemory(optimizationLevel, emergency);\r\n    \r\n    // 최적화 후 메모리 정보 조회\r\n    const memoryInfo = await getMemoryUsage();\r\n    \r\n    return NextResponse.json({\r\n      success: true,\r\n      result,\r\n      memoryInfo: {\r\n        ...memoryInfo,\r\n        heapUsedFormatted: formatBytes(memoryInfo.heapUsed),\r\n        heapTotalFormatted: formatBytes(memoryInfo.heapTotal),\r\n        rssFormatted: formatBytes(memoryInfo.rss)\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Error optimizing memory:', error);\r\n    return NextResponse.json(\r\n      {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\api\\native\\memory\\settings\\initialize\\route.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'require' is not defined.","line":11,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":20,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":20,"endColumn":12}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\n\r\n/**\r\n * 메모리 설정 초기화 API\r\n */\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const settingsJson = await request.text();\r\n    \r\n    // 서버 측에서 네이티브 모듈 불러오기\r\n    const nativeModule = require('../../../../../../../native-modules');\r\n    \r\n    const success = await nativeModule.initialize_memory_settings(settingsJson);\r\n    \r\n    return NextResponse.json({\r\n      success: !!success,\r\n      timestamp: Date.now()\r\n    });\r\n  } catch (error) {\r\n    console.error('메모리 설정 초기화 API 오류:', error);\r\n    return NextResponse.json({\r\n      success: false,\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\r\n      timestamp: Date.now()\r\n    }, { status: 500 });\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\api\\native\\memory\\settings\\route.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'request' is defined but never used.","line":6,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'request' is defined but never used. Allowed unused args must match /^_/u.","line":6,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'require' is not defined.","line":9,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":21,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":21,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'require' is not defined.","line":39,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":39,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":48,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":48,"endColumn":12}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\n\r\n/**\r\n * 메모리 설정 가져오기 API\r\n */\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    // 서버 측에서 네이티브 모듈 불러오기\r\n    const nativeModule = require('../../../../../../../native-modules');\r\n    \r\n    // 설정 가져오기\r\n    const settingsJson = nativeModule.get_settings_json();\r\n    const settings = JSON.parse(settingsJson);\r\n    \r\n    return NextResponse.json({\r\n      success: true,\r\n      settings,\r\n      timestamp: Date.now()\r\n    });\r\n  } catch (error) {\r\n    console.error('메모리 설정 가져오기 API 오류:', error);\r\n    return NextResponse.json({\r\n      success: false,\r\n      settings: null,\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\r\n      timestamp: Date.now()\r\n    }, { status: 500 });\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 설정 초기화 API\r\n */\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const settingsJson = await request.text();\r\n    \r\n    // 서버 측에서 네이티브 모듈 불러오기\r\n    const nativeModule = require('../../../../../../native-modules');\r\n    \r\n    const success = await nativeModule.initialize_memory_settings(settingsJson);\r\n    \r\n    return NextResponse.json({\r\n      success: !!success,\r\n      timestamp: Date.now()\r\n    });\r\n  } catch (error) {\r\n    console.error('메모리 설정 초기화 API 오류:', error);\r\n    return NextResponse.json({\r\n      success: false,\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\r\n      timestamp: Date.now()\r\n    }, { status: 500 });\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\api\\native\\memory\\settings\\update\\route.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'require' is not defined.","line":11,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":20,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":20,"endColumn":12}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\n\r\n/**\r\n * 메모리 설정 업데이트 API\r\n */\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const settingsJson = await request.text();\r\n    \r\n    // 서버 측에서 네이티브 모듈 불러오기\r\n    const nativeModule = require('../../../../../../../native-modules');\r\n    \r\n    const success = await nativeModule.update_memory_settings(settingsJson);\r\n    \r\n    return NextResponse.json({\r\n      success: !!success,\r\n      timestamp: Date.now()\r\n    });\r\n  } catch (error) {\r\n    console.error('메모리 설정 업데이트 API 오류:', error);\r\n    return NextResponse.json({\r\n      success: false,\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\r\n      timestamp: Date.now()\r\n    }, { status: 500 });\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\api\\native\\status\\route.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":39,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":39,"endColumn":12}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\r\n\r\n// 네이티브 모듈 상태 조회\r\nexport async function GET() {\r\n  try {\r\n    // 서버 측 네이티브 모듈 가져오기\r\n    const nativeModule = await import('../../../../server/native');\r\n    \r\n    // 네이티브 모듈 가용성 확인\r\n    const isAvailable = nativeModule.default.isNativeModuleAvailable();\r\n    const isFallback = nativeModule.default.isFallbackMode();\r\n    \r\n    // 네이티브 모듈 버전 및 정보 가져오기\r\n    let version = null;\r\n    let info = null;\r\n    \r\n    if (isAvailable) {\r\n      version = nativeModule.default.getNativeModuleVersion();\r\n      info = nativeModule.default.getNativeModuleInfo();\r\n    }\r\n    \r\n    // GPU 가용성 확인\r\n    const gpuAvailable = nativeModule.default.isGpuAccelerationAvailable?.() || false;\r\n    \r\n    return NextResponse.json({\r\n      success: true,\r\n      available: isAvailable,\r\n      fallbackMode: isFallback,\r\n      version,\r\n      info,\r\n      features: {\r\n        memory: isAvailable,\r\n        gpu: gpuAvailable,\r\n        worker: isAvailable && !isFallback\r\n      },\r\n      timestamp: Date.now()\r\n    });\r\n  } catch (error) {\r\n    console.error('네이티브 모듈 상태 조회 오류:', error);\r\n    return NextResponse.json({\r\n      success: false,\r\n      error: error instanceof Error ? error.message : '네이티브 모듈 상태를 조회하는 중 오류가 발생했습니다',\r\n      timestamp: Date.now()\r\n    }, { status: 500 });\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\api\\native\\worker\\route.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'request' is defined but never used.","line":12,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'request' is defined but never used. Allowed unused args must match /^_/u.","line":12,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":22,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":54,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":54,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":92,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":92,"endColumn":12}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { \r\n  initializeWorkerPool,\r\n  shutdownWorkerPool,\r\n  submitTask,\r\n  getWorkerPoolStats\r\n} from '@/server/native';\r\n\r\n/**\r\n * 워커 풀 상태 확인 API\r\n */\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    const stats = getWorkerPoolStats();\r\n    \r\n    return NextResponse.json({\r\n      success: true,\r\n      stats,\r\n      timestamp: Date.now()\r\n    });\r\n  } catch (error) {\r\n    console.error('워커 풀 상태 API 오류:', error);\r\n    return NextResponse.json({\r\n      success: false,\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\r\n      timestamp: Date.now()\r\n    }, { status: 500 });\r\n  }\r\n}\r\n\r\n/**\r\n * 작업 제출 API\r\n */\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const { taskType, data } = await request.json();\r\n    \r\n    if (!taskType || !data) {\r\n      return NextResponse.json({\r\n        success: false,\r\n        error: '유효하지 않은 요청 파라미터',\r\n        timestamp: Date.now()\r\n      }, { status: 400 });\r\n    }\r\n    \r\n    const result = await submitTask(taskType, JSON.stringify(data));\r\n    \r\n    return NextResponse.json({\r\n      success: true,\r\n      result,\r\n      timestamp: Date.now()\r\n    });\r\n  } catch (error) {\r\n    console.error('작업 제출 API 오류:', error);\r\n    return NextResponse.json({\r\n      success: false,\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\r\n      timestamp: Date.now()\r\n    }, { status: 500 });\r\n  }\r\n}\r\n\r\n/**\r\n * 워커 풀 초기화/종료 API\r\n */\r\nexport async function PUT(request: NextRequest) {\r\n  try {\r\n    const { action, threadCount } = await request.json();\r\n    \r\n    if (action === 'initialize') {\r\n      const result = initializeWorkerPool(threadCount || 0);\r\n      return NextResponse.json({\r\n        success: result,\r\n        action: 'initialize',\r\n        timestamp: Date.now()\r\n      });\r\n    } else if (action === 'shutdown') {\r\n      const result = shutdownWorkerPool();\r\n      return NextResponse.json({\r\n        success: result,\r\n        action: 'shutdown',\r\n        timestamp: Date.now()\r\n      });\r\n    } else {\r\n      return NextResponse.json({\r\n        success: false,\r\n        error: '유효하지 않은 액션',\r\n        timestamp: Date.now()\r\n      }, { status: 400 });\r\n    }\r\n  } catch (error) {\r\n    console.error('워커 풀 제어 API 오류:', error);\r\n    return NextResponse.json({\r\n      success: false,\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\r\n      timestamp: Date.now()\r\n    }, { status: 500 });\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\api\\saveLogs\\route.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":34,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":12}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport pool from '@/lib/mysql';\r\n\r\nexport async function POST(req: NextRequest) {\r\n  try {\r\n    const body = await req.json();\r\n    const { \r\n      content, \r\n      keyCount, \r\n      typingTime, \r\n      timestamp, \r\n      windowTitle,\r\n      // 아래 변수들은 현재 사용되지 않지만 나중에 사용될 수 있으므로 주석 처리합니다\r\n      // totalChars,\r\n      // totalCharsNoSpace,\r\n      // totalWords,\r\n      // pages,\r\n      // accuracy\r\n    } = body;\r\n\r\n    // 데이터베이스에 추가 필드를 저장하기 위한 SQL 쿼리 (기존 테이블 구조에 따라 조정 필요)\r\n    // 기존 테이블에 추가 필드가 없다면 알터 테이블을 실행하거나 기존 필드만 저장해야 함\r\n    await pool.query(\r\n      `INSERT INTO typing_logs (content, key_count, typing_time, window_title, timestamp)\r\n       VALUES (?, ?, ?, ?, ?)`,\r\n      [content, keyCount, typingTime, windowTitle, new Date(timestamp)]\r\n    );\r\n\r\n    return NextResponse.json({ \r\n      success: true,\r\n      message: '데이터가 성공적으로 저장되었습니다.' \r\n    }, { status: 200 });\r\n  } catch (error: unknown) {\r\n    console.error('DB 저장 오류:', error);\r\n    return NextResponse.json(\r\n      { success: false, error: String(error) },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\AppFooter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\AppHeader.tsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'visible' is defined but never used.","line":12,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'HTMLDivElement' is not defined.","line":25,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":25,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":26,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":26,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'MouseEvent' is not defined.","line":35,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":35,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":41,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":41,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":42,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":42,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":54,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":54,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":62,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":62,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":69,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":69,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":74,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":74,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":86,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":86,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":88,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":88,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":106,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":106,"endColumn":44}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { memo, useState, useEffect, useRef } from 'react';\r\nimport { useTheme } from './ThemeProvider';\r\nimport { WindowControls } from './WindowControls';\r\nimport styles from './AppHeader.module.css';\r\nimport Image from 'next/image';\r\n\r\ninterface AppHeaderProps {\r\n  api: any;\r\n  isVisible?: boolean;\r\n  onVisibilityChange?: (visible: boolean) => void;\r\n  autoHide?: boolean;\r\n}\r\n\r\nexport const AppHeader = memo(function AppHeader({ \r\n  api, \r\n  isVisible = true, \r\n  onVisibilityChange,\r\n  autoHide = false\r\n}: AppHeaderProps) {\r\n  const { theme } = useTheme();\r\n  const [visibility, setVisibility] = useState(isVisible);\r\n  const lastMouseY = useRef(0);\r\n  const headerRef = useRef<HTMLDivElement>(null);\r\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n  const mouseInsideHeader = useRef(false);\r\n\r\n  useEffect(() => {\r\n    setVisibility(isVisible);\r\n  }, [isVisible]);\r\n\r\n  useEffect(() => {\r\n    if (!autoHide) return;\r\n    const handleMouseMove = (e: MouseEvent) => {\r\n      const currentY = e.clientY;\r\n      if (currentY < 20 && !visibility) {\r\n        setVisibility(true);\r\n        onVisibilityChange && onVisibilityChange(true);\r\n      } else if (currentY > 80 && !mouseInsideHeader.current && visibility) {\r\n        if (timeoutRef.current) clearTimeout(timeoutRef.current);\r\n        timeoutRef.current = setTimeout(() => {\r\n          setVisibility(false);\r\n          onVisibilityChange && onVisibilityChange(false);\r\n          timeoutRef.current = null;\r\n        }, 1000);\r\n      }\r\n      lastMouseY.current = currentY;\r\n    };\r\n    \r\n    const handleHeaderMouseEnter = () => {\r\n      mouseInsideHeader.current = true;\r\n      if (timeoutRef.current) {\r\n        clearTimeout(timeoutRef.current);\r\n        timeoutRef.current = null;\r\n      }\r\n    };\r\n    const handleHeaderMouseLeave = () => {\r\n      mouseInsideHeader.current = false;\r\n    };\r\n    \r\n    document.addEventListener('mousemove', handleMouseMove);\r\n    const headerElement = headerRef.current;\r\n    if (headerElement) {\r\n      headerElement.addEventListener('mouseenter', handleHeaderMouseEnter);\r\n      headerElement.addEventListener('mouseleave', handleHeaderMouseLeave);\r\n    }\r\n    return () => {\r\n      document.removeEventListener('mousemove', handleMouseMove);\r\n      if (headerElement) {\r\n        headerElement.removeEventListener('mouseenter', handleHeaderMouseEnter);\r\n        headerElement.removeEventListener('mouseleave', handleHeaderMouseLeave);\r\n      }\r\n      if (timeoutRef.current) clearTimeout(timeoutRef.current);\r\n    };\r\n  }, [autoHide, visibility, onVisibilityChange]);\r\n  \r\n  useEffect(() => {\r\n    if (!autoHide) return;\r\n    const handleClick = () => {\r\n      if (!visibility) {\r\n        setVisibility(true);\r\n        onVisibilityChange && onVisibilityChange(true);\r\n      }\r\n    };\r\n    document.addEventListener('click', handleClick);\r\n    return () => {\r\n      document.removeEventListener('click', handleClick);\r\n    };\r\n  }, [autoHide, visibility, onVisibilityChange]);\r\n\r\n  return (\r\n    <div \r\n      ref={headerRef}\r\n      className={`${styles.header} ${!visibility ? styles.hidden : ''} ${theme === 'dark' ? styles.darkMode : ''}`}\r\n      aria-hidden={!visibility}\r\n    >\r\n      <div className={styles.titleBar}>\r\n        <div className={styles.appIcon}>\r\n          <Image \r\n            src=\"/app-icon.png\" \r\n            alt=\"App Icon\"\r\n            width={24}\r\n            height={24}\r\n            onError={(e) => {\r\n              (e.target as HTMLImageElement).style.display = 'none';\r\n            }}\r\n          />\r\n        </div>\r\n        <div className={styles.appTitle}>타이핑 통계 앱</div>\r\n        <WindowControls api={api} />\r\n      </div>\r\n    </div>\r\n  );\r\n});","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\ClientLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\ClientSideControls.tsx","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":46,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":46,"endColumn":42},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":46,"column":35,"nodeType":"MemberExpression","messageId":"unexpected","endLine":46,"endColumn":46}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { useState } from 'react';\r\nimport dynamic from 'next/dynamic';\r\n\r\nconst NativeModuleTestPanel = dynamic(() => import('./NativeModuleTestPanel'), { ssr: false });\r\n// TypingAnalyzer가 named export이므로 아래와 같이 수정\r\nconst DynamicTypingAnalyzer = dynamic(\r\n  () => import('./TypingAnalyzer').then(mod => mod.TypingAnalyzer),\r\n  { ssr: false }\r\n);\r\n\r\n// 타이핑 샘플 데이터\r\nconst sampleTypingData = {\r\n  keyCount: 650,\r\n  typingTime: 90000, // 1분 30초\r\n  accuracy: 97.2\r\n};\r\n\r\nexport default function ClientSideControls() {\r\n  const [showTest, setShowTest] = useState<boolean>(false);\r\n  const [showDemo, setShowDemo] = useState<boolean>(false);\r\n\r\n  return (\r\n    <>\r\n      <div className=\"text-center my-4 space-x-4\">\r\n        <button \r\n          onClick={() => setShowTest(!showTest)}\r\n          className=\"bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded\"\r\n        >\r\n          {showTest ? '테스트 패널 숨기기' : '네이티브 모듈 테스트 패널 표시'}\r\n        </button>\r\n        \r\n        <button \r\n          onClick={() => setShowDemo(!showDemo)}\r\n          className=\"bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded\"\r\n        >\r\n          {showDemo ? '데모 숨기기' : '타이핑 분석 데모 표시'}\r\n        </button>\r\n      </div>\r\n      \r\n      {showDemo && (\r\n        <div className=\"mb-8 max-w-2xl mx-auto\">\r\n          <DynamicTypingAnalyzer \r\n            data={sampleTypingData} \r\n            onResult={(result) => console.log('분석 결과:', result)}\r\n          />\r\n        </div>\r\n      )}\r\n      \r\n      {showTest && <NativeModuleTestPanel />}\r\n    </>\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\CustomHeader.tsx","messages":[{"ruleId":"no-undef","severity":2,"message":"'HTMLDivElement' is not defined.","line":19,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":19,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'HTMLDivElement' is not defined.","line":20,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":20,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":21,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":21,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":43,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":43,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":53,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":53,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'MouseEvent' is not defined.","line":61,"column":43,"nodeType":"Identifier","messageId":"undef","endLine":61,"endColumn":53},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":68,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":68,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":74,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":74,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":92,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":92,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":104,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":104,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":116,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":116,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":151,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":151,"endColumn":38}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { memo, useState, useEffect, useRef, useCallback } from 'react';\r\nimport { WindowControls } from './WindowControls';\r\nimport styles from './CustomHeader.module.css';\r\nimport Image from 'next/image';\r\n\r\ninterface CustomHeaderProps {\r\n  darkMode: boolean;\r\n  windowMode: string;\r\n}\r\n\r\nexport const CustomHeader = memo(function CustomHeader({ \r\n  darkMode, \r\n  windowMode \r\n}: CustomHeaderProps) {\r\n  const [isVisible, setIsVisible] = useState(true);\r\n  const [isAutoHide, setIsAutoHide] = useState(windowMode === 'fullscreen-auto-hide');\r\n  const headerRef = useRef<HTMLDivElement>(null);\r\n  const detectionAreaRef = useRef<HTMLDivElement>(null);\r\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n  const mouseInsideHeader = useRef(false);\r\n  \r\n  // 창 모드에 따른 자동 숨김 활성화 여부 설정\r\n  useEffect(() => {\r\n    setIsAutoHide(windowMode === 'fullscreen-auto-hide');\r\n    if (windowMode !== 'fullscreen-auto-hide') {\r\n      setIsVisible(true);\r\n    }\r\n  }, [windowMode]);\r\n  \r\n  // 마우스 감지 영역 이벤트 핸들러를 메모이제이션\r\n  const handleDetectionAreaEnter = useCallback(() => {\r\n    if (isAutoHide) {\r\n      setIsVisible(true);\r\n    }\r\n  }, [isAutoHide]);\r\n  \r\n  // 헤더 마우스 이벤트 핸들러를 메모이제이션\r\n  const handleMouseEnter = useCallback(() => {\r\n    mouseInsideHeader.current = true;\r\n    if (timeoutRef.current) {\r\n      clearTimeout(timeoutRef.current);\r\n      timeoutRef.current = null;\r\n    }\r\n    setIsVisible(true);\r\n  }, []);\r\n  \r\n  const handleMouseLeave = useCallback(() => {\r\n    mouseInsideHeader.current = false;\r\n    // 마우스가 헤더를 떠나면 타이머 설정\r\n    if (isAutoHide && !timeoutRef.current) {\r\n      timeoutRef.current = setTimeout(() => {\r\n        setIsVisible(false);\r\n        timeoutRef.current = null;\r\n      }, 600);\r\n    }\r\n  }, [isAutoHide]);\r\n\r\n  // 마우스 움직임 감지 함수를 메모이제이션\r\n  const handleMouseMove = useCallback((e: MouseEvent) => {\r\n    const { clientY } = e;\r\n    \r\n    // 마우스가 화면 상단 10px 이내에 있으면 도구모음 표시\r\n    if (clientY < 10) {\r\n      setIsVisible(true);\r\n      if (timeoutRef.current) {\r\n        clearTimeout(timeoutRef.current);\r\n        timeoutRef.current = null;\r\n      }\r\n    } else if (clientY > 100 && isVisible && !mouseInsideHeader.current) {\r\n      // 마우스가 헤더 영역을 벗어났고, 아래로 이동한 경우 타이머 설정\r\n      if (!timeoutRef.current) {\r\n        timeoutRef.current = setTimeout(() => {\r\n          if (!mouseInsideHeader.current) {\r\n            setIsVisible(false);\r\n          }\r\n          timeoutRef.current = null;\r\n        }, 600);\r\n      }\r\n    }\r\n  }, [isVisible]);\r\n  \r\n  // 마우스 움직임 감지 및 도구모음 표시/숨김 처리 최적화\r\n  useEffect(() => {\r\n    if (!isAutoHide) {\r\n      setIsVisible(true);\r\n      return;\r\n    }\r\n    \r\n    // passive 옵션을 true로 설정하여 성능 향상\r\n    window.addEventListener('mousemove', handleMouseMove, { passive: true });\r\n    \r\n    if (headerRef.current) {\r\n      headerRef.current.addEventListener('mouseenter', handleMouseEnter);\r\n      headerRef.current.addEventListener('mouseleave', handleMouseLeave);\r\n    }\r\n    \r\n    if (detectionAreaRef.current) {\r\n      detectionAreaRef.current.addEventListener('mouseenter', handleDetectionAreaEnter);\r\n    }\r\n    \r\n    return () => {\r\n      window.removeEventListener('mousemove', handleMouseMove);\r\n      \r\n      if (headerRef.current) {\r\n        headerRef.current.removeEventListener('mouseenter', handleMouseEnter);\r\n        headerRef.current.removeEventListener('mouseleave', handleMouseLeave);\r\n      }\r\n      \r\n      if (detectionAreaRef.current) {\r\n        detectionAreaRef.current.removeEventListener('mouseenter', handleDetectionAreaEnter);\r\n      }\r\n      \r\n      if (timeoutRef.current) {\r\n        clearTimeout(timeoutRef.current);\r\n      }\r\n    };\r\n  }, [isAutoHide, handleMouseMove, handleMouseEnter, handleMouseLeave, handleDetectionAreaEnter]);\r\n\r\n  return (\r\n    <>\r\n      {isAutoHide && (\r\n        <div \r\n          ref={detectionAreaRef}\r\n          className={styles.headerDetectionArea}\r\n          aria-hidden=\"true\"\r\n        />\r\n      )}\r\n      <header \r\n        ref={headerRef}\r\n        className={`${styles.customHeader} ${darkMode ? styles.darkMode : ''} ${isVisible ? styles.visible : styles.hidden}`}\r\n      >\r\n        <div className={styles.dragArea}>\r\n          <div className={styles.leftSection}>\r\n            <div className={styles.iconOnly}>\r\n              <Image \r\n                src=\"/loop-icon.svg\" \r\n                alt=\"Loop 아이콘\"\r\n                width={24}\r\n                height={24}\r\n                priority \r\n                loading=\"eager\"\r\n              />\r\n            </div>\r\n            <h4 className={styles.appTitle}>loop</h4>\r\n          </div>\r\n        </div>\r\n        \r\n        <div className={styles.rightSection}>\r\n          <WindowControls api={window.electronAPI} />\r\n        </div>\r\n      </header>\r\n    </>\r\n  );\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\DebugPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\Editor.tsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'stats' is defined but never used.","line":21,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'HTMLDivElement' is not defined.","line":28,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":28,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":33,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":33,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":34,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":59,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":59,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":65,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":65,"endColumn":46},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":66,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":70,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":71,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":71,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'HTMLDivElement' is not defined.","line":76,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":76,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'CompositionEvent' is not defined.","line":90,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":90,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'InputEvent' is not defined.","line":111,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":111,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":137,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":137,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":147,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":147,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'Event' is not defined.","line":156,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":156,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'HTMLDivElement' is not defined.","line":157,"column":51,"nodeType":"Identifier","messageId":"undef","endLine":157,"endColumn":65},{"ruleId":"no-undef","severity":2,"message":"'Event' is not defined.","line":158,"column":39,"nodeType":"Identifier","messageId":"undef","endLine":158,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'CompositionEvent' is not defined.","line":159,"column":44,"nodeType":"Identifier","messageId":"undef","endLine":159,"endColumn":60},{"ruleId":"no-undef","severity":2,"message":"'Event' is not defined.","line":160,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":160,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'InputEvent' is not defined.","line":160,"column":68,"nodeType":"Identifier","messageId":"undef","endLine":160,"endColumn":78},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":171,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":171,"endColumn":48},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":172,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":172,"endColumn":45}],"suppressedMessages":[],"errorCount":22,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, {\r\n  useRef,\r\n  useState,\r\n  useCallback,\r\n  useEffect,\r\n  KeyboardEvent,\r\n} from 'react';\r\n\r\ninterface Stats {\r\n  pages: number;\r\n  words: number;\r\n  charCount: number;\r\n  charCountNoSpace: number;\r\n  keyCount: number;\r\n  typingTime: number;\r\n}\r\n\r\ninterface EditorProps {\r\n  onStatsUpdate: (stats: Stats) => void;\r\n  onSaveLog: () => void;\r\n}\r\n\r\nconst IDLE_TIMEOUT = 3000; // 3초\r\n\r\nconst Editor: React.FC<EditorProps> = ({ onStatsUpdate, onSaveLog }) => {\r\n  const editorRef = useRef<HTMLDivElement>(null);\r\n\r\n  const [typingTime, setTypingTime] = useState<number>(0);\r\n  const [keyCount, setKeyCount] = useState<number>(0);\r\n\r\n  const idleTimerRef = useRef<NodeJS.Timeout | null>(null);\r\n  const typingTimerRef = useRef<NodeJS.Timeout | null>(null);\r\n  const compositionHandledRef = useRef<boolean>(false);\r\n\r\n  const updateStats = useCallback(() => {\r\n    const content = editorRef.current?.textContent ?? '';\r\n    const pages = Math.max(1, Math.ceil(content.length / 600));\r\n    const words =\r\n      content.trim().length > 0\r\n        ? content.trim().split(/\\s+/).filter((w) => w.length > 0).length\r\n        : 0;\r\n    const charCount = content.length;\r\n    const charCountNoSpace = content.replace(/\\s/g, '').length;\r\n\r\n    onStatsUpdate({\r\n      pages,\r\n      words,\r\n      charCount,\r\n      charCountNoSpace,\r\n      keyCount,\r\n      typingTime,\r\n    });\r\n  }, [keyCount, typingTime, onStatsUpdate]);\r\n\r\n  const stopTyping = useCallback(() => {\r\n    if (typingTimerRef.current) {\r\n      clearInterval(typingTimerRef.current);\r\n      typingTimerRef.current = null;\r\n    }\r\n  }, []);\r\n\r\n  const startTyping = useCallback(() => {\r\n    if (typingTimerRef.current) clearInterval(typingTimerRef.current);\r\n    typingTimerRef.current = setInterval(() => {\r\n      setTypingTime((prev) => prev + 1);\r\n    }, 1000);\r\n\r\n    if (idleTimerRef.current) clearTimeout(idleTimerRef.current);\r\n    idleTimerRef.current = setTimeout(stopTyping, IDLE_TIMEOUT);\r\n  }, [stopTyping]);\r\n\r\n  // 일반 키보드 입력\r\n  const handleKeyDown = useCallback(\r\n    (e: KeyboardEvent<HTMLDivElement>) => {\r\n      // e.key가 한 글자이거나 스페이스/엔터일 때만 카운트\r\n      if (e.key.length === 1 || e.key === ' ' || e.key === 'Enter') {\r\n        const isKorean = /[가-힣]/.test(e.key);\r\n        setKeyCount((prev) => prev + (isKorean ? 2 : 1));\r\n        startTyping();\r\n        updateStats();\r\n      }\r\n    },\r\n    [startTyping, updateStats]\r\n  );\r\n\r\n  // 한글 입력 완료\r\n  const handleCompositionEnd = useCallback(\r\n    (e: CompositionEvent) => {\r\n      compositionHandledRef.current = true;\r\n      let typeCount = 0;\r\n      for (const char of e.data) {\r\n        if (/[가-힣]/.test(char)) {\r\n          typeCount += 2;\r\n        } else if (/[ㄱ-ㅎ|ㅏ-ㅣ]/.test(char)) {\r\n          typeCount += 1;\r\n        } else {\r\n          typeCount += 1;\r\n        }\r\n      }\r\n      setKeyCount((prev) => prev + typeCount);\r\n      startTyping();\r\n      updateStats();\r\n    },\r\n    [startTyping, updateStats]\r\n  );\r\n\r\n  // input 이벤트 (compositionEnd 후에도 발생)\r\n  const handleInput = useCallback(\r\n    (e: InputEvent) => {\r\n      if (compositionHandledRef.current) {\r\n        compositionHandledRef.current = false;\r\n        return;\r\n      }\r\n      if (e.data) {\r\n        const inputLen = e.data.length;\r\n        setKeyCount((prev) => prev + inputLen);\r\n        startTyping();\r\n        updateStats();\r\n      }\r\n    },\r\n    [startTyping, updateStats]\r\n  );\r\n\r\n  // 저장\r\n  const handleSave = async () => {\r\n    const content = editorRef.current?.textContent ?? '';\r\n    const logData = {\r\n      content,\r\n      keyCount,\r\n      typingTime,\r\n      timestamp: new Date().toISOString(),\r\n    };\r\n\r\n    try {\r\n      const res = await fetch('/api/saveLogs', {  // 수정된 경로: saveLog -> saveLogs\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify(logData),\r\n      });\r\n      const data = await res.json();\r\n      if (data.success) {\r\n        onSaveLog();\r\n      }\r\n    } catch (error: unknown) {\r\n      console.error('저장 오류:', error);\r\n    }\r\n  };\r\n\r\n  // 이벤트 등록\r\n  useEffect(() => {\r\n    const editorEl = editorRef.current;\r\n    if (!editorEl) return;\r\n\r\n    const keyDownHandler = (e: Event) =>\r\n      handleKeyDown(e as unknown as KeyboardEvent<HTMLDivElement>);\r\n    const compositionEndHandler = (e: Event) =>\r\n      handleCompositionEnd(e as unknown as CompositionEvent);\r\n    const inputHandler = (e: Event) => handleInput(e as unknown as InputEvent);\r\n\r\n    editorEl.addEventListener('keydown', keyDownHandler);\r\n    editorEl.addEventListener('compositionend', compositionEndHandler);\r\n    editorEl.addEventListener('input', inputHandler);\r\n\r\n    return () => {\r\n      editorEl.removeEventListener('keydown', keyDownHandler);\r\n      editorEl.removeEventListener('compositionend', compositionEndHandler);\r\n      editorEl.removeEventListener('input', inputHandler);\r\n\r\n      if (typingTimerRef.current) clearInterval(typingTimerRef.current);\r\n      if (idleTimerRef.current) clearTimeout(idleTimerRef.current);\r\n    };\r\n  }, [handleKeyDown, handleCompositionEnd, handleInput]);\r\n\r\n  return (\r\n    <div>\r\n      <div\r\n        ref={editorRef}\r\n        contentEditable\r\n        style={{\r\n          border: '1px solid #ccc',\r\n          minHeight: '200px',\r\n          padding: '10px',\r\n        }}\r\n      />\r\n      <button type=\"button\" onClick={handleSave}>\r\n        저장\r\n      </button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Editor;\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\GPUSettingsPanel.tsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'settings' is defined but never used.","line":17,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":82,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":82,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":136,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":136,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":158,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":158,"endColumn":14}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\r\nimport styles from './GPUSettingsPanel.module.css';\r\nimport { useToast } from './ToastContext';\r\nimport { \r\n  getGPURecommendations, \r\n  applyGPUSettings, \r\n  GPUSettings \r\n} from '../utils/gpu-settings-manager';\r\nimport { isGPUAccelerationEnabled, getGPUInfo } from '../utils/memory/gpu-accelerator';\r\n\r\ninterface GPUSettingsPanelProps {\r\n  isDarkMode?: boolean;\r\n  initialSettings?: {\r\n    useHardwareAcceleration: boolean;\r\n    processingMode: string;\r\n  };\r\n  onSettingsChange?: (settings: any) => void;\r\n  onRestartNeeded?: () => void;\r\n}\r\n\r\nexport function GPUSettingsPanel({\r\n  isDarkMode = false,\r\n  initialSettings,\r\n  onSettingsChange,\r\n  onRestartNeeded\r\n}: GPUSettingsPanelProps) {\r\n  const [gpuInfo, setGpuInfo] = useState<{ renderer: string; vendor: string; isAccelerated: boolean }>({\r\n    renderer: '정보 로드 중...',\r\n    vendor: '정보 로드 중...',\r\n    isAccelerated: false\r\n  });\r\n  \r\n  const [settings, setSettings] = useState<GPUSettings>({\r\n    useHardwareAcceleration: initialSettings?.useHardwareAcceleration ?? false,\r\n    processingMode: initialSettings?.processingMode ?? 'auto',\r\n    optimizeForBattery: true,\r\n    memoryOptimization: 'medium',\r\n    threadCount: 4\r\n  });\r\n  \r\n  const [gpuType, setGpuType] = useState<string>('알 수 없음');\r\n  const [recommendation, setRecommendation] = useState<string>('GPU 정보를 가져오는 중...');\r\n  const [isLoading, setIsLoading] = useState<boolean>(true);\r\n  const [hasChanges, setHasChanges] = useState<boolean>(false);\r\n  const [needsRestart, setNeedsRestart] = useState<boolean>(false);\r\n  \r\n  const { showToast } = useToast();\r\n  \r\n  // 컴포넌트 마운트 시 GPU 정보 로드\r\n  useEffect(() => {\r\n    async function loadGPUInfo() {\r\n      try {\r\n        setIsLoading(true);\r\n        \r\n        // GPU 가속화 상태 확인\r\n        const isAccelerated = await isGPUAccelerationEnabled();\r\n        \r\n        // GPU 정보 가져오기\r\n        const info = getGPUInfo();\r\n        setGpuInfo({\r\n          ...info,\r\n          isAccelerated\r\n        });\r\n        \r\n        // GPU 권장 설정 가져오기\r\n        const recommendations = await getGPURecommendations();\r\n        setGpuType(recommendations.gpuType);\r\n        setRecommendation(recommendations.recommendation);\r\n        \r\n        // 초기 설정이 없는 경우 권장 설정 사용\r\n        if (!initialSettings) {\r\n          setSettings(recommendations.recommendedSettings);\r\n        } else {\r\n          // 초기 설정이 있는 경우 사용자 지정 설정과 권장 설정을 병합\r\n          setSettings({\r\n            ...recommendations.recommendedSettings,\r\n            useHardwareAcceleration: initialSettings.useHardwareAcceleration,\r\n            processingMode: initialSettings.processingMode\r\n          });\r\n        }\r\n      } catch (error) {\r\n        console.error('GPU 정보 로드 오류:', error);\r\n        showToast('GPU 정보를 가져오는 중 오류가 발생했습니다', 'error');\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    }\r\n    \r\n    loadGPUInfo();\r\n  }, [initialSettings, showToast]);\r\n  \r\n  // 설정 변경 처리 함수\r\n  const handleSettingChange = (key: keyof GPUSettings, value: any) => {\r\n    // 하드웨어 가속 변경 시 재시작 필요\r\n    if (key === 'useHardwareAcceleration' && value !== settings.useHardwareAcceleration) {\r\n      setNeedsRestart(true);\r\n    }\r\n    \r\n    // 새 설정 적용\r\n    setSettings(prev => ({\r\n      ...prev,\r\n      [key]: value\r\n    }));\r\n    \r\n    // 변경 사항 기록\r\n    setHasChanges(true);\r\n  };\r\n  \r\n  // 설정 저장 처리 함수\r\n  const handleSaveSettings = async () => {\r\n    try {\r\n      const success = await applyGPUSettings(settings);\r\n      \r\n      if (success) {\r\n        showToast('GPU 설정이 저장되었습니다', 'success');\r\n        \r\n        // 부모 컴포넌트에 설정 변경 알림\r\n        if (onSettingsChange) {\r\n          onSettingsChange({\r\n            useHardwareAcceleration: settings.useHardwareAcceleration,\r\n            processingMode: settings.processingMode\r\n          });\r\n        }\r\n        \r\n        // 재시작 필요 여부 확인\r\n        if (needsRestart && onRestartNeeded) {\r\n          onRestartNeeded();\r\n        }\r\n        \r\n        // 변경 사항 초기화\r\n        setHasChanges(false);\r\n      } else {\r\n        showToast('GPU 설정 저장에 실패했습니다', 'error');\r\n      }\r\n    } catch (error) {\r\n      console.error('설정 저장 오류:', error);\r\n      showToast('설정을 저장하는 중 오류가 발생했습니다', 'error');\r\n    }\r\n  };\r\n  \r\n  // 최적 설정 적용 함수\r\n  const applyOptimalSettings = async () => {\r\n    try {\r\n      const recommendations = await getGPURecommendations();\r\n      const newSettings = recommendations.recommendedSettings;\r\n      \r\n      // 하드웨어 가속 변경 여부 확인\r\n      if (newSettings.useHardwareAcceleration !== settings.useHardwareAcceleration) {\r\n        setNeedsRestart(true);\r\n      }\r\n      \r\n      // 새 설정 적용\r\n      setSettings(newSettings);\r\n      setHasChanges(true);\r\n      \r\n      showToast('최적 GPU 설정이 적용되었습니다. 저장하려면 저장 버튼을 클릭하세요.', 'info');\r\n    } catch (error) {\r\n      console.error('최적 설정 적용 오류:', error);\r\n      showToast('최적 설정을 적용하는 중 오류가 발생했습니다', 'error');\r\n    }\r\n  };\r\n  \r\n  return (\r\n    <div className={`${styles.container} ${isDarkMode ? styles.darkMode : ''}`}>\r\n      <h2 className={styles.title}>GPU 설정</h2>\r\n      \r\n      {isLoading ? (\r\n        <div className={styles.loading}>\r\n          <p>GPU 정보 불러오는 중...</p>\r\n        </div>\r\n      ) : (\r\n        <>\r\n          <div className={styles.infoSection}>\r\n            <h3>감지된 GPU 정보</h3>\r\n            <div className={styles.gpuInfo}>\r\n              <div className={styles.infoItem}>\r\n                <span className={styles.label}>GPU 유형:</span>\r\n                <span className={styles.value}>{gpuType}</span>\r\n              </div>\r\n              <div className={styles.infoItem}>\r\n                <span className={styles.label}>GPU 렌더러:</span>\r\n                <span className={styles.value}>{gpuInfo.renderer}</span>\r\n              </div>\r\n              <div className={styles.infoItem}>\r\n                <span className={styles.label}>GPU 벤더:</span>\r\n                <span className={styles.value}>{gpuInfo.vendor}</span>\r\n              </div>\r\n              <div className={styles.infoItem}>\r\n                <span className={styles.label}>하드웨어 가속:</span>\r\n                <span className={styles.value}>\r\n                  {gpuInfo.isAccelerated ? '사용 가능' : '사용 불가능'}\r\n                </span>\r\n              </div>\r\n            </div>\r\n            \r\n            <div className={styles.recommendation}>\r\n              <h4>권장 설정</h4>\r\n              <p>{recommendation}</p>\r\n              <button \r\n                className={styles.recommendButton}\r\n                onClick={applyOptimalSettings}\r\n              >\r\n                최적 설정 적용\r\n              </button>\r\n            </div>\r\n          </div>\r\n          \r\n          <div className={styles.settingsSection}>\r\n            <h3>GPU 설정</h3>\r\n            \r\n            <div className={styles.settingItem}>\r\n              <label>\r\n                <input\r\n                  type=\"checkbox\"\r\n                  checked={settings.useHardwareAcceleration}\r\n                  onChange={(e) => handleSettingChange('useHardwareAcceleration', e.target.checked)}\r\n                />\r\n                <span>하드웨어 가속 사용 (재시작 필요)</span>\r\n              </label>\r\n              {needsRestart && (\r\n                <div className={styles.restartNotice}>\r\n                  이 설정을 적용하려면 앱을 재시작해야 합니다.\r\n                </div>\r\n              )}\r\n            </div>\r\n            \r\n            <div className={styles.settingItem}>\r\n              <label>처리 모드:</label>\r\n              <select\r\n                value={settings.processingMode}\r\n                onChange={(e) => handleSettingChange('processingMode', e.target.value)}\r\n                disabled={!settings.useHardwareAcceleration}\r\n              >\r\n                <option value=\"auto\">자동 (시스템에 맞게 조정)</option>\r\n                <option value=\"normal\">일반 모드</option>\r\n                <option value=\"cpu-intensive\">CPU 중점 모드 (저사양 GPU)</option>\r\n                <option value=\"gpu-intensive\">GPU 중점 모드 (고사양 GPU)</option>\r\n              </select>\r\n              {!settings.useHardwareAcceleration && (\r\n                <div className={styles.disabledNote}>\r\n                  하드웨어 가속을 활성화하면 처리 모드를 선택할 수 있습니다.\r\n                </div>\r\n              )}\r\n            </div>\r\n            \r\n            <div className={styles.settingItem}>\r\n              <label>\r\n                <input\r\n                  type=\"checkbox\"\r\n                  checked={settings.optimizeForBattery}\r\n                  onChange={(e) => handleSettingChange('optimizeForBattery', e.target.checked)}\r\n                  disabled={!settings.useHardwareAcceleration}\r\n                />\r\n                <span>배터리 사용 시 전력 소모 최적화</span>\r\n              </label>\r\n            </div>\r\n            \r\n            <div className={styles.settingItem}>\r\n              <label>메모리 최적화:</label>\r\n              <select\r\n                value={settings.memoryOptimization}\r\n                onChange={(e) => handleSettingChange('memoryOptimization', e.target.value)}\r\n              >\r\n                <option value=\"low\">낮음 (높은 성능, 많은 메모리 사용)</option>\r\n                <option value=\"medium\">중간 (균형 있는 설정)</option>\r\n                <option value=\"high\">높음 (낮은 메모리 사용, 낮은 성능)</option>\r\n              </select>\r\n            </div>\r\n            \r\n            <div className={styles.settingItem}>\r\n              <label>스레드 수:</label>\r\n              <select\r\n                value={settings.threadCount}\r\n                onChange={(e) => handleSettingChange('threadCount', parseInt(e.target.value))}\r\n              >\r\n                <option value=\"2\">2 (저사양 CPU)</option>\r\n                <option value=\"4\">4 (균형)</option>\r\n                <option value=\"8\">8 (고사양 CPU)</option>\r\n                <option value=\"16\">16 (최고사양 CPU)</option>\r\n              </select>\r\n            </div>\r\n          </div>\r\n          \r\n          <div className={styles.buttonSection}>\r\n            <button\r\n              className={`${styles.saveButton} ${!hasChanges ? styles.disabled : ''}`}\r\n              onClick={handleSaveSettings}\r\n              disabled={!hasChanges}\r\n            >\r\n              설정 저장\r\n            </button>\r\n            {needsRestart && (\r\n              <button\r\n                className={styles.restartButton}\r\n                onClick={onRestartNeeded}\r\n              >\r\n                앱 재시작\r\n              </button>\r\n            )}\r\n          </div>\r\n          \r\n          <div className={styles.noteSection}>\r\n            <p className={styles.note}>\r\n              <strong>참고:</strong> GPU 하드웨어 가속을 사용하면 그래픽 렌더링 및 일부 계산 작업의 성능이 향상될 수 있지만, \r\n              메모리 사용량이 증가하고 일부 시스템에서는 호환성 문제가 발생할 수 있습니다.\r\n            </p>\r\n            <p className={styles.note}>\r\n              <strong>처리 모드:</strong> 자동 모드는 시스템 성능에 따라 최적의 설정을 선택합니다. \r\n              CPU 중점 모드는 저사양 GPU에 적합하며, GPU 중점 모드는 고성능 GPU에서 최상의 성능을 제공합니다.\r\n            </p>\r\n          </div>\r\n        </>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\HomeContent.tsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'useMemo' is defined but never used.","line":3,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useMemo' is defined but never used.","line":3,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":24},{"ruleId":"no-unused-vars","severity":2,"message":"'TypingStats' is defined but never used.","line":4,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TypingStats' is defined but never used.","line":4,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'TypingHistory' is defined but never used.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TypingHistory' is defined but never used.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":23},{"ruleId":"no-unused-vars","severity":2,"message":"'loadSettings' is assigned a value but never used.","line":61,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":61,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'loadSettings' is assigned a value but never used.","line":61,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":61,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":94,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":94,"endColumn":14},{"ruleId":"no-unused-vars","severity":2,"message":"'isLoading' is assigned a value but never used.","line":118,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":118,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isLoading' is assigned a value but never used.","line":118,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":118,"endColumn":14},{"ruleId":"no-unused-vars","severity":2,"message":"'fetchLogs' is assigned a value but never used.","line":125,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":125,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fetchLogs' is assigned a value but never used.","line":125,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":125,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":143,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":143,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":144,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":144,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":145,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":145,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":155,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":155,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":156,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":156,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":160,"column":39,"nodeType":"Identifier","messageId":"undef","endLine":160,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":161,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":161,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":162,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":162,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":163,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":163,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":195,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":195,"endColumn":19}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useMemo, useState, useCallback, useEffect } from 'react';\r\nimport TypingStats from './TypingStats'; // default import로 변경\r\nimport { TypingMonitor } from './TypingMonitor';\r\nimport { TypingHistory } from './TypingHistory';\r\nimport { TypingChart } from './TypingChart';\r\nimport { TabNavigation } from './TabNavigation';\r\nimport { MainLayout } from './MainLayout';\r\nimport { DebugPanel } from './DebugPanel';\r\nimport { Settings } from './Settings'; \r\nimport RestartLoading from './RestartLoading';\r\n// useToast를 사용하지 않는다면 임포트 제거\r\n// import { useToast } from './ToastContext';\r\nimport { useElectronApi } from '../hooks/useElectronApi';\r\nimport { useSettings } from '../hooks/useSettings';\r\nimport { useTypingStats } from '../hooks/useTypingStats';\r\nimport { useTabNavigation } from '../hooks/useTabNavigation';\r\nimport { useMemoryManagement } from '../hooks/useMemoryManagement';\r\nimport { useAutoHideHeader } from '../hooks/useAutoHideHeader';\r\n\r\n// LogEntry 타입 정의 추가\r\ninterface LogEntry {\r\n  id: number;\r\n  content: string;\r\n  key_count: number;\r\n  typing_time: number;\r\n  timestamp: string;\r\n  created_at: string;\r\n  is_saved?: boolean;\r\n  window_title?: string;\r\n  browser_name?: string;\r\n  total_chars?: number;\r\n  total_chars_no_space?: number;\r\n  total_words?: number;\r\n  pages?: number;\r\n  accuracy?: number;\r\n}\r\n\r\n// RestartLoadingData 인터페이스 추가\r\ninterface RestartLoadingData {\r\n  message?: string;\r\n  timeout?: number;\r\n}\r\n\r\nexport const HomeContent = React.memo(function HomeContent() {\r\n  // Electron API 초기화\r\n  const { electronAPI, api } = useElectronApi();\r\n  \r\n  // 설정 상태 관리\r\n  const { \r\n    settings, \r\n    darkMode, \r\n    windowMode,\r\n    handleSaveSettings, \r\n    handleDarkModeChange, \r\n    handleWindowModeChange \r\n  } = useSettings(electronAPI);\r\n  \r\n  // 설정 로드 함수 내에서 기본값 설정\r\n  const loadSettings = async () => {\r\n    try {\r\n      if (electronAPI && electronAPI.loadSettings) {\r\n        const settings = await electronAPI.loadSettings();\r\n        \r\n        // GPU 가속 관련 속성이 없는 경우 기본값 설정\r\n        const completeSettings = {\r\n          enabledCategories: settings.enabledCategories || {\r\n            docs: true,\r\n            office: true,\r\n            coding: true,\r\n            sns: true\r\n          },\r\n          autoStartMonitoring: settings.autoStartMonitoring ?? true,\r\n          resumeAfterIdle: settings.resumeAfterIdle ?? true,\r\n          darkMode: settings.darkMode ?? false,\r\n          windowMode: settings.windowMode ?? 'windowed',\r\n          minimizeToTray: settings.minimizeToTray ?? true,\r\n          showTrayNotifications: settings.showTrayNotifications ?? true,\r\n          reduceMemoryInBackground: settings.reduceMemoryInBackground ?? true,\r\n          enableMiniView: settings.enableMiniView ?? true,\r\n          // 기존 값 유지\r\n          useHardwareAcceleration: settings.useHardwareAcceleration ?? false,\r\n          processingMode: settings.processingMode ?? 'auto',\r\n          maxMemoryThreshold: settings.maxMemoryThreshold ?? 100\r\n        };\r\n        \r\n        // setSettings 대신 handleSaveSettings 사용\r\n        handleSaveSettings(completeSettings);\r\n        // setDarkMode 대신 handleDarkModeChange 사용\r\n        handleDarkModeChange(settings.darkMode);\r\n      }\r\n    } catch (error) {\r\n      console.error('설정 로드 중 오류:', error);\r\n    }\r\n  };\r\n\r\n  // 탭 관리\r\n  const { \r\n    activeTab, \r\n    debugMode, \r\n    handleTabChange, \r\n    toggleDebugMode \r\n  } = useTabNavigation({ \r\n    initialTab: 'monitor',\r\n    electronAPI: api // api는 이제 TabNavigationAPI와 호환됩니다\r\n  });\r\n  \r\n  // 자동 숨김 헤더 관리\r\n  const { isHeaderVisible } = useAutoHideHeader({\r\n    windowMode, \r\n    electronAPI\r\n  });\r\n  \r\n  // 타이핑 통계 관리 - 'typingLogs'로 이름 변경하여 중복 방지\r\n  const { \r\n    logs: typingLogs, // 이름 변경\r\n    isLoading, \r\n    isTracking,\r\n    displayStats,\r\n    handleStartTracking,\r\n    handleStopTracking,\r\n    handleSaveStats,\r\n    currentStatsRef,\r\n    fetchLogs\r\n  } = useTypingStats(electronAPI);\r\n  \r\n  // 현재 표시할 로그 관리\r\n  const [currentLogs, setCurrentLogs] = useState<LogEntry[]>([]);\r\n  \r\n  // 메모리 관리 훅 사용 개선\r\n  const memoryManager = useMemoryManagement({\r\n    debugMode,\r\n    activeTab,\r\n    memoryThreshold: 100, // 100MB 기준\r\n    checkInterval: 30000, // 30초마다 체크\r\n    onClearLogs: () => {\r\n      // 현재 활성 탭이 로그를 사용하지 않는 경우에만 해제\r\n      if (activeTab !== 'history' && activeTab !== 'stats' && activeTab !== 'chart') {\r\n        setCurrentLogs([]);\r\n        \r\n        // 대용량 데이터 참조 해제를 통한 추가 최적화\r\n        if (window.__memoryOptimizer?.optimizeImageResources) {\r\n          window.__memoryOptimizer.optimizeImageResources().catch((err: Error) => {\r\n            console.error('이미지 리소스 최적화 중 오류:', err);\r\n          });\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  // 컴포넌트 첫 로드 시 메모리 최적화 실행\r\n  useEffect(() => {\r\n    // 초기 메모리 최적화\r\n    if (window.__memoryOptimizer?.optimizeMemory) {\r\n      window.__memoryOptimizer.optimizeMemory(false);\r\n    }\r\n    \r\n    // 주기적으로 이미지 리소스 최적화 (페이지가 오래 열려있을 때)\r\n    const imageOptimizationInterval = setInterval(() => {\r\n      if (window.__memoryOptimizer?.optimizeImageResources) {\r\n        window.__memoryOptimizer.optimizeImageResources().catch((err: Error) => {\r\n          console.error('이미지 리소스 최적화 주기 작업 중 오류:', err);\r\n        });\r\n      }\r\n    }, 300000); // 5분마다\r\n    \r\n    // 인터벌 등록 및 언마운트 시 정리\r\n    memoryManager.addInterval(imageOptimizationInterval);\r\n    \r\n    return () => {\r\n      memoryManager.clearIntervals();\r\n    };\r\n  }, [memoryManager]);\r\n\r\n  // 로그 데이터 업데이트 - 타이핑 로그가 변경될 때마다 실행\r\n  React.useEffect(() => {\r\n    if (typingLogs && typingLogs.length > 0) {\r\n      setCurrentLogs(typingLogs);\r\n    }\r\n  }, [typingLogs]);\r\n\r\n  const [isRestarting, setIsRestarting] = useState(false);\r\n\r\n  // 재시작 로딩 리스너 추가\r\n  useEffect(() => {\r\n    // 전자캅에 접근할 수 있는지 확인\r\n    if (!electronAPI) return;\r\n    \r\n    const unsubscribe = electronAPI.onShowRestartLoading?.((data: RestartLoadingData) => {\r\n      setIsRestarting(true);\r\n      \r\n      // 타임아웃이 있으면 자동으로 숨김\r\n      if (data.timeout) {\r\n        setTimeout(() => {\r\n          setIsRestarting(false);\r\n        }, data.timeout);\r\n      }\r\n    }) || (() => {});\r\n    \r\n    return () => {\r\n      unsubscribe();\r\n    };\r\n  }, [electronAPI]);\r\n\r\n  // 컴포넌트 렌더링 로직\r\n  const renderContent = useCallback(() => {\r\n    switch (activeTab) {\r\n      case 'monitor':\r\n        return (\r\n          <TypingMonitor\r\n            stats={displayStats}\r\n            isTracking={isTracking}\r\n            onStartTracking={handleStartTracking}\r\n            onStopTracking={handleStopTracking}\r\n            onSaveStats={handleSaveStats}\r\n          />\r\n        );\r\n      case 'stats':\r\n        return (\r\n          <React.Suspense fallback={<div>Loading chart...</div>}>\r\n            <TypingChart \r\n              logs={typingLogs}\r\n            />\r\n          </React.Suspense>\r\n        );\r\n      case 'settings':\r\n        return (\r\n          <div className=\"settings-tab-wrapper\" style={{\r\n            maxWidth: '800px',\r\n            margin: '0 auto',\r\n            width: '100%'\r\n          }}>\r\n            <Settings\r\n              onSave={handleSaveSettings}\r\n              initialSettings={settings}\r\n              darkMode={darkMode}\r\n              onDarkModeChange={handleDarkModeChange}\r\n              onWindowModeChange={handleWindowModeChange}\r\n            />\r\n          </div>\r\n        );\r\n      default:\r\n        return null;\r\n    }\r\n  }, [\r\n    activeTab, \r\n    displayStats, \r\n    isTracking, \r\n    handleStartTracking, \r\n    handleStopTracking, \r\n    handleSaveStats,\r\n    typingLogs,\r\n    settings, \r\n    darkMode, \r\n    handleDarkModeChange, \r\n    handleWindowModeChange,\r\n    handleSaveSettings\r\n  ]);\r\n\r\n  return (\r\n    <MainLayout \r\n      darkMode={darkMode}\r\n      windowMode={windowMode} \r\n      electronAPI={electronAPI}\r\n      isHeaderVisible={isHeaderVisible}\r\n    >\r\n      {/* 재시작 로딩 오버레이 */}\r\n      <RestartLoading \r\n        isVisible={isRestarting}\r\n        message=\"앱을 재시작하는 중입니다\"\r\n      />\r\n      \r\n      {/* 나머지 내용 */}\r\n      <TabNavigation\r\n        activeTab={activeTab}\r\n        onTabChange={handleTabChange}\r\n        onDebugToggle={toggleDebugMode}\r\n        debugMode={debugMode}\r\n      />\r\n      \r\n      {/* 메모이제이션된 컴포넌트 사용 */}\r\n      {renderContent()}\r\n      \r\n      {/* 디버그 패널 */}\r\n      <DebugPanel\r\n        isVisible={debugMode}\r\n        stats={currentStatsRef.current}\r\n        logsCount={currentLogs.length}\r\n        isTracking={isTracking}\r\n        windowMode={windowMode}\r\n      />\r\n    </MainLayout>\r\n  );\r\n});\r\n\r\n// 전역 window 타입 확장 - 참고용 주석으로 남겨둠\r\n// Window.__memoryOptimizer는 이미 다른 파일(types-declarations.d.ts)에 정의되어 있음\r\n\r\nexport default HomeContent;\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\LogAnalysisPanel.tsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'getCurrentTimestamp' is defined but never used.","line":5,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getCurrentTimestamp' is defined but never used.","line":5,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":42},{"ruleId":"no-unused-vars","severity":2,"message":"'learningStatus' is assigned a value but never used.","line":25,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":25,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'learningStatus' is assigned a value but never used.","line":25,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":40,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":55,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":55,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":58,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":58,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":80,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":80,"endColumn":35}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useState, useEffect, useCallback } from 'react';\r\nimport { LearningModelType, LearningResult } from '../utils/log-learning';\r\nimport { formatBytes, getCurrentTimestamp } from '../utils/common-utils';\r\nimport styles from './LogAnalysisPanel.module.css';\r\n\r\ninterface LogAnalysisPanelProps {\r\n  className?: string;\r\n}\r\n\r\n/**\r\n * 로그 분석 패널 컴포넌트\r\n * 로그 데이터를 학습하고 분석 결과를 표시합니다.\r\n */\r\nexport default function LogAnalysisPanel({ className = '' }: LogAnalysisPanelProps) {\r\n  const [isLoading, setIsLoading] = useState<boolean>(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const [results, setResults] = useState<LearningResult[]>([]);\r\n  const [selectedTab, setSelectedTab] = useState<LearningModelType>(LearningModelType.MEMORY_OPTIMIZATION);\r\n  const [lastAnalysisTime, setLastAnalysisTime] = useState<number | null>(null);\r\n  const [combinedRecommendations, setCombinedRecommendations] = useState<string[]>([]);\r\n\r\n  // 학습 상태\r\n  const [learningStatus, setLearningStatus] = useState<{\r\n    isLearning: boolean;\r\n    lastLearningTime: number | null;\r\n    availableModels: LearningModelType[];\r\n  }>({\r\n    isLearning: false,\r\n    lastLearningTime: null,\r\n    availableModels: Object.values(LearningModelType)\r\n  });\r\n\r\n  /**\r\n   * 학습 상태 확인\r\n   */\r\n  const checkLearningStatus = useCallback(async () => {\r\n    try {\r\n      const response = await fetch('/api/logs/learn');\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`API 요청 실패: ${response.status} ${response.statusText}`);\r\n      }\r\n\r\n      const data = await response.json();\r\n\r\n      if (data.success) {\r\n        setLearningStatus(data.status || {\r\n          isLearning: false,\r\n          lastLearningTime: null,\r\n          availableModels: Object.values(LearningModelType)\r\n        });\r\n      } else {\r\n        console.error('학습 상태 확인 오류:', data.error);\r\n      }\r\n    } catch (error) {\r\n      console.error('학습 상태 확인 중 오류 발생:', error);\r\n    }\r\n  }, []);\r\n\r\n  // 컴포넌트 마운트 시 학습 상태 확인\r\n  useEffect(() => {\r\n    checkLearningStatus();\r\n  }, [checkLearningStatus]);\r\n\r\n  /**\r\n   * 학습 실행\r\n   */\r\n  const runLearning = useCallback(async (models: LearningModelType[] = []) => {\r\n    // 모델을 지정하지 않은 경우 기본값으로 모든 모델 사용\r\n    const modelsToLearn = models.length > 0\r\n      ? models\r\n      : Object.values(LearningModelType);\r\n\r\n    setIsLoading(true);\r\n    setError(null);\r\n\r\n    try {\r\n      const response = await fetch('/api/logs/learn', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json'\r\n        },\r\n        body: JSON.stringify({\r\n          modelTypes: modelsToLearn,\r\n          options: {\r\n            memory: {\r\n              timeRange: {\r\n                startTime: Date.now() - 7 * 24 * 60 * 60 * 1000, // 1주일\r\n                endTime: Date.now()\r\n              }\r\n            },\r\n            user: {\r\n              timeRange: {\r\n                startTime: Date.now() - 30 * 24 * 60 * 60 * 1000, // 1개월\r\n                endTime: Date.now()\r\n              }\r\n            },\r\n            error: {\r\n              timeRange: {\r\n                startTime: Date.now() - 30 * 24 * 60 * 60 * 1000, // 1개월\r\n                endTime: Date.now()\r\n              }\r\n            }\r\n          }\r\n        })\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`API 요청 실패: ${response.status} ${response.statusText}`);\r\n      }\r\n\r\n      const data = await response.json();\r\n\r\n      if (data.success) {\r\n        setResults(data.results || []);\r\n        setCombinedRecommendations(data.combinedRecommendations || []);\r\n        setLastAnalysisTime(data.timestamp || Date.now());\r\n\r\n        // 학습 상태 업데이트\r\n        await checkLearningStatus();\r\n      } else {\r\n        setError(data.error || '알 수 없는 오류가 발생했습니다.');\r\n      }\r\n    } catch (error) {\r\n      setError(error instanceof Error ? error.message : String(error));\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [checkLearningStatus]);\r\n\r\n  /**\r\n   * 특정 모델 유형에 대한 학습 결과 가져오기\r\n   */\r\n  const getResultForModel = (modelType: LearningModelType): LearningResult | undefined => {\r\n    return results.find(result => result.modelType === modelType);\r\n  };\r\n\r\n  /**\r\n   * 학습 결과에서 추천 사항 렌더링\r\n   */\r\n  const renderRecommendations = (recommendations: string[]) => {\r\n    return (\r\n      <ul className={styles.recommendationList}>\r\n        {recommendations.map((rec, index) => (\r\n          <li key={index} className={styles.recommendationItem}>{rec}</li>\r\n        ))}\r\n      </ul>\r\n    );\r\n  };\r\n\r\n  /**\r\n   * 통계 항목 렌더링\r\n   */\r\n  const renderMetricItem = (label: string, value: any) => {\r\n    let formattedValue = value;\r\n\r\n    // 숫자인 경우 소수점 처리\r\n    if (typeof value === 'number') {\r\n      // 메모리 관련 항목은 MB 또는 바이트로 표시\r\n      if (label.toLowerCase().includes('memory') ||\r\n        label.toLowerCase().includes('heap') ||\r\n        label.toLowerCase().includes('size')) {\r\n        formattedValue = formatBytes(value);\r\n      }\r\n      // 0과 1 사이의 값은 백분율로 표시\r\n      else if (value > 0 && value < 1) {\r\n        formattedValue = `${(value * 100).toFixed(2)}%`;\r\n      }\r\n      // 기타 숫자는 소수점 2자리까지 표시\r\n      else {\r\n        formattedValue = Number.isInteger(value) ? value : value.toFixed(2);\r\n      }\r\n    }\r\n\r\n    return (\r\n      <div key={label} className={styles.metricItem}>\r\n        <span className={styles.metricLabel}>{label}:</span>\r\n        <span className={styles.metricValue}>{formattedValue}</span>\r\n      </div>\r\n    );\r\n  };\r\n\r\n  /**\r\n   * 메모리 최적화 결과 렌더링\r\n   */\r\n  const renderMemoryOptimizationResults = () => {\r\n    const result = getResultForModel(LearningModelType.MEMORY_OPTIMIZATION);\r\n\r\n    if (!result) {\r\n      return (\r\n        <div className={styles.noResults}>\r\n          <p>메모리 최적화 학습 결과가 없습니다.</p>\r\n          <button\r\n            onClick={() => runLearning([LearningModelType.MEMORY_OPTIMIZATION])}\r\n            disabled={isLoading}\r\n            className={styles.learningButton}\r\n          >\r\n            메모리 패턴 학습하기\r\n          </button>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    const { insights, recommendations, metrics } = result;\r\n\r\n    return (\r\n      <div className={styles.resultSection}>\r\n        <h3>메모리 사용량 분석 결과</h3>\r\n\r\n        {/* 인사이트 표시 */}\r\n        <div className={styles.insightsSection}>\r\n          <h4>주요 인사이트</h4>\r\n\r\n          {insights.map((insight, index) => {\r\n            if (insight.type === 'peakHours' && insight.data.length > 0) {\r\n              return (\r\n                <div key={index} className={styles.insightItem}>\r\n                  <h5>메모리 사용량 피크 시간대</h5>\r\n                  <div className={styles.peakHoursChart}>\r\n                    {insight.data.map((hour, i) => (\r\n                      <div key={i} className={styles.peakHourBar}\r\n                        style={{\r\n                          height: `${Math.max(30, (hour.avgUsage / 100) * 100)}px`,\r\n                          backgroundColor: i === 0 ? '#ff6b6b' : '#5c7cfa'\r\n                        }}\r\n                      >\r\n                        <span className={styles.peakHourLabel}>{hour.hour}시</span>\r\n                        <span className={styles.peakHourValue}>{hour.avgUsage.toFixed(1)}%</span>\r\n                      </div>\r\n                    ))}\r\n                  </div>\r\n                </div>\r\n              );\r\n            }\r\n\r\n            if (insight.type === 'problematicSessions' && insight.data.length > 0) {\r\n              return (\r\n                <div key={index} className={styles.insightItem}>\r\n                  <h5>의심되는 메모리 누수 세션</h5>\r\n                  <ul className={styles.sessionsList}>\r\n                    {insight.data.map((session, i) => (\r\n                      <li key={i}>\r\n                        <span>세션 {session.sessionId.substring(0, 8)}</span>\r\n                        <span className={styles.sessionIncrease} style={{\r\n                          color: session.percentIncrease > 20 ? '#ff6b6b' : '#5c7cfa'\r\n                        }}>\r\n                          증가율: {session.percentIncrease.toFixed(2)}%\r\n                        </span>\r\n                      </li>\r\n                    ))}\r\n                  </ul>\r\n                </div>\r\n              );\r\n            }\r\n\r\n            return null;\r\n          })}\r\n        </div>\r\n\r\n        {/* 메트릭 표시 */}\r\n        <div className={styles.metricsSection}>\r\n          <h4>메모리 사용 통계</h4>\r\n          <div className={styles.metricsGrid}>\r\n            {Object.entries(metrics).map(([key, value]) =>\r\n              renderMetricItem(\r\n                key\r\n                  .replace(/([A-Z])/g, ' $1')\r\n                  .replace(/^./, str => str.toUpperCase()),\r\n                value\r\n              )\r\n            )}\r\n          </div>\r\n        </div>\r\n\r\n        {/* 추천 사항 표시 */}\r\n        <div className={styles.recommendationsSection}>\r\n          <h4>추천 사항</h4>\r\n          {renderRecommendations(recommendations)}\r\n        </div>\r\n      </div>\r\n    );\r\n  };\r\n\r\n  /**\r\n   * 사용자 행동 분석 결과 렌더링\r\n   */\r\n  const renderUserBehaviorResults = () => {\r\n    const result = getResultForModel(LearningModelType.USER_BEHAVIOR);\r\n\r\n    if (!result) {\r\n      return (\r\n        <div className={styles.noResults}>\r\n          <p>사용자 행동 분석 결과가 없습니다.</p>\r\n          <button\r\n            onClick={() => runLearning([LearningModelType.USER_BEHAVIOR])}\r\n            disabled={isLoading}\r\n            className={styles.learningButton}\r\n          >\r\n            사용자 패턴 학습하기\r\n          </button>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    const { insights, recommendations, metrics } = result;\r\n\r\n    return (\r\n      <div className={styles.resultSection}>\r\n        <h3>사용자 행동 분석 결과</h3>\r\n\r\n        {/* 인사이트 표시 */}\r\n        <div className={styles.insightsSection}>\r\n          <h4>주요 인사이트</h4>\r\n\r\n          {insights.map((insight, index) => {\r\n            if (insight.type === 'topWords' && insight.data.length > 0) {\r\n              return (\r\n                <div key={index} className={styles.insightItem}>\r\n                  <h5>자주 사용하는 단어</h5>\r\n                  <div className={styles.wordCloud}>\r\n                    {insight.data.slice(0, 10).map((word, i) => (\r\n                      <span\r\n                        key={i}\r\n                        className={styles.wordItem}\r\n                        style={{\r\n                          fontSize: `${Math.max(14, Math.min(24, 14 + (word.count / 5)))}px`,\r\n                          opacity: 0.7 + ((i / 10) * 0.3)\r\n                        }}\r\n                      >\r\n                        {word.word}\r\n                      </span>\r\n                    ))}\r\n                  </div>\r\n                </div>\r\n              );\r\n            }\r\n\r\n            if (insight.type === 'activeHours' && insight.data.length > 0) {\r\n              return (\r\n                <div key={index} className={styles.insightItem}>\r\n                  <h5>활발한 활동 시간대</h5>\r\n                  <div className={styles.activeHoursChart}>\r\n                    {insight.data.map((hour, i) => (\r\n                      <div key={i} className={styles.activeHourBar}\r\n                        style={{\r\n                          height: `${Math.max(30, (hour.count / 10) * 100)}px`,\r\n                          backgroundColor: i === 0 ? '#82c91e' : '#15aabf'\r\n                        }}\r\n                      >\r\n                        <span className={styles.activeHourLabel}>{hour.hour}시</span>\r\n                        <span className={styles.activeHourValue}>{hour.count}회</span>\r\n                      </div>\r\n                    ))}\r\n                  </div>\r\n                </div>\r\n              );\r\n            }\r\n\r\n            return null;\r\n          })}\r\n        </div>\r\n\r\n        {/* 메트릭 표시 */}\r\n        <div className={styles.metricsSection}>\r\n          <h4>사용 통계</h4>\r\n          <div className={styles.metricsGrid}>\r\n            {Object.entries(metrics).map(([key, value]) =>\r\n              renderMetricItem(\r\n                key\r\n                  .replace(/([A-Z])/g, ' $1')\r\n                  .replace(/^./, str => str.toUpperCase()),\r\n                value\r\n              )\r\n            )}\r\n          </div>\r\n        </div>\r\n\r\n        {/* 추천 사항 표시 */}\r\n        <div className={styles.recommendationsSection}>\r\n          <h4>추천 사항</h4>\r\n          {renderRecommendations(recommendations)}\r\n        </div>\r\n      </div>\r\n    );\r\n  };\r\n\r\n  /**\r\n   * 오류 분석 결과 렌더링\r\n   */\r\n  const renderErrorPredictionResults = () => {\r\n    const result = getResultForModel(LearningModelType.ERROR_PREDICTION);\r\n\r\n    if (!result) {\r\n      return (\r\n        <div className={styles.noResults}>\r\n          <p>오류 분석 결과가 없습니다.</p>\r\n          <button\r\n            onClick={() => runLearning([LearningModelType.ERROR_PREDICTION])}\r\n            disabled={isLoading}\r\n            className={styles.learningButton}\r\n          >\r\n            오류 패턴 학습하기\r\n          </button>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    const { insights, recommendations, metrics } = result;\r\n\r\n    return (\r\n      <div className={styles.resultSection}>\r\n        <h3>오류 패턴 분석 결과</h3>\r\n\r\n        {/* 인사이트 표시 */}\r\n        <div className={styles.insightsSection}>\r\n          <h4>주요 인사이트</h4>\r\n\r\n          {insights.map((insight, index) => {\r\n            if (insight.type === 'topErrors' && insight.data.length > 0) {\r\n              return (\r\n                <div key={index} className={styles.insightItem}>\r\n                  <h5>가장 빈번한 오류 유형</h5>\r\n                  <ul className={styles.errorsList}>\r\n                    {insight.data.map((error, i) => (\r\n                      <li key={i} className={styles.errorItem}>\r\n                        <span className={styles.errorType}>{error.type}</span>\r\n                        <span className={styles.errorCount}>{error.count}회</span>\r\n                        <div className={styles.errorBar} style={{ width: `${Math.min(100, error.count * 5)}%` }} />\r\n\r\n                        {error.examples && error.examples.length > 0 && (\r\n                          <div className={styles.errorExample}>\r\n                            <span className={styles.errorExampleLabel}>예시:</span>\r\n                            <span className={styles.errorExampleContent}>\r\n                              {error.examples[0].message}\r\n                            </span>\r\n                          </div>\r\n                        )}\r\n                      </li>\r\n                    ))}\r\n                  </ul>\r\n                </div>\r\n              );\r\n            }\r\n\r\n            if (insight.type === 'errorPeakHours' && insight.data.length > 0) {\r\n              return (\r\n                <div key={index} className={styles.insightItem}>\r\n                  <h5>오류 발생 빈도 높은 시간대</h5>\r\n                  <div className={styles.errorHoursChart}>\r\n                    {insight.data.map((hour, i) => (\r\n                      <div key={i} className={styles.errorHourBar}\r\n                        style={{\r\n                          height: `${Math.max(20, (hour.count / 5) * 100)}px`,\r\n                          backgroundColor: i === 0 ? '#e03131' : '#f08c00'\r\n                        }}\r\n                      >\r\n                        <span className={styles.errorHourLabel}>{hour.hour}시</span>\r\n                        <span className={styles.errorHourValue}>{hour.count}회</span>\r\n                      </div>\r\n                    ))}\r\n                  </div>\r\n                </div>\r\n              );\r\n            }\r\n\r\n            return null;\r\n          })}\r\n        </div>\r\n\r\n        {/* 메트릭 표시 */}\r\n        <div className={styles.metricsSection}>\r\n          <h4>오류 통계</h4>\r\n          <div className={styles.metricsGrid}>\r\n            {Object.entries(metrics).map(([key, value]) =>\r\n              renderMetricItem(\r\n                key\r\n                  .replace(/([A-Z])/g, ' $1')\r\n                  .replace(/^./, str => str.toUpperCase()),\r\n                value\r\n              )\r\n            )}\r\n          </div>\r\n        </div>\r\n\r\n        {/* 추천 사항 표시 */}\r\n        <div className={styles.recommendationsSection}>\r\n          <h4>추천 사항</h4>\r\n          {renderRecommendations(recommendations)}\r\n        </div>\r\n      </div>\r\n    );\r\n  };\r\n\r\n  /**\r\n   * 종합 분석 결과 렌더링\r\n   */\r\n  const renderOverallInsights = () => {\r\n    if (combinedRecommendations.length === 0) {\r\n      return (\r\n        <div className={styles.noResults}>\r\n          <p>종합 분석 결과가 없습니다. 먼저 다양한 유형의 학습을 실행하세요.</p>\r\n          <button\r\n            onClick={() => runLearning()}\r\n            disabled={isLoading}\r\n            className={styles.learningButton}\r\n          >\r\n            전체 학습 실행하기\r\n          </button>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return (\r\n      <div className={styles.resultSection}>\r\n        <h3>종합 분석 결과</h3>\r\n\r\n        <div className={styles.overallSummary}>\r\n          <div className={styles.summaryStats}>\r\n            <div className={styles.summaryStat}>\r\n              <span className={styles.summaryStatLabel}>분석된 모델</span>\r\n              <span className={styles.summaryStatValue}>{results.length}</span>\r\n            </div>\r\n            <div className={styles.summaryStat}>\r\n              <span className={styles.summaryStatLabel}>총 추천사항</span>\r\n              <span className={styles.summaryStatValue}>{combinedRecommendations.length}</span>\r\n            </div>\r\n            <div className={styles.summaryStat}>\r\n              <span className={styles.summaryStatLabel}>마지막 분석</span>\r\n              <span className={styles.summaryStatValue}>\r\n                {lastAnalysisTime\r\n                  ? new Date(lastAnalysisTime).toLocaleString()\r\n                  : '없음'}\r\n              </span>\r\n            </div>\r\n          </div>\r\n\r\n          <div className={styles.recommendationsSection}>\r\n            <h4>통합 추천 사항</h4>\r\n            {renderRecommendations(combinedRecommendations)}\r\n          </div>\r\n\r\n          <div className={styles.actionButtons}>\r\n            <button\r\n              onClick={() => runLearning()}\r\n              disabled={isLoading}\r\n              className={styles.learningButton}\r\n            >\r\n              {isLoading ? '학습 중...' : '학습 다시 실행하기'}\r\n            </button>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  };\r\n\r\n  // 선택한 탭에 따라 결과 렌더링\r\n  const renderSelectedTabContent = () => {\r\n    switch (selectedTab) {\r\n      case LearningModelType.MEMORY_OPTIMIZATION:\r\n        return renderMemoryOptimizationResults();\r\n      case LearningModelType.USER_BEHAVIOR:\r\n        return renderUserBehaviorResults();\r\n      case LearningModelType.ERROR_PREDICTION:\r\n        return renderErrorPredictionResults();\r\n      case LearningModelType.PERFORMANCE_OPTIMIZATION:\r\n        return renderOverallInsights();\r\n      default:\r\n        return <div>유효하지 않은 탭입니다.</div>;\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className={`${styles.logAnalysisPanel} ${className}`}>\r\n      <div className={styles.header}>\r\n        <h2>로그 분석 대시보드</h2>\r\n        {lastAnalysisTime && (\r\n          <p className={styles.lastAnalysisTime}>\r\n            마지막 분석: {new Date(lastAnalysisTime).toLocaleString()}\r\n          </p>\r\n        )}\r\n      </div>\r\n\r\n      {/* 학습 컨트롤 버튼 */}\r\n      <div className={styles.controls}>\r\n        <button\r\n          onClick={() => runLearning()}\r\n          disabled={isLoading}\r\n          className={styles.mainButton}\r\n        >\r\n          {isLoading ? '학습 중...' : '모든 데이터 학습하기'}\r\n        </button>\r\n      </div>\r\n\r\n      {/* 에러 메시지 */}\r\n      {error && (\r\n        <div className={styles.errorMessage}>\r\n          <p>오류 발생: {error}</p>\r\n        </div>\r\n      )}\r\n\r\n      {/* 학습 중 로딩 표시 */}\r\n      {isLoading && (\r\n        <div className={styles.loadingIndicator}>\r\n          <div className={styles.spinner}></div>\r\n          <p>로그 데이터 학습 중...</p>\r\n        </div>\r\n      )}\r\n\r\n      {/* 탭 네비게이션 */}\r\n      <div className={styles.tabNavigation}>\r\n        <button\r\n          className={`${styles.tabButton} ${selectedTab === LearningModelType.MEMORY_OPTIMIZATION ? styles.activeTab : ''}`}\r\n          onClick={() => setSelectedTab(LearningModelType.MEMORY_OPTIMIZATION)}\r\n        >\r\n          메모리 최적화\r\n        </button>\r\n        <button\r\n          className={`${styles.tabButton} ${selectedTab === LearningModelType.USER_BEHAVIOR ? styles.activeTab : ''}`}\r\n          onClick={() => setSelectedTab(LearningModelType.USER_BEHAVIOR)}\r\n        >\r\n          사용자 행동\r\n        </button>\r\n        <button\r\n          className={`${styles.tabButton} ${selectedTab === LearningModelType.ERROR_PREDICTION ? styles.activeTab : ''}`}\r\n          onClick={() => setSelectedTab(LearningModelType.ERROR_PREDICTION)}\r\n        >\r\n          오류 예측\r\n        </button>\r\n        <button\r\n          className={`${styles.tabButton} ${selectedTab === LearningModelType.PERFORMANCE_OPTIMIZATION ? styles.activeTab : ''}`}\r\n          onClick={() => setSelectedTab(LearningModelType.PERFORMANCE_OPTIMIZATION)}\r\n        >\r\n          종합 분석\r\n        </button>\r\n      </div>\r\n\r\n      {/* 선택한 탭 내용 렌더링 */}\r\n      <div className={styles.tabContent}>\r\n        {renderSelectedTabContent()}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\MainLayout.tsx","messages":[{"ruleId":"no-undef","severity":2,"message":"'HTMLDivElement' is not defined.","line":29,"column":37,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":51}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport React, { memo, useRef, ReactNode } from 'react';\r\nimport { AppHeader } from './AppHeader';\r\nimport { AppFooter } from './AppFooter';\r\nimport styles from '../page.module.css';\r\n\r\n// Define the ElectronAPI interface\r\ninterface ElectronAPI {\r\n  // Add properties that your electron API needs\r\n  // For example: minimize: () => void;\r\n}\r\n\r\ninterface MainLayoutProps {\r\n  children: ReactNode;\r\n  darkMode?: boolean;\r\n  windowMode?: string;\r\n  electronAPI?: ElectronAPI | null;\r\n  isHeaderVisible?: boolean;\r\n}\r\n\r\nexport const MainLayout = memo(function MainLayout({\r\n  children,\r\n  darkMode = false,\r\n  windowMode = 'normal',\r\n  electronAPI = null,\r\n  isHeaderVisible = true\r\n}: MainLayoutProps) {\r\n  const headerDetectionRef = useRef<HTMLDivElement>(null);\r\n\r\n  return (\r\n    <div\r\n      className={`${styles.container} ${darkMode ? 'dark-mode' : ''} ${windowMode === 'fullscreen-auto-hide' ? styles.zenMode : ''}`}\r\n      style={{ position: 'relative', zIndex: 1 }}\r\n    >\r\n      {/* AppHeader 컴포넌트 추가 */}\r\n      {isHeaderVisible && <AppHeader api={electronAPI} />}\r\n\r\n      {/* 네비게이션 링크 추가 */}\r\n      {isHeaderVisible && (\r\n        <nav className={styles.navLinks}>\r\n          <ul>\r\n            <li>\r\n              <a href=\"/\" className={styles.navLink}>홈</a>\r\n            </li>\r\n            <li>\r\n              <a href=\"/pages/analysis\" className={styles.navLink}>로그 분석</a>\r\n            </li>\r\n          </ul>\r\n        </nav>\r\n      )}\r\n\r\n      {/* 자동 숨김 모드일 때 감지 영역 추가 */}\r\n      {windowMode === 'fullscreen-auto-hide' && (\r\n        <div\r\n          ref={headerDetectionRef}\r\n          className={styles.headerDetectionArea}\r\n          aria-hidden=\"true\"\r\n          style={{ pointerEvents: 'auto' }}\r\n        />\r\n      )}\r\n\r\n      <main className={styles.mainContent}>\r\n        {children}\r\n      </main>\r\n\r\n      <AppFooter />\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default MainLayout;\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\MemoryMonitor.tsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'formatBytes' is defined but never used.","line":18,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'formatBytes' is defined but never used.","line":18,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":132,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":132,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":194,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":194,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":208,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":208,"endColumn":16},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":208,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":208,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5505,5560],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":214,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":214,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":226,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":226,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":233,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":233,"endColumn":22}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useState, useEffect, useRef } from 'react';\r\nimport { \r\n  Chart as ChartJS, \r\n  CategoryScale, \r\n  LinearScale, \r\n  PointElement, \r\n  LineElement, \r\n  Title, \r\n  Tooltip, \r\n  Legend, \r\n  ChartOptions \r\n} from 'chart.js';\r\nimport { Line } from 'react-chartjs-2';\r\nimport { getMemoryInfo } from '../utils/memory/memory-info';\r\nimport { requestGC } from '../utils/memory/gc-utils';\r\nimport { formatBytes } from '../utils/memory/format-utils';\r\nimport styles from './MemoryMonitor.module.css';\r\n\r\n// 차트 등록\r\nChartJS.register(\r\n  CategoryScale,\r\n  LinearScale,\r\n  PointElement,\r\n  LineElement,\r\n  Title,\r\n  Tooltip,\r\n  Legend\r\n);\r\n\r\n// 메모리 타임스탬프 형식화\r\nconst formatTime = (timestamp: number) => {\r\n  const date = new Date(timestamp);\r\n  return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`;\r\n};\r\n\r\n// 차트 옵션\r\nconst chartOptions: ChartOptions<'line'> = {\r\n  responsive: true,\r\n  maintainAspectRatio: false,\r\n  animation: {\r\n    duration: 500\r\n  },\r\n  scales: {\r\n    y: {\r\n      beginAtZero: true,\r\n      title: {\r\n        display: true,\r\n        text: 'Memory (MB)'\r\n      }\r\n    },\r\n    x: {\r\n      title: {\r\n        display: true,\r\n        text: 'Time'\r\n      }\r\n    }\r\n  },\r\n  plugins: {\r\n    legend: {\r\n      position: 'top',\r\n    },\r\n    tooltip: {\r\n      callbacks: {\r\n        label: (context) => {\r\n          const label = context.dataset.label || '';\r\n          const value = context.parsed.y || 0;\r\n          return `${label}: ${value.toFixed(2)} MB`;\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\ninterface MemoryMonitorProps {\r\n  pollInterval?: number; // 데이터 수집 간격 (ms)\r\n  historyLength?: number; // 기록할 데이터 포인트 수\r\n  showControls?: boolean; // GC 버튼 등 컨트롤 표시 여부\r\n  height?: number; // 차트 높이\r\n  detailed?: boolean; // 상세 정보 표시 여부\r\n  darkMode?: boolean; // 다크 모드 여부\r\n}\r\n\r\n/**\r\n * 메모리 모니터링 컴포넌트\r\n * \r\n * 실시간으로 메모리 사용량을 그래프로 표시하고 메모리 관리 기능을 제공합니다.\r\n */\r\nexport default function MemoryMonitor({\r\n  pollInterval = 5000,\r\n  historyLength = 20,\r\n  showControls = true,\r\n  height = 300,\r\n  detailed = true,\r\n  darkMode = false\r\n}: MemoryMonitorProps) {\r\n  // 메모리 데이터 상태\r\n  const [memoryData, setMemoryData] = useState<{\r\n    labels: string[];\r\n    used: number[];\r\n    total: number[];\r\n    percent: number[];\r\n    rss?: number[];\r\n  }>({\r\n    labels: [],\r\n    used: [],\r\n    total: [],\r\n    percent: [],\r\n    rss: []\r\n  });\r\n  \r\n  // 현재 메모리 상태\r\n  const [currentMemory, setCurrentMemory] = useState<{\r\n    heapUsed: number;\r\n    heapTotal: number;\r\n    percentUsed: number;\r\n    rss?: number;\r\n    timestamp: number;\r\n  } | null>(null);\r\n  \r\n  // 갱신 중 상태\r\n  const [isRefreshing, setIsRefreshing] = useState(false);\r\n  \r\n  // GC 실행 중 상태\r\n  const [isPerformingGC, setIsPerformingGC] = useState(false);\r\n  \r\n  // 메모리 상태 (안전, 주의, 위험)\r\n  const [memoryStatus, setMemoryStatus] = useState<'safe' | 'warning' | 'danger'>('safe');\r\n  \r\n  // 애니메이션을 위한 타이머 ID\r\n  const timerRef = useRef<NodeJS.Timeout | null>(null);\r\n  \r\n  // 메모리 상태 평가 함수\r\n  const evaluateMemoryStatus = (percentUsed: number) => {\r\n    if (percentUsed > 85) return 'danger';\r\n    if (percentUsed > 70) return 'warning';\r\n    return 'safe';\r\n  };\r\n  \r\n  // 메모리 정보 가져오기\r\n  const fetchMemoryInfo = async () => {\r\n    try {\r\n      setIsRefreshing(true);\r\n      \r\n      const memoryInfo = await getMemoryInfo();\r\n      \r\n      if (memoryInfo) {\r\n        const timestamp = memoryInfo.timestamp || Date.now();\r\n        const formattedTime = formatTime(timestamp);\r\n        \r\n        // 메모리 상태 업데이트\r\n        setCurrentMemory({\r\n          heapUsed: memoryInfo.heap_used_mb || memoryInfo.heapUsedMB || 0,\r\n          heapTotal: (memoryInfo.heap_total || 0) / (1024 * 1024),\r\n          percentUsed: memoryInfo.percent_used || memoryInfo.percentUsed || 0,\r\n          rss: memoryInfo.rss_mb || memoryInfo.rssMB,\r\n          timestamp\r\n        });\r\n        \r\n        // 메모리 상태 평가\r\n        setMemoryStatus(evaluateMemoryStatus(\r\n          memoryInfo.percent_used || memoryInfo.percentUsed || 0\r\n        ));\r\n        \r\n        // 차트 데이터 업데이트\r\n        setMemoryData(prev => {\r\n          // 새 데이터 포인트 추가\r\n          const newLabels = [...prev.labels, formattedTime];\r\n          const newUsed = [...prev.used, memoryInfo.heap_used_mb || memoryInfo.heapUsedMB || 0];\r\n          const newTotal = [...prev.total, (memoryInfo.heap_total || 0) / (1024 * 1024)];\r\n          const newPercent = [...prev.percent, memoryInfo.percent_used || memoryInfo.percentUsed || 0];\r\n          const newRSS = [...(prev.rss || []), memoryInfo.rss_mb || memoryInfo.rssMB || 0];\r\n          \r\n          // 데이터 개수 제한\r\n          if (newLabels.length > historyLength) {\r\n            newLabels.shift();\r\n            newUsed.shift();\r\n            newTotal.shift();\r\n            newPercent.shift();\r\n            if (newRSS.length > historyLength) newRSS.shift();\r\n          }\r\n          \r\n          return {\r\n            labels: newLabels,\r\n            used: newUsed,\r\n            total: newTotal,\r\n            percent: newPercent,\r\n            rss: newRSS\r\n          };\r\n        });\r\n      }\r\n    } catch (error) {\r\n      console.error('메모리 정보 가져오기 오류:', error);\r\n    } finally {\r\n      setIsRefreshing(false);\r\n    }\r\n  };\r\n  \r\n  // 가비지 컬렉션 요청\r\n  const handleGarbageCollection = async () => {\r\n    try {\r\n      setIsPerformingGC(true);\r\n      const result = await requestGC();\r\n      \r\n      if (result && result.success) {\r\n        const freedMB = result.freedMB || 0;\r\n        console.log(`가비지 컬렉션 완료: ${freedMB.toFixed(2)}MB 해제됨`);\r\n      }\r\n      \r\n      // GC 후 메모리 정보 갱신\r\n      await fetchMemoryInfo();\r\n    } catch (error) {\r\n      console.error('가비지 컬렉션 오류:', error);\r\n    } finally {\r\n      setIsPerformingGC(false);\r\n    }\r\n  };\r\n  \r\n  // 초기화 및 주기적 갱신\r\n  useEffect(() => {\r\n    // 초기 데이터 로드\r\n    fetchMemoryInfo();\r\n    \r\n    // 주기적 갱신 설정\r\n    timerRef.current = setInterval(() => {\r\n      fetchMemoryInfo();\r\n    }, pollInterval);\r\n    \r\n    // 정리 함수\r\n    return () => {\r\n      if (timerRef.current) {\r\n        clearInterval(timerRef.current);\r\n      }\r\n    };\r\n  }, [pollInterval]);\r\n  \r\n  // 차트 데이터\r\n  const chartData = {\r\n    labels: memoryData.labels,\r\n    datasets: [\r\n      {\r\n        label: 'Heap Used (MB)',\r\n        data: memoryData.used,\r\n        borderColor: 'rgb(75, 192, 192)',\r\n        backgroundColor: 'rgba(75, 192, 192, 0.2)',\r\n        tension: 0.4\r\n      },\r\n      ...(detailed ? [{\r\n        label: 'RSS (MB)',\r\n        data: memoryData.rss,\r\n        borderColor: 'rgb(153, 102, 255)',\r\n        backgroundColor: 'rgba(153, 102, 255, 0.2)',\r\n        tension: 0.4\r\n      }] : [])\r\n    ]\r\n  };\r\n  \r\n  return (\r\n    <div className={`${styles.container} ${darkMode ? styles.darkMode : ''}`}>\r\n      <h3 className={styles.title}>메모리 모니터링</h3>\r\n      \r\n      {/* 현재 메모리 상태 */}\r\n      <div className={`${styles.statsContainer} ${styles[memoryStatus]}`}>\r\n        {currentMemory ? (\r\n          <>\r\n            <div className={styles.stat}>\r\n              <span className={styles.statLabel}>사용됨:</span>\r\n              <span className={styles.statValue}>{currentMemory.heapUsed.toFixed(2)} MB</span>\r\n            </div>\r\n            {detailed && (\r\n              <div className={styles.stat}>\r\n                <span className={styles.statLabel}>전체:</span>\r\n                <span className={styles.statValue}>{currentMemory.heapTotal.toFixed(2)} MB</span>\r\n              </div>\r\n            )}\r\n            <div className={styles.stat}>\r\n              <span className={styles.statLabel}>사용률:</span>\r\n              <span className={styles.statValue}>{currentMemory.percentUsed.toFixed(1)}%</span>\r\n            </div>\r\n            {detailed && currentMemory.rss && (\r\n              <div className={styles.stat}>\r\n                <span className={styles.statLabel}>RSS:</span>\r\n                <span className={styles.statValue}>{currentMemory.rss.toFixed(2)} MB</span>\r\n              </div>\r\n            )}\r\n          </>\r\n        ) : (\r\n          <div className={styles.loading}>데이터 로드 중...</div>\r\n        )}\r\n      </div>\r\n      \r\n      {/* 메모리 사용량 차트 */}\r\n      <div className={styles.chartContainer} style={{ height: `${height}px` }}>\r\n        <Line data={chartData} options={chartOptions} />\r\n      </div>\r\n      \r\n      {/* 컨트롤 버튼 */}\r\n      {showControls && (\r\n        <div className={styles.controls}>\r\n          <button \r\n            className={styles.refreshButton} \r\n            onClick={fetchMemoryInfo}\r\n            disabled={isRefreshing}\r\n          >\r\n            {isRefreshing ? '갱신 중...' : '수동 갱신'}\r\n          </button>\r\n          \r\n          <button \r\n            className={styles.gcButton} \r\n            onClick={handleGarbageCollection}\r\n            disabled={isPerformingGC}\r\n          >\r\n            {isPerformingGC ? 'GC 실행 중...' : '가비지 컬렉션 실행'}\r\n          </button>\r\n        </div>\r\n      )}\r\n      \r\n      {/* 메모리 상태 표시 */}\r\n      <div className={`${styles.statusIndicator} ${styles[memoryStatus]}`}>\r\n        <div className={styles.statusLabel}>\r\n          {memoryStatus === 'safe' && '정상'}\r\n          {memoryStatus === 'warning' && '주의'}\r\n          {memoryStatus === 'danger' && '위험'}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\MemorySettingsPanel.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Identifier expected.","line":319,"column":31,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useState, useEffect } from 'react';\r\nimport { \r\n  loadMemorySettings, \r\n  saveMemorySettings, \r\n  resetMemorySettings \r\n} from '../settings/memory-settings';\r\nimport { MemorySettings } from '@/types'; // @/types에서 MemorySettings 타입 가져오기\r\nimport { runComprehensiveBenchmark } from '../utils/performance-metrics';\r\n// 메모리 유틸리티 가져오기\r\nimport { setupMemoryUtils } from '../utils/memory';\r\nimport { getNativeModuleStatus } from '../utils/nativeModuleClient';\r\nimport styles from './MemorySettingsPanel.module.css';\r\n\r\ninterface MemorySettingsPanelProps {\r\n  showPerformanceData?: boolean;\r\n  onSettingsChange?: (settings: MemorySettings) => void;\r\n}\r\n\r\n// 메모리 매니저 상태 인터페이스 정의\r\ninterface MemoryManagerState {\r\n  nativeAvailable: boolean;\r\n  inFallbackMode: boolean;\r\n  monitoringActive: boolean;\r\n  lastNativeCheck: number | null;\r\n  recentFailures: Array<{\r\n    timestamp: number;\r\n    operation: string;\r\n    error: string;\r\n  }>;\r\n  optimizationHistory: Array<{\r\n    timestamp: number;\r\n    level: string;\r\n    implementation: 'native' | 'js';\r\n    success: boolean;\r\n    freedMemory?: number;\r\n  }>;\r\n}\r\n\r\nconst MemorySettingsPanel: React.FC<MemorySettingsPanelProps> = ({\r\n  showPerformanceData = true,\r\n  onSettingsChange\r\n}) => {\r\n  // 설정 상태\r\n  const [settings, setSettings] = useState<MemorySettings | null>(null);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [isNativeAvailable, setIsNativeAvailable] = useState(false);\r\n  const [isBenchmarking, setIsBenchmarking] = useState(false);\r\n  const [activeTab, setActiveTab] = useState('general');\r\n  const [managerState, setManagerState] = useState<MemoryManagerState | null>(null);\r\n  \r\n  // 설정 초기 로딩\r\n  useEffect(() => {\r\n    const initializeSettings = async () => {\r\n      try {\r\n        // 메모리 유틸리티 초기화\r\n        setupMemoryUtils();\r\n        \r\n        // 네이티브 모듈 상태 확인\r\n        const { available } = await getNativeModuleStatus();\r\n        setIsNativeAvailable(available);\r\n        \r\n        // 메모리 설정 로딩\r\n        const loadedSettings = loadMemorySettings();\r\n        setSettings(loadedSettings);\r\n        \r\n        // 메모리 매니저 상태 직접 설정 (함수를 직접 호출하는 대신)\r\n        setManagerState({\r\n          nativeAvailable: available,\r\n          inFallbackMode: !available,\r\n          monitoringActive: true,\r\n          lastNativeCheck: Date.now(),\r\n          recentFailures: [],\r\n          optimizationHistory: []\r\n        });\r\n      } catch (error) {\r\n        console.error('설정 초기화 오류:', error);\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    };\r\n    \r\n    initializeSettings();\r\n  }, []);\r\n  \r\n  // 설정 변경 핸들러\r\n  const handleSettingChange = <K extends keyof MemorySettings>(\r\n    key: K, \r\n    value: MemorySettings[K]\r\n  ) => {\r\n    if (!settings) return;\r\n    \r\n    const updatedSettings = { ...settings, [key]: value };\r\n    setSettings(updatedSettings);\r\n    saveMemorySettings(updatedSettings);\r\n    \r\n    if (onSettingsChange) {\r\n      onSettingsChange(updatedSettings);\r\n    }\r\n  };\r\n  \r\n  // 컴포넌트 설정 변경 핸들러\r\n  const handleComponentSettingChange = (\r\n    componentId: string,\r\n    key: 'optimizeOnUnmount' | 'aggressiveCleanup',\r\n    value: boolean\r\n  ) => {\r\n    if (!settings) return;\r\n    \r\n    const updatedSettings = { \r\n      ...settings,\r\n      componentSpecificSettings: {\r\n        ...settings.componentSpecificSettings,\r\n        [componentId]: {\r\n          ...settings.componentSpecificSettings[componentId] || {\r\n            optimizeOnUnmount: false,\r\n            aggressiveCleanup: false\r\n          },\r\n          [key]: value\r\n        }\r\n      }\r\n    };\r\n    \r\n    setSettings(updatedSettings);\r\n    saveMemorySettings(updatedSettings);\r\n    \r\n    if (onSettingsChange) {\r\n      onSettingsChange(updatedSettings);\r\n    }\r\n  };\r\n  \r\n  // 설정 초기화 핸들러\r\n  const handleResetSettings = () => {\r\n    resetMemorySettings();\r\n    const defaultSettings = loadMemorySettings();\r\n    setSettings(defaultSettings);\r\n    \r\n    if (onSettingsChange) {\r\n      onSettingsChange(defaultSettings);\r\n    }\r\n  };\r\n  \r\n  // 벤치마크 실행 핸들러\r\n  const handleRunBenchmark = async () => {\r\n    setIsBenchmarking(true);\r\n    try {\r\n      await runComprehensiveBenchmark();\r\n    } finally {\r\n      setIsBenchmarking(false);\r\n    }\r\n  };\r\n  \r\n  // 로딩 중이거나 설정이 없는 경우 로딩 표시\r\n  if (isLoading || !settings) {\r\n    return <div className={styles.loading}>설정 로딩 중...</div>;\r\n  }\r\n  \r\n  return (\r\n    <div className={styles.container}>\r\n      <h2 className={styles.title}>메모리 최적화 설정</h2>\r\n      \r\n      <div className={styles.tabs}>\r\n        <button \r\n          className={`${styles.tabButton} ${activeTab === 'general' ? styles.activeTab : ''}`}\r\n          onClick={() => setActiveTab('general')}\r\n        >\r\n          기본 설정\r\n        </button>\r\n        <button \r\n          className={`${styles.tabButton} ${activeTab === 'advanced' ? styles.activeTab : ''}`}\r\n          onClick={() => setActiveTab('advanced')}\r\n        >\r\n          고급 설정\r\n        </button>\r\n        <button \r\n          className={`${styles.tabButton} ${activeTab === 'components' ? styles.activeTab : ''}`}\r\n          onClick={() => setActiveTab('components')}\r\n        >\r\n          컴포넌트 설정\r\n        </button>\r\n        {showPerformanceData && (\r\n          <button \r\n            className={`${styles.tabButton} ${activeTab === 'performance' ? styles.activeTab : ''}`}\r\n            onClick={() => setActiveTab('performance')}\r\n          >\r\n            성능 데이터\r\n          </button>\r\n        )}\r\n      </div>\r\n      \r\n      <div className={styles.tabContent}>\r\n        {/* 기본 설정 탭 */}\r\n        {activeTab === 'general' && (\r\n          <div className={styles.settingsGroup}>\r\n            <div className={styles.settingItem}>\r\n              <div className={styles.settingLabel}>\r\n                <div className={styles.settingTitle}>네이티브 구현 선호</div>\r\n                <div className={styles.settingDescription}>\r\n                  가능한 경우 JavaScript 대신 Rust 네이티브 모듈 사용\r\n                </div>\r\n              </div>\r\n              <div className={styles.settingControl}>\r\n                <label className={styles.switch}>\r\n                  <input \r\n                    type=\"checkbox\" \r\n                    checked={settings.preferNativeImplementation}\r\n                    onChange={(e) => handleSettingChange('preferNativeImplementation', e.target.checked)}\r\n                    disabled={!isNativeAvailable}\r\n                  />\r\n                  <span className={styles.slider}></span>\r\n                </label>\r\n              </div>\r\n            </div>\r\n            \r\n            <div className={styles.settingItem}>\r\n              <div className={styles.settingLabel}>\r\n                <div className={styles.settingTitle}>자동 폴백 활성화</div>\r\n                <div className={styles.settingDescription}>\r\n                  네이티브 모듈 실패 시 자동으로 JavaScript 구현으로 전환\r\n                </div>\r\n              </div>\r\n              <div className={styles.settingControl}>\r\n                <label className={styles.switch}>\r\n                  <input \r\n                    type=\"checkbox\" \r\n                    checked={settings.enableAutomaticFallback}\r\n                    onChange={(e) => handleSettingChange('enableAutomaticFallback', e.target.checked)}\r\n                  />\r\n                  <span className={styles.slider}></span>\r\n                </label>\r\n              </div>\r\n            </div>\r\n            \r\n            <div className={styles.settingItem}>\r\n              <div className={styles.settingLabel}>\r\n                <div className={styles.settingTitle}>자동 최적화 활성화</div>\r\n                <div className={styles.settingDescription}>\r\n                  메모리 사용량이 임계값을 초과할 때 자동으로 최적화 수행\r\n                </div>\r\n              </div>\r\n              <div className={styles.settingControl}>\r\n                <label className={styles.switch}>\r\n                  <input \r\n                    type=\"checkbox\" \r\n                    checked={settings.enableAutomaticOptimization}\r\n                    onChange={(e) => handleSettingChange('enableAutomaticOptimization', e.target.checked)}\r\n                  />\r\n                  <span className={styles.slider}></span>\r\n                </label>\r\n              </div>\r\n            </div>\r\n            \r\n            <div className={styles.settingItem}>\r\n              <div className={styles.settingLabel}>\r\n                <div className={styles.settingTitle}>최적화 임계값 (MB)</div>\r\n                <div className={styles.settingDescription}>\r\n                  이 값을 초과하면 자동 최적화가 실행됩니다\r\n                </div>\r\n              </div>\r\n              <div className={styles.settingControl}>\r\n                <input \r\n                  type=\"number\"\r\n                  className={styles.numberInput}\r\n                  min={50}\r\n                  max={500}\r\n                  value={settings.optimizationThreshold}\r\n                  onChange={(e) => handleSettingChange('optimizationThreshold', Number(e.target.value))}\r\n                  disabled={!settings.enableAutomaticOptimization}\r\n                />\r\n              </div>\r\n            </div>\r\n            \r\n            <div className={styles.settingItem}>\r\n              <div className={styles.settingLabel}>\r\n                <div className={styles.settingTitle}>최적화 체크 간격 (초)</div>\r\n                <div className={styles.settingDescription}>\r\n                  자동 최적화 체크 주기\r\n                </div>\r\n              </div>\r\n              <div className={styles.settingControl}>\r\n                <input \r\n                  type=\"number\"\r\n                  className={styles.numberInput}\r\n                  min={10}\r\n                  max={300}\r\n                  value={settings.optimizationInterval / 1000}\r\n                  onChange={(e) => handleSettingChange('optimizationInterval', Number(e.target.value) * 1000)}\r\n                  disabled={!settings.enableAutomaticOptimization}\r\n                />\r\n              </div>\r\n            </div>\r\n          </div>\r\n        )}\r\n        \r\n        {/* 고급 설정 탭 */}\r\n        {activeTab === 'advanced' && (\r\n          <div className={styles.settingsGroup}>\r\n            <div className={styles.settingItem}>\r\n              <div className={styles.settingLabel}>\r\n                <div className={styles.settingTitle}>적극적 GC 사용</div>\r\n                <div className={styles.settingDescription}>\r\n                  더 빈번하고 강력한 가비지 컬렉션 수행 (성능 영향 있음)\r\n                </div>\r\n              </div>\r\n              <div className={styles.settingControl}>\r\n                <label className={styles.switch}>\r\n                  <input \r\n                    type=\"checkbox\" \r\n                    checked={settings.aggressiveGC}\r\n                    onChange={(e) => handleSettingChange('aggressiveGC', e.target.checked)}\r\n                  />\r\n                  <span className={styles.slider}></span>\r\n                </label>\r\n              </div>\r\n            </div>\r\n            \r\n            <div className={styles.settingItem}>\r\n              <div class는styles.settingLabel}>\r\n                <div className={styles.settingTitle}>상세 로깅 활성화</div>\r\n                <div className={styles.settingDescription}>\r\n                  메모리 사용 패턴 및 최적화 작업 상세 로깅\r\n                </div>\r\n              </div>\r\n              <div className={styles.settingControl}>\r\n                <label className={styles.switch}>\r\n                  <input \r\n                    type=\"checkbox\" \r\n                    checked={settings.enableLogging}\r\n                    onChange={(e) => handleSettingChange('enableLogging', e.target.checked)}\r\n                  />\r\n                  <span className={styles.slider}></span>\r\n                </label>\r\n              </div>\r\n            </div>\r\n            \r\n            <div className={styles.settingItem}>\r\n              <div className={styles.settingLabel}>\r\n                <div className={styles.settingTitle}>성능 측정 활성화</div>\r\n                <div className={styles.settingDescription}>\r\n                  네이티브 및 JavaScript 구현 간 성능 비교 측정\r\n                </div>\r\n              </div>\r\n              <div className={styles.settingControl}>\r\n                <label className={styles.switch}>\r\n                  <input \r\n                    type=\"checkbox\" \r\n                    checked={settings.enablePerformanceMetrics}\r\n                    onChange={(e) => handleSettingChange('enablePerformanceMetrics', e.target.checked)}\r\n                  />\r\n                  <span className={styles.slider}></span>\r\n                </label>\r\n              </div>\r\n            </div>\r\n            \r\n            <div className={styles.settingItem}>\r\n              <div className={styles.settingLabel}>\r\n                <div className={styles.settingTitle}>메모리 풀 사용</div>\r\n                <div className={styles.settingDescription}>\r\n                  객체 재사용을 위한 메모리 풀링 활성화\r\n                </div>\r\n              </div>\r\n              <div className={styles.settingControl}>\r\n                <label className={styles.switch}>\r\n                  <input \r\n                    type=\"checkbox\" \r\n                    checked={settings.useMemoryPool}\r\n                    onChange={(e) => handleSettingChange('useMemoryPool', e.target.checked)}\r\n                  />\r\n                  <span className={styles.slider}></span>\r\n                </label>\r\n              </div>\r\n            </div>\r\n            \r\n            <div className={styles.settingItem}>\r\n              <div className={styles.settingLabel}>\r\n                <div className={styles.settingTitle}>폴백 재시도 간격 (분)</div>\r\n                <div className={styles.settingDescription}>\r\n                  네이티브 모듈 폴백 후 재시도 대기 시간\r\n                </div>\r\n              </div>\r\n              <div className={styles.settingControl}>\r\n                <input \r\n                  type=\"number\"\r\n                  className={styles.numberInput}\r\n                  min={1}\r\n                  max={60}\r\n                  value={settings.fallbackRetryDelay / 60000}\r\n                  onChange={(e) => handleSettingChange('fallbackRetryDelay', Number(e.target.value) * 60000)}\r\n                  disabled={!settings.enableAutomaticFallback}\r\n                />\r\n              </div>\r\n            </div>\r\n            \r\n            <div className={styles.settingItem}>\r\n              <div className={styles.settingLabel}>\r\n                <div className={styles.settingTitle}>풀 정리 간격 (분)</div>\r\n                <div className={styles.settingDescription}>\r\n                  메모리 풀 정리 주기\r\n                </div>\r\n              </div>\r\n              <div className={styles.settingControl}>\r\n                <input \r\n                  type=\"number\"\r\n                  className={styles.numberInput}\r\n                  min={1}\r\n                  max={60}\r\n                  value={settings.poolCleanupInterval / 60000}\r\n                  onChange={(e) => handleSettingChange('poolCleanupInterval', Number(e.target.value) * 60000)}\r\n                  disabled={!settings.useMemoryPool}\r\n                />\r\n              </div>\r\n            </div>\r\n          </div>\r\n        )}\r\n        \r\n        {/* 컴포넌트 설정 탭 */}\r\n        {activeTab === 'components' && (\r\n          <div className={styles.settingsGroup}>\r\n            <div className={styles.componentSettings}>\r\n              <h3>컴포넌트별 최적화 설정</h3>\r\n              <p className={styles.componentDescription}>\r\n                특정 컴포넌트에 대한 메모리 최적화 동작을 설정합니다.\r\n              </p>\r\n              \r\n              {Object.keys(settings.componentSpecificSettings).length > 0 ? (\r\n                Object.entries(settings.componentSpecificSettings).map(([id, compSettings]) => (\r\n                  <div key={id} className={styles.componentItem}>\r\n                    <div className={styles.componentHeader}>\r\n                      <h4>{id}</h4>\r\n                    </div>\r\n                    <div className={styles.componentControls}>\r\n                      <div className={styles.settingItem}>\r\n                        <div className={styles.settingLabel}>언마운트 시 최적화</div>\r\n                        <div className={styles.settingControl}>\r\n                          <label className={styles.switch}>\r\n                            <input \r\n                              type=\"checkbox\" \r\n                              checked={compSettings.optimizeOnUnmount}\r\n                              onChange={(e) => handleComponentSettingChange(\r\n                                id, 'optimizeOnUnmount', e.target.checked\r\n                              )}\r\n                            />\r\n                            <span className={styles.slider}></span>\r\n                          </label>\r\n                        </div>\r\n                      </div>\r\n                      <div className={styles.settingItem}>\r\n                        <div className={styles.settingLabel}>적극적 정리</div>\r\n                        <div className={styles.settingControl}>\r\n                          <label className={styles.switch}>\r\n                            <input \r\n                              type=\"checkbox\" \r\n                              checked={compSettings.aggressiveCleanup}\r\n                              onChange={(e) => handleComponentSettingChange(\r\n                                id, 'aggressiveCleanup', e.target.checked\r\n                              )}\r\n                            />\r\n                            <span className={styles.slider}></span>\r\n                          </label>\r\n                        </div>\r\n                      </div>\r\n                    </div>\r\n                  </div>\r\n                ))\r\n              ) : (\r\n                <div className={styles.emptyState}>\r\n                  컴포넌트별 설정이 없습니다. 컴포넌트 마운트 시 자동으로 추가됩니다.\r\n                </div>\r\n              )}\r\n            </div>\r\n          </div>\r\n        )}\r\n        \r\n        {/* 성능 데이터 탭 */}\r\n        {activeTab === 'performance' && showPerformanceData && (\r\n          <div className={styles.settingsGroup}>\r\n            <div className={styles.performanceData}>\r\n              <h3>성능 측정 데이터</h3>\r\n              \r\n              <div className={styles.benchmarkControls}>\r\n                <button \r\n                  className={styles.benchmarkButton}\r\n                  onClick={handleRunBenchmark}\r\n                  disabled={isBenchmarking}\r\n                >\r\n                  {isBenchmarking ? '벤치마크 실행 중...' : '종합 벤치마크 실행'}\r\n                </button>\r\n                <p className={styles.benchmarkDesc}>\r\n                  네이티브 및 JavaScript 구현 간의 성능을 측정합니다.\r\n                </p>\r\n              </div>\r\n              \r\n              {/* 메모리 매니저 상태 표시 */}\r\n              {managerState && (\r\n                <div className={styles.managerState}>\r\n                  <h4>메모리 매니저 상태</h4>\r\n                  <div className={styles.stateGrid}>\r\n                    <div className={styles.stateItem}>\r\n                      <div className={styles.stateLabel}>네이티브 모듈 가용성</div>\r\n                      <div className={styles.stateValue}>\r\n                        {managerState.nativeAvailable ? '사용 가능' : '사용 불가'}\r\n                      </div>\r\n                    </div>\r\n                    <div className={styles.stateItem}>\r\n                      <div className={styles.stateLabel}>폴백 모드</div>\r\n                      <div className={styles.stateValue}>\r\n                        {managerState.inFallbackMode ? '활성화됨' : '비활성화됨'}\r\n                      </div>\r\n                    </div>\r\n                    <div className={styles.stateItem}>\r\n                      <div className={styles.stateLabel}>모니터링 활성화</div>\r\n                      <div className={styles.stateValue}>\r\n                        {managerState.monitoringActive ? '활성화됨' : '비활성화됨'}\r\n                      </div>\r\n                    </div>\r\n                    <div className={styles.stateItem}>\r\n                      <div className={styles.stateLabel}>마지막 네이티브 체크</div>\r\n                      <div className={styles.stateValue}>\r\n                        {managerState.lastNativeCheck ? new Date(managerState.lastNativeCheck).toLocaleTimeString() : '없음'}\r\n                      </div>\r\n                    </div>\r\n                  </div>\r\n                  \r\n                  {/* 최근 실패 기록 */}\r\n                  {managerState.recentFailures.length > 0 && (\r\n                    <div className={styles.failureLog}>\r\n                      <h4>최근 실패 기록</h4>\r\n                      <ul className={styles.failureList}>\r\n                        {managerState.recentFailures.map((failure: any, index: number) => (\r\n                          <li key={index} className={styles.failureItem}>\r\n                            <div className={styles.failureTime}>\r\n                              {new Date(failure.timestamp).toLocaleTimeString()}\r\n                            </div>\r\n                            <div className={styles.failureOperation}>\r\n                              {failure.operation}\r\n                            </div>\r\n                            <div className={styles.failureError}>\r\n                              {failure.error}\r\n                            </div>\r\n                          </li>\r\n                        ))}\r\n                      </ul>\r\n                    </div>\r\n                  )}\r\n                  \r\n                  {/* 최적화 이력 */}\r\n                  {managerState.optimizationHistory.length > 0 && (\r\n                    <div className={styles.optimizationHistory}>\r\n                      <h4>최근 최적화 이력</h4>\r\n                      <div className={styles.historyTable}>\r\n                        <table>\r\n                          <thead>\r\n                            <tr>\r\n                              <th>시간</th>\r\n                              <th>레벨</th>\r\n                              <th>구현</th>\r\n                              <th>결과</th>\r\n                              <th>해제 메모리</th>\r\n                            </tr>\r\n                          </thead>\r\n                          <tbody>\r\n                            {managerState.optimizationHistory.map((record: any, index: number) => (\r\n                              <tr key={index}>\r\n                                <td>{new Date(record.timestamp).toLocaleTimeString()}</td>\r\n                                <td>{record.level}</td>\r\n                                <td>{record.implementation === 'native' ? '네이티브' : 'JS'}</td>\r\n                                <td>{record.success ? '성공' : '실패'}</td>\r\n                                <td>{record.freedMemory ? `${record.freedMemory.toFixed(2)}MB` : '-'}</td>\r\n                              </tr>\r\n                            ))}\r\n                          </tbody>\r\n                        </table>\r\n                      </div>\r\n                    </div>\r\n                  )}\r\n                </div>\r\n              )}\r\n            </div>\r\n          </div>\r\n        )}\r\n      </div>\r\n      \r\n      <div className={styles.actions}>\r\n        <button \r\n          className={styles.resetButton}\r\n          onClick={handleResetSettings}\r\n        >\r\n          기본값으로 초기화\r\n        </button>\r\n      </div>\r\n      \r\n      <div className={styles.statusBar}>\r\n        <div className={styles.statusItem}>\r\n          네이티브 모듈: {isNativeAvailable ? (\r\n            <span className={styles.statusAvailable}>사용 가능</span>\r\n          ) : (\r\n            <span className={styles.statusUnavailable}>사용 불가</span>\r\n          )}\r\n        </div>\r\n        <div className={styles.statusItem}>\r\n          설정 변경 시 즉시 적용됩니다\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default MemorySettingsPanel;\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\MemoryUsageMonitor.tsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'info' is defined but never used.","line":10,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":35},{"ruleId":"no-unused-vars","severity":2,"message":"'error' is assigned a value but never used.","line":23,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is assigned a value but never used.","line":23,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":41,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":41,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":52,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":52,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":55,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":55,"endColumn":20}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport { getMemoryInfo } from '../utils/nativeModuleClient';\r\nimport type { MemoryInfo } from '@/types';\r\n\r\ninterface MemoryUsageMonitorProps {\r\n  interval?: number;\r\n  showDetails?: boolean;\r\n  onMemoryInfo?: (info: MemoryInfo) => void;\r\n}\r\n\r\n/**\r\n * 메모리 사용량 모니터링 컴포넌트\r\n */\r\nexport function MemoryUsageMonitor({\r\n  interval = 30000,\r\n  showDetails = true,\r\n  onMemoryInfo\r\n}: MemoryUsageMonitorProps) {\r\n  const [memoryInfo, setMemoryInfo] = useState<MemoryInfo | null>(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n  \r\n  // 메모리 정보 가져오기 - useCallback으로 래핑하여 의존성 처리\r\n  const fetchMemoryInfoData = useCallback(async () => {\r\n    try {\r\n      setLoading(true);\r\n      const response = await getMemoryInfo();\r\n      \r\n      if (response.success && response.memoryInfo) {\r\n        setMemoryInfo(response.memoryInfo);\r\n        if (onMemoryInfo) {\r\n          onMemoryInfo(response.memoryInfo);\r\n        }\r\n        setError(null);\r\n      } else {\r\n        setError(response.error || 'Failed to fetch memory info');\r\n      }\r\n    } catch (err) {\r\n      console.error('Memory info fetch error:', err);\r\n      setError(err instanceof Error ? err.message : 'Unknown error');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [onMemoryInfo]);\r\n  \r\n  // 컴포넌트 마운트 시 및 주기적으로 메모리 정보 가져오기\r\n  useEffect(() => {\r\n    fetchMemoryInfoData();\r\n    \r\n    const timerHandle = setInterval(fetchMemoryInfoData, interval);\r\n    \r\n    return () => {\r\n      clearInterval(timerHandle);\r\n    };\r\n  }, [interval, fetchMemoryInfoData]); // fetchMemoryInfoData 추가\r\n  \r\n  // 메모리 정보가 없는 경우\r\n  if (loading && !memoryInfo) {\r\n    return <div className=\"memory-usage-monitor loading\">Loading memory info...</div>;\r\n  }\r\n  \r\n  // 메모리 정보 표시\r\n  return (\r\n    <div className=\"memory-usage-monitor\">\r\n      <div className=\"memory-usage-bar-container\">\r\n        <div \r\n          className=\"memory-usage-bar\" \r\n          style={{ \r\n            width: memoryInfo ? `${Math.min(100, memoryInfo.percentUsed)}%` : '0%',\r\n            backgroundColor: getStatusColor(memoryInfo?.percentUsed || 0)\r\n          }}\r\n        />\r\n        <div className=\"memory-usage-label\">\r\n          {memoryInfo ? `${memoryInfo.percentUsed.toFixed(1)}%` : 'N/A'}\r\n        </div>\r\n      </div>\r\n      \r\n      {showDetails && memoryInfo && (\r\n        <div className=\"memory-usage-details\">\r\n          <div className=\"memory-detail\">\r\n            <span>Heap Used:</span> \r\n            <span>{formatBytes(memoryInfo.heapUsed)}</span>\r\n          </div>\r\n          <div className=\"memory-detail\">\r\n            <span>Heap Total:</span> \r\n            <span>{formatBytes(memoryInfo.heapTotal)}</span>\r\n          </div>\r\n          <div className=\"memory-detail\">\r\n            <span>RSS:</span> \r\n            <span>{formatBytes(memoryInfo.rss)}</span>\r\n          </div>\r\n          <div className=\"memory-detail\">\r\n            <span>Last Update:</span>\r\n            <span>{new Date(memoryInfo.timestamp).toLocaleTimeString()}</span>\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\n// 메모리 사용량에 따른 색상 결정\r\nfunction getStatusColor(percentUsed: number): string {\r\n  if (percentUsed >= 90) return '#ff4d4f';  // 심각 (빨강)\r\n  if (percentUsed >= 75) return '#fa8c16';  // 경고 (주황)\r\n  if (percentUsed >= 60) return '#faad14';  // 주의 (노랑)\r\n  return '#52c41a';  // 정상 (초록)\r\n}\r\n\r\n// 바이트 단위 포맷팅\r\nfunction formatBytes(bytes: number): string {\r\n  if (bytes === 0) return '0 B';\r\n  \r\n  const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];\r\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\r\n  \r\n  return `${(bytes / Math.pow(1024, i)).toFixed(2)} ${sizes[i]}`;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\MiniView.tsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'useCallback' is defined but never used.","line":3,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useCallback' is defined but never used.","line":3,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":33,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":33,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":34,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":39,"column":42,"nodeType":"Identifier","messageId":"undef","endLine":39,"endColumn":48},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":40,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":46,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":46,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":47,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":47,"endColumn":15}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useState, useCallback, useEffect } from 'react';\r\nimport styles from './MiniView.module.css';\r\n\r\n// 미니뷰 통계 인터페이스 추가\r\ninterface MiniViewStats {\r\n  keyCount: number;\r\n  typingTime: number;\r\n  windowTitle?: string;\r\n  browserName?: string;\r\n  totalChars?: number;\r\n  totalWords?: number;\r\n  accuracy?: number;\r\n  isTracking?: boolean;\r\n}\r\n\r\nexport default function MiniView() {\r\n  const [isExpanded, setIsExpanded] = useState(false);\r\n  const [stats, setStats] = useState<MiniViewStats>({\r\n    keyCount: 0,\r\n    typingTime: 0,\r\n    windowTitle: '',\r\n    browserName: '',\r\n    totalChars: 0,\r\n    totalWords: 0,\r\n    accuracy: 100,\r\n    isTracking: false\r\n  });\r\n\r\n  // 초기화 시 webkitUserSelect를 none으로 설정\r\n  useEffect(() => {\r\n    document.documentElement.style.webkitUserSelect = 'none';\r\n    document.documentElement.style.userSelect = 'none';\r\n    \r\n    // 전자 API를 사용하여 통계 업데이트 수신\r\n    let unsubscribe: (() => void) | null = null;\r\n    \r\n    if (typeof window !== 'undefined' && window.electronAPI) {\r\n      unsubscribe = window.electronAPI.onMiniViewStatsUpdate((data: MiniViewStats) => {\r\n        setStats(data);\r\n      });\r\n    }\r\n    \r\n    return () => {\r\n      document.documentElement.style.webkitUserSelect = '';\r\n      document.documentElement.style.userSelect = '';\r\n      \r\n      if (unsubscribe) {\r\n        unsubscribe();\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  // 드래그만 가능하게, onClick 제거\r\n  // Collapsed state: Show only the app icon\r\n  if (!isExpanded) {\r\n    return (\r\n      <div\r\n        className={styles.miniViewCollapsed}\r\n        aria-label=\"타이핑 통계 드래그\"\r\n        style={{\r\n          WebkitAppRegion: 'drag',\r\n          cursor: 'move',\r\n          border: 'none',\r\n          outline: 'none',\r\n          boxShadow: 'none'\r\n        }}\r\n      >\r\n        <img\r\n          src=\"/app-icon.svg\"\r\n          alt=\"앱 아이콘\"\r\n          className={styles.appIcon}\r\n          style={{ \r\n            pointerEvents: 'none',\r\n            WebkitAppRegion: 'drag',\r\n            border: 'none',\r\n            outline: 'none'\r\n          }}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // Expanded state: Show the full mini-view with statistics\r\n  return (\r\n    <div className={styles.miniView}>\r\n      <div className={styles.appIconWrapper}>\r\n        <img\r\n          src=\"/app-icon.svg\"\r\n          alt=\"앱 아이콘\"\r\n          className={styles.appIcon}\r\n          onClick={() => setIsExpanded(false)}\r\n        />\r\n      </div>\r\n      <div className={styles.content}>\r\n        <div className={styles.statsContainer}>\r\n          <div className={styles.statItem}>\r\n            <span className={styles.statLabel}>타자 수</span>\r\n            <span className={styles.statValue}>{stats.keyCount.toLocaleString()}</span>\r\n          </div>\r\n          <div className={styles.statItem}>\r\n            <span className={styles.statLabel}>타이핑 시간</span>\r\n            <span className={styles.statValue}>{stats.typingTime}초</span>\r\n          </div>\r\n          <div className={styles.statItem}>\r\n            <span className={styles.statLabel}>평균 속도</span>\r\n            <span className={styles.statValue}>\r\n              {stats.typingTime > 0 ? Math.round((stats.keyCount / stats.typingTime) * 60) : 0} 타/분\r\n            </span>\r\n          </div>\r\n          {stats.accuracy && (\r\n            <div className={styles.statItem}>\r\n              <span className={styles.statLabel}>정확도</span>\r\n              <span className={styles.statValue}>{stats.accuracy}%</span>\r\n            </div>\r\n          )}\r\n        </div>\r\n        {stats.windowTitle && (\r\n          <div className={styles.currentWindow}>\r\n            {stats.windowTitle}\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\MiniViewIcon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\NativeModuleStatus.tsx","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":21,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":21,"endColumn":16}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { useState, useEffect } from 'react';\r\nimport { getNativeModuleStatus } from '../utils/nativeModuleClient';\r\nimport type { NativeModuleStatus } from '@/types/native-module';\r\nimport styles from './NativeModuleStatus.module.css';\r\n\r\nexport default function NativeModuleStatusComponent() {\r\n  const [status, setStatus] = useState<NativeModuleStatus | null>(null);\r\n  const [loading, setLoading] = useState<boolean>(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  useEffect(() => {\r\n    const fetchStatus = async () => {\r\n      try {\r\n        setLoading(true);\r\n        const moduleStatus = await getNativeModuleStatus();\r\n        setStatus(moduleStatus);\r\n        setError(null);\r\n      } catch (err) {\r\n        console.error('네이티브 모듈 상태 확인 오류:', err);\r\n        setError(err instanceof Error ? err.message : '알 수 없는 오류');\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    fetchStatus();\r\n  }, []);\r\n\r\n  if (loading) {\r\n    return <div className={styles.loader}>네이티브 모듈 상태 확인 중...</div>;\r\n  }\r\n\r\n  if (error) {\r\n    return <div className={styles.error}>오류: {error}</div>;\r\n  }\r\n\r\n  if (!status) {\r\n    return <div className={styles.unavailable}>네이티브 모듈 정보를 가져올 수 없습니다</div>;\r\n  }\r\n\r\n  return (\r\n    <div className={styles.container}>\r\n      <h3 className={styles.title}>네이티브 모듈 상태</h3>\r\n      \r\n      <div className={styles.statusItem}>\r\n        <span className={styles.label}>상태:</span>\r\n        <span className={`${styles.value} ${status.available ? styles.available : styles.unavailable}`}>\r\n          {status.available ? '사용 가능' : '사용 불가'}\r\n        </span>\r\n      </div>\r\n      \r\n      <div className={styles.statusItem}>\r\n        <span className={styles.label}>모드:</span>\r\n        <span className={`${styles.value} ${status.fallbackMode ? styles.fallback : styles.native}`}>\r\n          {status.fallbackMode ? 'JavaScript 폴백' : '네이티브 Rust'}\r\n        </span>\r\n      </div>\r\n      \r\n      <div className={styles.statusItem}>\r\n        <span className={styles.label}>버전:</span>\r\n        <span className={styles.value}>{status.version || '알 수 없음'}</span>\r\n      </div>\r\n      \r\n      {status.info && (\r\n        <>\r\n          <div className={styles.statusItem}>\r\n            <span className={styles.label}>설명:</span>\r\n            <span className={styles.value}>{status.info.description}</span>\r\n          </div>\r\n          \r\n          <div className={styles.features}>\r\n            <div className={styles.featuresTitle}>지원 기능:</div>\r\n            <ul className={styles.featuresList}>\r\n              <li className={status.info.features.memory_optimization ? styles.supported : styles.unsupported}>\r\n                메모리 최적화\r\n              </li>\r\n              <li className={status.info.features.gpu_acceleration ? styles.supported : styles.unsupported}>\r\n                GPU 가속\r\n              </li>\r\n              <li className={status.info.features.worker_threads ? styles.supported : styles.unsupported}>\r\n                워커 스레드\r\n              </li>\r\n            </ul>\r\n          </div>\r\n        </>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\NativeModuleTestPanel.tsx","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":35,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":35,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":51,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":51,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":67,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":67,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":83,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":83,"endColumn":14}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { useState, useEffect } from 'react';\r\nimport { \r\n  getMemoryInfo, \r\n  optimizeMemory, \r\n  forceGarbageCollection, \r\n  getGpuInfo \r\n} from '../utils/nativeModuleClient';\r\nimport styles from './NativeModuleTestPanel.module.css';\r\nimport NativeModuleStatus from './NativeModuleStatus';\r\n\r\nexport default function NativeModuleTestPanel() {\r\n  const [memoryInfo, setMemoryInfo] = useState<any>(null);\r\n  const [gpuInfo, setGpuInfo] = useState<any>(null);\r\n  const [optimizationResult, setOptimizationResult] = useState<any>(null);\r\n  const [gcResult, setGcResult] = useState<any>(null);\r\n  const [loading, setLoading] = useState<{ [key: string]: boolean }>({});\r\n  const [error, setError] = useState<string | null>(null);\r\n  \r\n  // 로딩 상태 설정 헬퍼 함수\r\n  const setLoadingState = (key: string, isLoading: boolean) => {\r\n    setLoading(prev => ({ ...prev, [key]: isLoading }));\r\n  };\r\n  \r\n  // 메모리 정보 가져오기\r\n  const fetchMemoryInfo = async () => {\r\n    try {\r\n      setLoadingState('memory', true);\r\n      setError(null);\r\n      \r\n      const response = await getMemoryInfo();\r\n      setMemoryInfo(response.memoryInfo);\r\n    } catch (err) {\r\n      console.error('메모리 정보 가져오기 오류:', err);\r\n      setError(err instanceof Error ? err.message : '메모리 정보를 가져오는 중 오류가 발생했습니다');\r\n    } finally {\r\n      setLoadingState('memory', false);\r\n    }\r\n  };\r\n  \r\n  // GPU 정보 가져오기\r\n  const fetchGpuInfo = async () => {\r\n    try {\r\n      setLoadingState('gpu', true);\r\n      setError(null);\r\n      \r\n      const response = await getGpuInfo();\r\n      setGpuInfo(response);\r\n    } catch (err) {\r\n      console.error('GPU 정보 가져오기 오류:', err);\r\n      setError(err instanceof Error ? err.message : 'GPU 정보를 가져오는 중 오류가 발생했습니다');\r\n    } finally {\r\n      setLoadingState('gpu', false);\r\n    }\r\n  };\r\n  \r\n  // 메모리 최적화 수행\r\n  const performMemoryOptimization = async (level: number = 2) => {\r\n    try {\r\n      setLoadingState('optimize', true);\r\n      setError(null);\r\n      \r\n      const response = await optimizeMemory(level, level === 4);\r\n      setOptimizationResult(response.result);\r\n    } catch (err) {\r\n      console.error('메모리 최적화 오류:', err);\r\n      setError(err instanceof Error ? err.message : '메모리 최적화 중 오류가 발생했습니다');\r\n    } finally {\r\n      setLoadingState('optimize', false);\r\n    }\r\n  };\r\n  \r\n  // 가비지 컬렉션 수행\r\n  const performGarbageCollection = async () => {\r\n    try {\r\n      setLoadingState('gc', true);\r\n      setError(null);\r\n      \r\n      const response = await forceGarbageCollection();\r\n      setGcResult(response.result);\r\n    } catch (err) {\r\n      console.error('가비지 컬렉션 오류:', err);\r\n      setError(err instanceof Error ? err.message : '가비지 컬렉션 중 오류가 발생했습니다');\r\n    } finally {\r\n      setLoadingState('gc', false);\r\n    }\r\n  };\r\n  \r\n  // 컴포넌트 마운트 시 초기 데이터 로드\r\n  useEffect(() => {\r\n    fetchMemoryInfo();\r\n    fetchGpuInfo();\r\n  }, []);\r\n  \r\n  return (\r\n    <div className={styles.container}>\r\n      <h2 className={styles.title}>네이티브 모듈 테스트 패널</h2>\r\n      \r\n      {/* 네이티브 모듈 상태 */}\r\n      <div className={styles.section}>\r\n        <h3 className={styles.sectionTitle}>네이티브 모듈 상태</h3>\r\n        <NativeModuleStatus />\r\n      </div>\r\n      \r\n      {/* 오류 표시 */}\r\n      {error && (\r\n        <div className={styles.error}>\r\n          <p>오류: {error}</p>\r\n        </div>\r\n      )}\r\n      \r\n      {/* 메모리 정보 */}\r\n      <div className={styles.section}>\r\n        <h3 className={styles.sectionTitle}>메모리 정보</h3>\r\n        <button \r\n          className={styles.button}\r\n          onClick={fetchMemoryInfo}\r\n          disabled={loading.memory}\r\n        >\r\n          {loading.memory ? '로딩 중...' : '메모리 정보 가져오기'}\r\n        </button>\r\n        \r\n        {memoryInfo && (\r\n          <div className={styles.infoContainer}>\r\n            <p>힙 사용량: {Math.round(memoryInfo.heap_used_mb * 10) / 10} MB</p>\r\n            <p>힙 총량: {Math.round((memoryInfo.heap_total / (1024 * 1024)) * 10) / 10} MB</p>\r\n            <p>사용률: {Math.round(memoryInfo.percent_used)}%</p>\r\n            <p>RSS: {Math.round(memoryInfo.rss_mb)} MB</p>\r\n            <p>타임스탬프: {new Date(memoryInfo.timestamp).toLocaleString()}</p>\r\n          </div>\r\n        )}\r\n      </div>\r\n      \r\n      {/* 메모리 최적화 */}\r\n      <div className={styles.section}>\r\n        <h3 className={styles.sectionTitle}>메모리 최적화</h3>\r\n        <div className={styles.buttonGroup}>\r\n          <button \r\n            className={`${styles.button} ${styles.levelLow}`}\r\n            onClick={() => performMemoryOptimization(1)}\r\n            disabled={loading.optimize}\r\n          >\r\n            가벼운 최적화\r\n          </button>\r\n          <button \r\n            className={`${styles.button} ${styles.levelMedium}`}\r\n            onClick={() => performMemoryOptimization(2)}\r\n            disabled={loading.optimize}\r\n          >\r\n            중간 최적화\r\n          </button>\r\n          <button \r\n            className={`${styles.button} ${styles.levelHigh}`}\r\n            onClick={() => performMemoryOptimization(3)}\r\n            disabled={loading.optimize}\r\n          >\r\n            높은 최적화\r\n          </button>\r\n          <button \r\n            className={`${styles.button} ${styles.levelCritical}`}\r\n            onClick={() => performMemoryOptimization(4)}\r\n            disabled={loading.optimize}\r\n          >\r\n            긴급 최적화\r\n          </button>\r\n        </div>\r\n        \r\n        {loading.optimize && <p className={styles.loading}>최적화 진행 중...</p>}\r\n        \r\n        {optimizationResult && (\r\n          <div className={styles.infoContainer}>\r\n            <p>최적화 레벨: {optimizationResult.optimization_level}</p>\r\n            <p>해제된 메모리: {optimizationResult.freed_mb} MB</p>\r\n            <p>소요 시간: {optimizationResult.duration} ms</p>\r\n            <p>성공 여부: {optimizationResult.success ? '성공' : '실패'}</p>\r\n            {optimizationResult.error && <p>오류: {optimizationResult.error}</p>}\r\n          </div>\r\n        )}\r\n      </div>\r\n      \r\n      {/* 가비지 컬렉션 */}\r\n      <div className={styles.section}>\r\n        <h3 className={styles.sectionTitle}>가비지 컬렉션</h3>\r\n        <button \r\n          className={styles.button}\r\n          onClick={performGarbageCollection}\r\n          disabled={loading.gc}\r\n        >\r\n          {loading.gc ? 'GC 수행 중...' : '가비지 컬렉션 수행'}\r\n        </button>\r\n        \r\n        {gcResult && (\r\n          <div className={styles.infoContainer}>\r\n            <p>해제된 메모리: {gcResult.freed_mb} MB</p>\r\n            <p>소요 시간: {gcResult.duration} ms</p>\r\n            <p>성공 여부: {gcResult.success ? '성공' : '실패'}</p>\r\n            {gcResult.error && <p>오류: {gcResult.error}</p>}\r\n          </div>\r\n        )}\r\n      </div>\r\n      \r\n      {/* GPU 정보 */}\r\n      <div className={styles.section}>\r\n        <h3 className={styles.sectionTitle}>GPU 정보</h3>\r\n        <button \r\n          className={styles.button}\r\n          onClick={fetchGpuInfo}\r\n          disabled={loading.gpu}\r\n        >\r\n          {loading.gpu ? '로딩 중...' : 'GPU 정보 가져오기'}\r\n        </button>\r\n        \r\n        {gpuInfo && (\r\n          <div className={styles.infoContainer}>\r\n            <p>가용성: {gpuInfo.available ? '사용 가능' : '사용 불가'}</p>\r\n            <p>이름: {gpuInfo.gpuInfo?.name || 'N/A'}</p>\r\n            <p>벤더: {gpuInfo.gpuInfo?.vendor || 'N/A'}</p>\r\n            <p>드라이버: {gpuInfo.gpuInfo?.driver_info || 'N/A'}</p>\r\n            <p>디바이스 타입: {gpuInfo.gpuInfo?.device_type || 'N/A'}</p>\r\n            <p>백엔드: {gpuInfo.gpuInfo?.backend || 'N/A'}</p>\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\RestartLoading.tsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'onClose' is defined but never used.","line":15,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'onClose' is defined but never used. Allowed unused args must match /^_/u.","line":15,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":25,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":25,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":33,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":33,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":41,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":41,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":42,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":42,"endColumn":20}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { useState, useEffect } from 'react';\r\nimport styles from './RestartLoading.module.css';\r\n\r\ninterface RestartLoadingProps {\r\n  message?: string;\r\n  isVisible: boolean;\r\n  onClose?: () => void;\r\n}\r\n\r\nexport default function RestartLoading({ \r\n  message = '앱을 재시작하는 중입니다...',\r\n  isVisible,\r\n  onClose\r\n}: RestartLoadingProps) {\r\n  const [dots, setDots] = useState('');\r\n  const [progress, setProgress] = useState(0);\r\n\r\n  // 로딩 애니메이션 효과\r\n  useEffect(() => {\r\n    if (!isVisible) return;\r\n    \r\n    // 진행 점 애니메이션\r\n    const dotsInterval = setInterval(() => {\r\n      setDots(prev => {\r\n        if (prev.length >= 3) return '';\r\n        return prev + '.';\r\n      });\r\n    }, 500);\r\n    \r\n    // 진행 표시줄 애니메이션\r\n    const progressInterval = setInterval(() => {\r\n      setProgress(prev => {\r\n        if (prev >= 100) return 100;\r\n        return prev + 5;\r\n      });\r\n    }, 100);\r\n    \r\n    return () => {\r\n      clearInterval(dotsInterval);\r\n      clearInterval(progressInterval);\r\n    };\r\n  }, [isVisible]);\r\n\r\n  if (!isVisible) return null;\r\n\r\n  return (\r\n    <div className={styles.overlay}>\r\n      <div className={styles.loadingContainer}>\r\n        <div className={styles.spinner}></div>\r\n        <h3 className={styles.title}>{message}{dots}</h3>\r\n        \r\n        <div className={styles.progressContainer}>\r\n          <div \r\n            className={styles.progressBar}\r\n            style={{ width: `${progress}%` }}\r\n          ></div>\r\n        </div>\r\n        \r\n        <p className={styles.note}>앱이 곧 다시 시작됩니다.</p>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\RestartPrompt.tsx","messages":[{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":19,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":19,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":20,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":20,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":20,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":20,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[544,585],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":21,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":21,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":27,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":27,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":28,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":28,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":28,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":28,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[853,895],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":29,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":34,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":36,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":36,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":45,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":45,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":45,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":45,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1284,1306],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":48,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":48,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":51,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":51,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":52,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":52,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":52,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":52,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1464,1504],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":53,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":53,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":58,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":58,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":59,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":59,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":59,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":59,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1710,1751],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":60,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":60,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":64,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":64,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":66,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":73,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":73,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":73,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":73,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2054,2077],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":76,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":76,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":77,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":77,"endColumn":16},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":77,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":77,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2170,2211],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":78,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":78,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":83,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":83,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":84,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":84,"endColumn":16},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":84,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":84,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2406,2448],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":85,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":85,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":89,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":89,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":91,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":91,"endColumn":14}],"suppressedMessages":[],"errorCount":27,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useState, useEffect, useCallback } from 'react';\r\nimport styles from './RestartPrompt.module.css';\r\n\r\n/**\r\n * 앱 재시작 안내 컴포넌트\r\n * 기존 restart.html을 React 컴포넌트로 마이그레이션\r\n */\r\nexport default function RestartPrompt() {\r\n  const [isDarkMode, setIsDarkMode] = useState(false);\r\n  const [isRestarting, setIsRestarting] = useState(false);\r\n  \r\n  // 다크 모드 설정 확인 및 적용\r\n  useEffect(() => {\r\n    async function applyTheme() {\r\n      try {\r\n        // 1. restartAPI 시도\r\n        if (window.restartAPI?.getDarkMode) {\r\n          console.log('restartAPI.getDarkMode 사용');\r\n          const darkMode = await window.restartAPI.getDarkMode();\r\n          setIsDarkMode(darkMode);\r\n          return;\r\n        }\r\n        \r\n        // 2. electronAPI 시도 (ElectronAPI 타입에 getDarkMode가 추가됨)\r\n        if (window.electronAPI?.getDarkMode) {\r\n          console.log('electronAPI.getDarkMode 사용');\r\n          const darkMode = await window.electronAPI.getDarkMode();\r\n          setIsDarkMode(darkMode);\r\n          return;\r\n        }\r\n        \r\n        console.warn('다크 모드 정보를 가져올 수 없습니다. 기본값 사용');\r\n      } catch (error) {\r\n        console.error('테마 적용 중 오류:', error);\r\n      }\r\n    }\r\n    \r\n    applyTheme();\r\n  }, []);\r\n  \r\n  // 앱 재시작 함수\r\n  const restartApp = useCallback(() => {\r\n    console.log('재시작 시도');\r\n    setIsRestarting(true);\r\n    \r\n    setTimeout(() => {\r\n      try {\r\n        // 1. restartAPI 시도\r\n        if (window.restartAPI?.restartApp) {\r\n          console.log('restartAPI.restartApp 사용');\r\n          window.restartAPI.restartApp();\r\n          return;\r\n        }\r\n        \r\n        // 2. electronAPI 시도 (ElectronAPI 타입에 restartApp이 추가됨)\r\n        if (window.electronAPI?.restartApp) {\r\n          console.log('electronAPI.restartApp 사용');\r\n          window.electronAPI.restartApp();\r\n          return;\r\n        }\r\n        \r\n        console.error('재시작 API를 찾을 수 없습니다');\r\n      } catch (error) {\r\n        console.error('재시작 실행 중 오류:', error);\r\n      }\r\n    }, 500);\r\n  }, []);\r\n  \r\n  // 창 닫기 함수\r\n  const closeWindow = useCallback(() => {\r\n    console.log('창 닫기 시도');\r\n    try {\r\n      // 1. restartAPI 시도\r\n      if (window.restartAPI?.closeWindow) {\r\n        console.log('restartAPI.closeWindow 사용');\r\n        window.restartAPI.closeWindow();\r\n        return;\r\n      }\r\n      \r\n      // 2. electronAPI 시도 (ElectronAPI 타입에 closeWindow가 추가됨)\r\n      if (window.electronAPI?.closeWindow) {\r\n        console.log('electronAPI.closeWindow 사용');\r\n        window.electronAPI.closeWindow();\r\n        return;\r\n      }\r\n      \r\n      console.error('창 닫기 API를 찾을 수 없습니다');\r\n    } catch (error) {\r\n      console.error('창 닫기 중 오류:', error);\r\n    }\r\n  }, []);\r\n\r\n  // UI 부분은 변경 없음\r\n  return (\r\n    <div className={`${styles.container} ${isDarkMode ? styles.darkMode : ''}`}>\r\n      <div className={styles.header}>\r\n        <h1>앱 재시작</h1>\r\n        <button className={styles.closeButton} onClick={closeWindow} disabled={isRestarting}>×</button>\r\n      </div>\r\n      \r\n      <div className={styles.content}>\r\n        {isRestarting ? (\r\n          <>\r\n            <div className={styles.loadingIcon}>🔄</div>\r\n            <p className={styles.message}>\r\n              재시작 중입니다...<br />\r\n              잠시만 기다려주세요.\r\n            </p>\r\n          </>\r\n        ) : (\r\n          <>\r\n            <div className={styles.icon}>🔄</div>\r\n            <p className={styles.message}>\r\n              GPU 가속 설정이 변경되었습니다.<br />\r\n              변경된 설정을 적용하려면 앱을 재시작해야 합니다.\r\n            </p>\r\n            <div className={styles.buttons}>\r\n              <button \r\n                className={`${styles.button} ${styles.primary}`}\r\n                onClick={restartApp}\r\n                disabled={isRestarting}\r\n              >\r\n                지금 재시작\r\n              </button>\r\n              <button \r\n                className={`${styles.button} ${styles.secondary}`}\r\n                onClick={closeWindow}\r\n                disabled={isRestarting}\r\n              >\r\n                나중에 하기\r\n              </button>\r\n            </div>\r\n          </>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\SelfLearningSystem.tsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'LogType' is defined but never used.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'LogType' is defined but never used.","line":5,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":17},{"ruleId":"no-unused-vars","severity":2,"message":"'results' is defined but never used.","line":23,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":37},{"ruleId":"no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":24,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":42,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":42,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":96,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":96,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":123,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":123,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":123,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":123,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3177,3218],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":139,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":139,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":163,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":163,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":177,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":177,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":197,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":197,"endColumn":16},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":197,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":197,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5334,5368],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":205,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":205,"endColumn":16},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":205,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":205,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5574,5609],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":213,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":213,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":218,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":218,"endColumn":22}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { useEffect, useRef, useState } from 'react';\r\nimport { LearningModelType } from '../utils/log-learning';\r\nimport { LogType, saveSystemLog } from '../utils/log-utils';\r\n\r\n/**\r\n * 자동 학습 옵션 인터페이스\r\n */\r\ninterface AutoLearningOptions {\r\n  enableAutoLearning: boolean;          // 자동 학습 활성화 여부\r\n  learningIntervalHours: number;        // 학습 실행 간격 (시간)\r\n  runOnLowActivity: boolean;            // 낮은 활동 시에만 실행 여부\r\n  modelsToLearn: LearningModelType[];   // 학습할 모델 유형\r\n  maxLogAgeDays: number;                // 학습에 사용할 최대 로그 기간 (일)\r\n}\r\n\r\n/**\r\n * 자동 학습 시스템 컴포넌트 Props\r\n */\r\ninterface SelfLearningSystemProps {\r\n  options?: Partial<AutoLearningOptions>;\r\n  onLearningComplete?: (results: any) => void;\r\n  onLearningError?: (error: Error) => void;\r\n}\r\n\r\n/**\r\n * 자동 학습 시스템 컴포넌트\r\n * \r\n * 백그라운드에서 정기적으로 로그 데이터에서 학습을 실행합니다.\r\n */\r\nexport default function SelfLearningSystem({\r\n  options,\r\n  onLearningComplete,\r\n  onLearningError\r\n}: SelfLearningSystemProps) {\r\n  // 마지막 학습 시간을 추적하는 ref (렌더링을 트리거하지 않기 위해 ref 사용)\r\n  const lastLearningRef = useRef<number | null>(null);\r\n  // 학습 실행 중인지 여부\r\n  const [isLearning, setIsLearning] = useState<boolean>(false);\r\n  // 학습 예약 타이머 ID\r\n  const timerRef = useRef<NodeJS.Timeout | null>(null);\r\n\r\n  // 기본 옵션과 사용자 옵션을 병합\r\n  const defaultOptions: AutoLearningOptions = {\r\n    enableAutoLearning: true,\r\n    learningIntervalHours: 24, // 기본 24시간마다\r\n    runOnLowActivity: true,\r\n    modelsToLearn: [\r\n      LearningModelType.MEMORY_OPTIMIZATION,\r\n      LearningModelType.USER_BEHAVIOR,\r\n      LearningModelType.ERROR_PREDICTION\r\n    ],\r\n    maxLogAgeDays: 30\r\n  };\r\n\r\n  const learningOptions: AutoLearningOptions = {\r\n    ...defaultOptions,\r\n    ...(options || {})\r\n  };\r\n\r\n  /**\r\n   * 현재 사용자 활동이 낮은지 확인\r\n   * (예: 야간 시간, 키보드/마우스 활동 없음)\r\n   */\r\n  const isLowActivityPeriod = (): boolean => {\r\n    // 현재 시간을 확인 (로컬 시간)\r\n    const now = new Date();\r\n    const hour = now.getHours();\r\n\r\n    // 밤 10시 ~ 아침 7시 사이면 낮은 활동 시간으로 간주\r\n    if (hour >= 22 || hour <= 7) {\r\n      return true;\r\n    }\r\n\r\n    // 추가 활동 감지 로직은 여기에 구현\r\n    // 예: 마지막 키보드/마우스 활동 시간, CPU 사용량 등\r\n\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * 학습 간격 시간이 지났는지 확인\r\n   */\r\n  const shouldRunLearning = (): boolean => {\r\n    // 자동 학습이 비활성화되어 있으면 실행하지 않음\r\n    if (!learningOptions.enableAutoLearning) {\r\n      return false;\r\n    }\r\n\r\n    const now = Date.now();\r\n\r\n    // 마지막 학습 시간이 없거나 간격 시간이 지났는지 확인\r\n    if (lastLearningRef.current === null) {\r\n      // 로컬 스토리지에서 마지막 학습 시간 불러오기\r\n      const lastLearningTime = localStorage.getItem('lastAutoLearningTime');\r\n\r\n      if (!lastLearningTime) {\r\n        return true; // 마지막 학습 기록이 없으면 실행\r\n      }\r\n\r\n      lastLearningRef.current = Number(lastLearningTime);\r\n    }\r\n\r\n    // 학습 간격 시간을 밀리초로 변환\r\n    const intervalMs = learningOptions.learningIntervalHours * 60 * 60 * 1000;\r\n\r\n    // 마지막 학습 후 간격이 지났는지 확인\r\n    return (now - lastLearningRef.current) >= intervalMs;\r\n  };\r\n\r\n  /**\r\n   * 자동 학습 실행\r\n   */\r\n  const runAutoLearning = async () => {\r\n    // 이미 학습 중이면 중복 실행 방지\r\n    if (isLearning) {\r\n      return;\r\n    }\r\n\r\n    // 낮은 활동 시에만 실행 옵션이 켜져 있고, 현재 활동이 높으면 건너뜀\r\n    if (learningOptions.runOnLowActivity && !isLowActivityPeriod()) {\r\n      console.log('활동이 높은 시간대라 자동 학습을 연기합니다.');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setIsLearning(true);\r\n\r\n      await saveSystemLog('자동 학습 시작', {\r\n        modelsToLearn: learningOptions.modelsToLearn,\r\n        maxLogAgeDays: learningOptions.maxLogAgeDays\r\n      });\r\n\r\n      const startTime = Date.now() - (learningOptions.maxLogAgeDays * 24 * 60 * 60 * 1000);\r\n      const endTime = Date.now();\r\n\r\n      // 학습 API 호출\r\n      const response = await fetch('/api/logs/learn', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json'\r\n        },\r\n        body: JSON.stringify({\r\n          modelTypes: learningOptions.modelsToLearn,\r\n          options: {\r\n            memory: { timeRange: { startTime, endTime } },\r\n            user: { timeRange: { startTime, endTime } },\r\n            error: { timeRange: { startTime, endTime } }\r\n          }\r\n        })\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`API 요청 실패: ${response.status} ${response.statusText}`);\r\n      }\r\n\r\n      const result = await response.json();\r\n\r\n      if (result.success) {\r\n        // 마지막 학습 시간 업데이트\r\n        lastLearningRef.current = Date.now();\r\n        localStorage.setItem('lastAutoLearningTime', lastLearningRef.current.toString());\r\n\r\n        // 로그 저장\r\n        await saveSystemLog('자동 학습 완료', {\r\n          resultsCount: result.results?.length || 0,\r\n          timestamp: Date.now()\r\n        });\r\n\r\n        // 콜백 호출\r\n        onLearningComplete?.(result);\r\n      } else {\r\n        throw new Error(result.error || '학습 중 오류가 발생했습니다.');\r\n      }\r\n    } catch (error) {\r\n      console.error('자동 학습 중 오류:', error);\r\n\r\n      // 오류 로그 저장\r\n      await saveSystemLog('자동 학습 오류', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n        timestamp: Date.now()\r\n      });\r\n\r\n      // 오류 콜백 호출\r\n      onLearningError?.(error instanceof Error ? error : new Error(String(error)));\r\n    } finally {\r\n      setIsLearning(false);\r\n    }\r\n  };\r\n\r\n  // 컴포넌트 마운트 시 자동 학습 체크 및 설정\r\n  useEffect(() => {\r\n    // 정기적으로 학습 체크 및 실행 (10분마다)\r\n    const checkAndRunLearning = async () => {\r\n      if (shouldRunLearning()) {\r\n        console.log('자동 학습 조건 충족, 학습 실행');\r\n        await runAutoLearning();\r\n      }\r\n    };\r\n\r\n    // 컴포넌트 마운트 시 즉시 확인 (하지만 바로 실행은 하지 않음)\r\n    const initialCheck = async () => {\r\n      if (shouldRunLearning() && isLowActivityPeriod()) {\r\n        console.log('초기 조건 확인 - 자동 학습 실행');\r\n        await runAutoLearning();\r\n      }\r\n    };\r\n\r\n    initialCheck();\r\n\r\n    // 10분마다 체크\r\n    timerRef.current = setInterval(checkAndRunLearning, 10 * 60 * 1000);\r\n\r\n    // 컴포넌트 언마운트 시 타이머 정리\r\n    return () => {\r\n      if (timerRef.current) {\r\n        clearInterval(timerRef.current);\r\n      }\r\n    };\r\n  }, [learningOptions.enableAutoLearning, learningOptions.learningIntervalHours]);\r\n\r\n  // 이 컴포넌트는 UI를 렌더링하지 않음\r\n  return null;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\Settings.tsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'settings' is defined but never used.","line":35,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":35},{"ruleId":"no-unused-vars","severity":2,"message":"'enabled' is defined but never used.","line":38,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":38,"endColumn":38},{"ruleId":"no-unused-vars","severity":2,"message":"'mode' is defined but never used.","line":39,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":39,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":99,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":99,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":101,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":101,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'React' is not defined.","line":179,"column":48,"nodeType":"Identifier","messageId":"undef","endLine":179,"endColumn":53},{"ruleId":"no-undef","severity":2,"message":"'HTMLInputElement' is not defined.","line":179,"column":66,"nodeType":"Identifier","messageId":"undef","endLine":179,"endColumn":82},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":210,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":210,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":211,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":211,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":212,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":212,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":215,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":215,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":216,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":216,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":217,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":217,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":219,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":219,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":238,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":238,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":244,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":244,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":245,"column":40,"nodeType":"Identifier","messageId":"undef","endLine":245,"endColumn":46},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":248,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":248,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":248,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":248,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7121,7160],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":252,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":252,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":253,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":253,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":258,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":258,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":259,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":259,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":264,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":264,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":264,"column":37,"nodeType":"Identifier","messageId":"undef","endLine":264,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":265,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":265,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":274,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":274,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":284,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":284,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":285,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":285,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":287,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":287,"endColumn":38}],"suppressedMessages":[],"errorCount":29,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback } from 'react';\r\nimport styles from './Settings.module.css';\r\nimport { useToast } from './ToastContext';\r\nimport SaveConfirmDialog from './dialogs/SaveConfirmDialog';\r\n\r\ninterface EnabledCategories {\r\n  docs: boolean;\r\n  office: boolean;\r\n  coding: boolean;\r\n  sns: boolean;\r\n}\r\n\r\ntype WindowModeType = 'windowed' | 'fullscreen' | 'fullscreen-auto-hide';\r\n\r\nexport interface SettingsState {\r\n  enabledCategories: EnabledCategories;\r\n  autoStartMonitoring: boolean;\r\n  darkMode: boolean;\r\n  windowMode: WindowModeType;\r\n  // 트레이 관련 설정 추가\r\n  minimizeToTray: boolean;\r\n  showTrayNotifications: boolean;\r\n  reduceMemoryInBackground: boolean;\r\n  // 미니뷰 설정 추가\r\n  enableMiniView: boolean;\r\n  // GPU 가속 관련 설정 추가\r\n  useHardwareAcceleration: boolean;\r\n  processingMode: 'auto' | 'normal' | 'cpu-intensive' | 'gpu-intensive';\r\n  maxMemoryThreshold: number;\r\n  // 유휴 상태 관련 설정 추가\r\n  resumeAfterIdle: boolean;\r\n}\r\n\r\ninterface SettingsProps {\r\n  onSave: (settings: SettingsState) => void;\r\n  initialSettings: SettingsState;\r\n  darkMode: boolean;\r\n  onDarkModeChange: (enabled: boolean) => void;\r\n  onWindowModeChange: (mode: WindowModeType) => void;\r\n}\r\n\r\nexport function Settings({ \r\n  onSave, \r\n  initialSettings, \r\n  darkMode, \r\n  onDarkModeChange, \r\n  onWindowModeChange \r\n}: SettingsProps) {\r\n  const [settings, setSettings] = useState<SettingsState>({\r\n    enabledCategories: {\r\n      docs: true,\r\n      office: true,\r\n      coding: true,\r\n      sns: true\r\n    },\r\n    autoStartMonitoring: true,\r\n    darkMode: false,\r\n    windowMode: 'windowed',\r\n    minimizeToTray: true,\r\n    showTrayNotifications: true,\r\n    reduceMemoryInBackground: true,\r\n    enableMiniView: true, // 미니뷰 기본값 true\r\n    // 수정: 타입 오류 해결을 위해 옵셔널 체이닝과 nullish 병합 연산자 수정\r\n    useHardwareAcceleration: initialSettings && 'useHardwareAcceleration' in initialSettings \r\n      ? initialSettings.useHardwareAcceleration \r\n      : false,\r\n    processingMode: initialSettings && 'processingMode' in initialSettings \r\n      ? initialSettings.processingMode \r\n      : 'auto',\r\n    maxMemoryThreshold: initialSettings && 'maxMemoryThreshold' in initialSettings \r\n      ? initialSettings.maxMemoryThreshold \r\n      : 100,\r\n    // resumeAfterIdle 속성 추가\r\n    resumeAfterIdle: initialSettings && 'resumeAfterIdle' in initialSettings\r\n      ? initialSettings.resumeAfterIdle\r\n      : true\r\n  });\r\n  const [needsRestart, setNeedsRestart] = useState(false);\r\n  const [showSaveConfirm, setShowSaveConfirm] = useState(false);\r\n  const { showToast } = useToast();\r\n\r\n  // 재시작 API 디버깅 상태 추가\r\n  const [apiDebugInfo, setApiDebugInfo] = useState<string>('');\r\n  const [showDebugInfo, setShowDebugInfo] = useState<boolean>(false);\r\n\r\n  // 초기 설정 변경 시 state 업데이트\r\n  useEffect(() => {\r\n    if (initialSettings) {\r\n      setSettings(initialSettings);\r\n    }\r\n  }, [initialSettings]);\r\n\r\n  // 다크 모드 처리를 위한 효과 추가\r\n  useEffect(() => {\r\n    // 다크 모드 클래스가 서버 렌더링과 클라이언트 간에 일치하도록 함\r\n    if (typeof window !== 'undefined') {\r\n      const isDarkMode = settings.darkMode;\r\n      if (isDarkMode) {\r\n        document.documentElement.classList.add('dark-mode');\r\n      } else {\r\n        document.documentElement.classList.remove('dark-mode');\r\n      }\r\n    }\r\n  }, [settings.darkMode]);\r\n\r\n  // Handler functions\r\n  const handleCategoryToggle = (category: keyof typeof settings.enabledCategories) => {\r\n    setSettings(prev => ({\r\n      ...prev,\r\n      enabledCategories: {\r\n        ...prev.enabledCategories,\r\n        [category]: !prev.enabledCategories[category]\r\n      }\r\n    }));\r\n  };\r\n\r\n  const handleAutoStartToggle = () => {\r\n    setSettings(prev => ({\r\n      ...prev, \r\n      autoStartMonitoring: !prev.autoStartMonitoring\r\n    }));\r\n  };\r\n\r\n  const handleDarkModeToggle = () => {\r\n    const newDarkMode = !settings.darkMode;\r\n    setSettings(prev => ({\r\n      ...prev,\r\n      darkMode: newDarkMode\r\n    }));\r\n    onDarkModeChange(newDarkMode);\r\n  };\r\n\r\n  const handleWindowModeChange = (mode: WindowModeType) => {\r\n    setSettings(prev => ({\r\n      ...prev,\r\n      windowMode: mode\r\n    }));\r\n    onWindowModeChange(mode);\r\n  };\r\n\r\n  // 트레이 관련 핸들러 추가\r\n  const handleMinimizeToTrayToggle = () => {\r\n    setSettings(prev => ({\r\n      ...prev,\r\n      minimizeToTray: !prev.minimizeToTray\r\n    }));\r\n  };\r\n  \r\n  const handleShowTrayNotificationsToggle = () => {\r\n    setSettings(prev => ({\r\n      ...prev,\r\n      showTrayNotifications: !prev.showTrayNotifications\r\n    }));\r\n  };\r\n  \r\n  const handleReduceMemoryToggle = () => {\r\n    setSettings(prev => ({\r\n      ...prev,\r\n      reduceMemoryInBackground: !prev.reduceMemoryInBackground\r\n    }));\r\n  };\r\n\r\n  // 미니뷰 토글 핸들러 추가\r\n  const handleMiniViewToggle = () => {\r\n    setSettings(prev => ({\r\n      ...prev,\r\n      enableMiniView: !prev.enableMiniView\r\n    }));\r\n  };\r\n\r\n  const handleSettingChange = (key: keyof SettingsState, value: any) => {\r\n    setSettings(prev => ({\r\n      ...prev,\r\n      [key]: value\r\n    }));\r\n  };\r\n\r\n  // GPU 가속 설정 변경 감지 함수 추가\r\n  const handleHardwareAccelerationToggle = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const newValue = e.target.checked;\r\n    // 이전 값과 다른 경우에만 재시작 필요 플래그 설정\r\n    if (newValue !== initialSettings.useHardwareAcceleration) {\r\n      setNeedsRestart(true);\r\n    }\r\n    handleSettingChange('useHardwareAcceleration', newValue);\r\n  };\r\n\r\n  const handleSaveSettings = () => {\r\n    // 변경 사항이 있을 때만 저장 확인 대화상자 표시\r\n    const hasChanges = JSON.stringify(settings) !== JSON.stringify(initialSettings);\r\n    \r\n    if (hasChanges) {\r\n      setShowSaveConfirm(true);\r\n    } else {\r\n      showToast('변경된 설정이 없습니다.', 'info');\r\n    }\r\n  };\r\n  \r\n  const confirmSaveSettings = () => {\r\n    setShowSaveConfirm(false);\r\n    \r\n    // 설정 저장 실행\r\n    onSave(settings);\r\n    \r\n    if (needsRestart) {\r\n      // 재시작이 필요한 경우 특별 메시지 표시\r\n      showToast('GPU 가속 설정이 변경되었습니다. 변경 사항을 적용하려면 앱을 재시작하세요.', 'info');\r\n      \r\n      // 재시작 확인 대화상자 표시\r\n      if (window.electronAPI) {\r\n        if (typeof window.electronAPI.showRestartPrompt === 'function') {\r\n          window.electronAPI.showRestartPrompt();\r\n        } else {\r\n          // 대체 방법: 재시작 여부 확인 후 재시작 요청\r\n          if (window.confirm('GPU 가속 설정이 변경되었습니다. 지금 앱을 재시작하시겠습니까?')) {\r\n            if (typeof window.electronAPI.restartApp === 'function') {\r\n              window.electronAPI.restartApp();\r\n            } else {\r\n              console.error('restartApp 함수를 찾을 수 없습니다.');\r\n              showToast('앱을 수동으로 재시작해 주세요.', 'warning');\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      showToast('설정이 저장되었습니다.', 'success');\r\n    }\r\n  };\r\n  \r\n  const cancelSaveSettings = () => {\r\n    setShowSaveConfirm(false);\r\n  };\r\n\r\n  // 재시작 버튼 클릭 핸들러 수정 - 실무적인 방식으로 개선\r\n  const handleRestartClick = useCallback(() => {\r\n    try {\r\n      // API 객체가 정의되어 있는지 먼저 확인\r\n      if (!window.electronAPI) {\r\n        showToast('Electron API를 찾을 수 없습니다. preload 스크립트가 올바르게 로드되었는지 확인하세요.', 'error');\r\n        return;\r\n      }\r\n\r\n      // API 정보 수집 (디버깅용)\r\n      const apiInfo = Object.keys(window.electronAPI)\r\n        .map(key => `${key}: ${typeof (window.electronAPI as any)[key]}`)\r\n        .join('\\n');\r\n      \r\n      console.log('사용 가능한 API 목록:', apiInfo);\r\n      setApiDebugInfo(apiInfo);\r\n      \r\n      // 앱 재시작 요청 전송 시도\r\n      if (typeof window.electronAPI.restartApp === 'function') {\r\n        window.electronAPI.restartApp();\r\n        return;\r\n      } \r\n      \r\n      // 첫 번째 방식이 실패한 경우 재시작 안내 창 사용 시도\r\n      if (typeof window.electronAPI.showRestartPrompt === 'function') {\r\n        window.electronAPI.showRestartPrompt();\r\n        return;\r\n      }\r\n      \r\n      // 두 방법 모두 실패했을 경우 일반 IPC 직접 호출 시도\r\n      if (window.electron && typeof window.electron.restartApp === 'function') {\r\n        window.electron.restartApp();\r\n        return;\r\n      }\r\n      \r\n      // 모든 방법이 실패한 경우 오류 메시지 표시\r\n      showToast('재시작 기능을 사용할 수 없습니다. 앱을 수동으로 재시작하세요.', 'warning');\r\n      setShowDebugInfo(true);\r\n      \r\n    } catch (error) {\r\n      console.error('앱 재시작 시도 중 오류:', error);\r\n      showToast(`재시작 중 오류: ${(error as Error).message}`, 'error');\r\n      setApiDebugInfo(String(error));\r\n      setShowDebugInfo(true);\r\n    }\r\n  }, [showToast]);\r\n\r\n  // API 디버그 정보 표시 함수 추가\r\n  const toggleDebugInfo = () => {\r\n    // API 정보 새로고침\r\n    if (window.electronAPI) {\r\n      const apiInfo = Object.keys(window.electronAPI)\r\n        .map(key => {\r\n          const type = typeof (window.electronAPI as any)[key];\r\n          return `${key}: ${type}`;\r\n        })\r\n        .join('\\n');\r\n        \r\n      setApiDebugInfo(apiInfo);\r\n    } else {\r\n      setApiDebugInfo('electronAPI가 정의되지 않았습니다');\r\n    }\r\n    \r\n    setShowDebugInfo(!showDebugInfo);\r\n  };\r\n\r\n  return (\r\n    <div className={`${styles.settingsContainer} ${darkMode ? styles.darkMode : ''}`}>\r\n      <h2>설정</h2>\r\n      \r\n      {/* 자동 모니터링 설정 섹션 (새로 추가) */}\r\n      <div className={`${styles.settingSection} ${styles.highlightedSetting}`}>\r\n        <h3>모니터링 자동 시작</h3>\r\n        <div className={styles.toggleItem}>\r\n          <label>\r\n            <input \r\n              type=\"checkbox\" \r\n              checked={settings.autoStartMonitoring} \r\n              onChange={handleAutoStartToggle}\r\n            />\r\n            <span className={styles.toggleLabel}>앱 시작 시 자동으로 모니터링 시작</span>\r\n          </label>\r\n        </div>\r\n        \r\n        <div className={styles.toggleItem}>\r\n          <label>\r\n            <input \r\n              type=\"checkbox\" \r\n              checked={settings.resumeAfterIdle || false} \r\n              onChange={(e) => handleSettingChange('resumeAfterIdle', e.target.checked)}\r\n            />\r\n            <span className={styles.toggleLabel}>일정 시간 사용하지 않다가 돌아왔을 때 자동 재시작</span>\r\n          </label>\r\n        </div>\r\n        \r\n        <div className={styles.settingDescription}>\r\n          자동 모니터링 설정을 통해 앱 시작 시 또는 일정 시간 사용하지 않다가 돌아왔을 때 \r\n          자동으로 타이핑 모니터링을 시작할 수 있습니다.\r\n        </div>\r\n      </div>\r\n      \r\n      <div className={`${styles.settingSection}`}>\r\n        <h3>일반 설정</h3>\r\n        <div className={styles.toggleItem}>\r\n          <label>\r\n            <input \r\n              type=\"checkbox\" \r\n              checked={settings.darkMode} \r\n              onChange={handleDarkModeToggle}\r\n            />\r\n            <span className={styles.toggleLabel}>다크 모드</span>\r\n          </label>\r\n        </div>\r\n      </div>\r\n\r\n      <div className={styles.settingSection}>\r\n        <h3>화면 모드</h3>\r\n        <div className={styles.radioGroup}>\r\n          <label className={styles.radioLabel}>\r\n            <input \r\n              type=\"radio\" \r\n              name=\"windowMode\" \r\n              checked={settings.windowMode === 'windowed'} \r\n              onChange={() => handleWindowModeChange('windowed')}\r\n            />\r\n            <span className={styles.radioText}>창 모드</span>\r\n          </label>\r\n          \r\n          <label className={styles.radioLabel}>\r\n            <input \r\n              type=\"radio\" \r\n              name=\"windowMode\" \r\n              checked={settings.windowMode === 'fullscreen'} \r\n              onChange={() => handleWindowModeChange('fullscreen')}\r\n            />\r\n            <span className={styles.radioText}>전체화면 모드</span>\r\n          </label>\r\n\r\n          <label className={styles.radioLabel}>\r\n            <input\r\n              type=\"radio\"\r\n              name=\"windowMode\"\r\n              value=\"fullscreen-auto-hide\"\r\n              checked={settings.windowMode === 'fullscreen-auto-hide'}\r\n              onChange={() => handleWindowModeChange('fullscreen-auto-hide')}\r\n            />\r\n            <span className={styles.radioText}>자동 숨김 모드</span>\r\n          </label>\r\n        </div>\r\n        \r\n        <p className={styles.settingDescription}>\r\n          자동 숨김 모드에서는 마우스를 화면 상단에 가져가면 도구모음이 자동으로 표시됩니다.\r\n        </p>\r\n      </div>\r\n      \r\n      <div className={styles.settingSection}>\r\n        <h3>모니터링 대상 카테고리</h3>\r\n        <div className={styles.categoryToggles}>\r\n          <div className={styles.toggleItem}>\r\n            <label>\r\n              <input \r\n                type=\"checkbox\" \r\n                checked={settings.enabledCategories.docs} \r\n                onChange={() => handleCategoryToggle('docs')}\r\n              />\r\n              <span className={styles.toggleLabel}>문서 작업 (Notion, Google Docs 등)</span>\r\n            </label>\r\n          </div>\r\n\r\n          <div className={styles.toggleItem}>\r\n            <label>\r\n              <input \r\n                type=\"checkbox\" \r\n                checked={settings.enabledCategories.office} \r\n                onChange={() => handleCategoryToggle('office')}\r\n              />\r\n              <span className={styles.toggleLabel}>오피스 웹앱 (Microsoft Office, 한컴오피스 등)</span>\r\n            </label>\r\n          </div>\r\n\r\n          <div className={styles.toggleItem}>\r\n            <label>\r\n              <input \r\n                type=\"checkbox\" \r\n                checked={settings.enabledCategories.coding} \r\n                onChange={() => handleCategoryToggle('coding')}\r\n              />\r\n              <span className={styles.toggleLabel}>코딩 관련 (GitHub, GitLab 등)</span>\r\n            </label>\r\n          </div>\r\n\r\n          <div className={styles.toggleItem}>\r\n            <label>\r\n              <input \r\n                type=\"checkbox\" \r\n                checked={settings.enabledCategories.sns} \r\n                onChange={() => handleCategoryToggle('sns')}\r\n              />\r\n              <span className={styles.toggleLabel}>SNS/메신저 (Discord, Slack 등)</span>\r\n            </label>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* 시스템 트레이 설정 섹션 */}\r\n      <div className={styles.settingSection}>\r\n        <h3>시스템 트레이 설정</h3>\r\n        <div className={styles.toggleItem}>\r\n          <label>\r\n            <input \r\n              type=\"checkbox\" \r\n              checked={settings.minimizeToTray} \r\n              onChange={handleMinimizeToTrayToggle}\r\n            />\r\n            <span className={styles.toggleLabel}>창 닫기 시 트레이로 최소화 (백그라운드 실행)</span>\r\n          </label>\r\n        </div>\r\n        \r\n        <div className={styles.toggleItem}>\r\n          <label>\r\n            <input \r\n              type=\"checkbox\" \r\n              checked={settings.showTrayNotifications} \r\n              onChange={handleShowTrayNotificationsToggle}\r\n              disabled={!settings.minimizeToTray}\r\n            />\r\n            <span className={styles.toggleLabel}>\r\n              트레이 알림 표시\r\n              {!settings.minimizeToTray && (\r\n                <small className={styles.disabledNote}> (트레이로 최소화 옵션이 활성화되어야 함)</small>\r\n              )}\r\n            </span>\r\n          </label>\r\n        </div>\r\n        \r\n        <div className={styles.toggleItem}>\r\n          <label>\r\n            <input \r\n              type=\"checkbox\" \r\n              checked={settings.reduceMemoryInBackground} \r\n              onChange={handleReduceMemoryToggle}\r\n              disabled={!settings.minimizeToTray}\r\n            />\r\n            <span className={styles.toggleLabel}>\r\n              백그라운드에서 메모리 사용 최적화\r\n              {!settings.minimizeToTray && (\r\n                <small className={styles.disabledNote}> (트레이로 최소화 옵션이 활성화되어야 함)</small>\r\n              )}\r\n            </span>\r\n          </label>\r\n        </div>\r\n        \r\n        {/* 미니뷰 설정 추가 */}\r\n        <div className={styles.toggleItem}>\r\n          <label>\r\n            <input \r\n              type=\"checkbox\" \r\n              checked={settings.enableMiniView} \r\n              onChange={handleMiniViewToggle}\r\n              disabled={!settings.minimizeToTray}\r\n            />\r\n            <span className={styles.toggleLabel}>\r\n              트레이 아이콘 클릭 시 미니뷰(PiP) 표시\r\n              {!settings.minimizeToTray && (\r\n                <small className={styles.disabledNote}> (트레이로 최소화 옵션이 활성화되어야 함)</small>\r\n              )}\r\n            </span>\r\n          </label>\r\n        </div>\r\n        \r\n        <p className={styles.settingDescription}>\r\n          트레이로 최소화 기능을 사용하면 창을 닫아도 앱이 백그라운드에서 계속 실행되어 타이핑을 모니터링합니다.\r\n          메모리 사용 최적화 옵션은 백그라운드 실행 시 RAM 사용량을 줄여줍니다.\r\n        </p>\r\n        \r\n        <p className={styles.settingDescription}>\r\n          미니뷰를 활성화하면 트레이 아이콘을 클릭할 때 화면 상단에 작은 통계 창이 표시됩니다.\r\n          이를 통해 앱을 최소화한 상태에서도 중요한 타이핑 통계를 확인할 수 있습니다.\r\n        </p>\r\n      </div>\r\n\r\n      {/* 성능 섹션 */}\r\n      <div className={styles.settingSection}>\r\n        <h3>성능 설정</h3>\r\n        \r\n        <div className={styles.toggleItem}>\r\n          <label>\r\n            <input \r\n              type=\"checkbox\" \r\n              checked={settings.useHardwareAcceleration} \r\n              onChange={handleHardwareAccelerationToggle}\r\n            />\r\n            <span className={styles.toggleLabel}>\r\n              GPU 하드웨어 가속 사용 (재시작 필요)\r\n            </span>\r\n          </label>\r\n          <p className={styles.settingDescription}>\r\n            GPU 하드웨어 가속을 활성화하면 그래픽 렌더링과 일부 계산이 더 빨라질 수 있지만,\r\n            일부 시스템에서는 불안정할 수 있습니다. 변경 후 앱 재시작이 필요합니다.\r\n          </p>\r\n          {needsRestart && (\r\n            <div className={styles.restartNotice}>\r\n              <p>GPU 가속 설정이 변경되었습니다. 변경 사항을 적용하려면 앱을 재시작해야 합니다.</p>\r\n              <div className={styles.buttonGroup}>\r\n                <button \r\n                  className={styles.restartButton}\r\n                  onClick={handleRestartClick}\r\n                >\r\n                  지금 재시작\r\n                </button>\r\n                <button \r\n                  className={styles.debugButton}\r\n                  onClick={toggleDebugInfo}\r\n                >\r\n                  API 디버그 정보\r\n                </button>\r\n              </div>\r\n              \r\n              {/* 디버그 정보 표시 영역 */}\r\n              {showDebugInfo && (\r\n                <div className={styles.debugInfo}>\r\n                  <h4>API 디버그 정보</h4>\r\n                  <pre>{apiDebugInfo || '정보 없음'}</pre>\r\n                </div>\r\n              )}\r\n            </div>\r\n          )}\r\n        </div>\r\n        \r\n        <div className={styles.toggleItem}>\r\n          <label className={styles.selectLabel}>처리 모드:</label>\r\n          <select \r\n            className={styles.selectControl}\r\n            value={settings.processingMode || 'auto'} \r\n            onChange={(e) => handleSettingChange('processingMode', e.target.value)}\r\n          >\r\n            <option value=\"auto\">자동 (리소스에 따라 결정)</option>\r\n            <option value=\"normal\">일반 모드</option>\r\n            <option value=\"cpu-intensive\">CPU 집약적 모드 (메모리 최적화)</option>\r\n            <option value=\"gpu-intensive\">GPU 가속 모드 (실험적)</option>\r\n          </select>\r\n        </div>\r\n        <p className={styles.settingDescription}>\r\n          처리 모드에 따라 타이핑 통계 계산 방식이 달라집니다. 자동 모드는 시스템 리소스에 따라\r\n          최적의 모드를 선택합니다. CPU 집약적 모드는 메모리 사용을 줄이고, GPU 가속 모드는\r\n          GPU를 활용하여 계산 속도를 높입니다.\r\n        </p>\r\n        \r\n        <div className={styles.toggleItem}>\r\n          <label className={styles.selectLabel}>메모리 임계치 (MB):</label>\r\n          <input \r\n            type=\"number\" \r\n            className={styles.numberInput}\r\n            value={settings.maxMemoryThreshold || 100} \r\n            onChange={(e) => handleSettingChange('maxMemoryThreshold', parseInt(e.target.value))}\r\n            min={50}\r\n            max={500}\r\n          />\r\n        </div>\r\n        <p className={styles.settingDescription}>\r\n          메모리 사용량이 이 임계치를 초과하면 메모리 최적화 모드로 전환됩니다.\r\n          값이 높을수록 더 많은 메모리를 사용하지만 성능이 향상될 수 있습니다.\r\n        </p>\r\n      </div>\r\n\r\n      <div className={styles.buttonRow}>\r\n        <button \r\n          className={styles.saveButton}\r\n          onClick={handleSaveSettings}\r\n        >\r\n          설정 저장\r\n        </button>\r\n      </div>\r\n      \r\n      {/* 설정 저장 확인 대화상자 */}\r\n      <SaveConfirmDialog \r\n        isOpen={showSaveConfirm}\r\n        onConfirm={confirmSaveSettings}\r\n        onCancel={cancelSaveSettings}\r\n        isDarkMode={darkMode}\r\n      />\r\n    </div>\r\n  );\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\StatsChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\TabNavigation.tsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'tab' is defined but never used.","line":8,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":28}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { memo } from 'react';\r\nimport styles from '../page.module.css';\r\n\r\ninterface TabNavigationProps {\r\n  activeTab: string;\r\n  onTabChange: (tab: string) => void;\r\n  onDebugToggle: () => void;\r\n  debugMode: boolean;\r\n}\r\n\r\nexport const TabNavigation = memo(function TabNavigation({\r\n  activeTab,\r\n  onTabChange,\r\n  onDebugToggle,\r\n  debugMode\r\n}: TabNavigationProps) {\r\n  return (\r\n    <div className={styles.appTabs} style={{ pointerEvents: 'auto' }}>\r\n      <button \r\n        className={`${styles.tabButton} ${activeTab === 'monitor' ? styles.activeTab : ''}`}\r\n        onClick={() => onTabChange('monitor')}\r\n        style={{ pointerEvents: 'auto' }}\r\n      >\r\n        모니터링\r\n      </button>\r\n      \r\n      <button \r\n        className={`${styles.tabButton} ${activeTab === 'history' ? styles.activeTab : ''}`}\r\n        onClick={() => onTabChange('history')}\r\n        style={{ pointerEvents: 'auto' }}\r\n      >\r\n        히스토리\r\n      </button>\r\n      \r\n      <button \r\n        className={`${styles.tabButton} ${activeTab === 'stats' ? styles.activeTab : ''}`}\r\n        onClick={() => onTabChange('stats')}\r\n        style={{ pointerEvents: 'auto' }}\r\n      >\r\n        통계\r\n      </button>\r\n      \r\n      <button \r\n        className={`${styles.tabButton} ${activeTab === 'chart' ? styles.activeTab : ''}`}\r\n        onClick={() => onTabChange('chart')}\r\n        style={{ pointerEvents: 'auto' }}\r\n      >\r\n        차트\r\n      </button>\r\n      \r\n      <button \r\n        className={`${styles.tabButton} ${activeTab === 'settings' ? styles.activeTab : ''}`}\r\n        onClick={() => onTabChange('settings')}\r\n        style={{ pointerEvents: 'auto' }}\r\n      >\r\n        설정\r\n      </button>\r\n      \r\n      {/* 디버그 모드 토글 버튼 */}\r\n      <button \r\n        className={`${styles.tabButton} ${styles.debugButton} ${debugMode ? styles.debugActive : ''}`}\r\n        onClick={onDebugToggle}\r\n        title=\"디버그 모드 토글\"\r\n        style={{ pointerEvents: 'auto' }}\r\n      >\r\n        🐞\r\n      </button>\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default TabNavigation;\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\ThemeProvider.tsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'enabled' is defined but never used.","line":9,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":34,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":36,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":36,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":41,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":41,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":44,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":44,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":46,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":46,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":50,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":50,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":51,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":51,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":64,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":64,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":70,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":74,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":74,"endColumn":14}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { createContext, useState, useContext, ReactNode, useEffect } from 'react';\r\n\r\n// 테마 컨텍스트 정의\r\ninterface ThemeContextType {\r\n  theme: 'light' | 'dark';\r\n  toggleTheme: () => void;\r\n  setDarkMode: (enabled: boolean) => void;\r\n}\r\n\r\nconst ThemeContext = createContext<ThemeContextType>({\r\n  theme: 'light',\r\n  toggleTheme: () => {},\r\n  setDarkMode: () => {},\r\n});\r\n\r\n// useTheme 훅 생성\r\nexport const useTheme = () => useContext(ThemeContext);\r\n\r\ninterface ThemeProviderProps {\r\n  children: ReactNode;\r\n}\r\n\r\nexport function ThemeProvider({ children }: ThemeProviderProps) {\r\n  const [theme, setTheme] = useState<'light' | 'dark'>('light');\r\n  \r\n  // 다크 모드 설정 함수\r\n  const setDarkMode = (enabled: boolean) => {\r\n    setTheme(enabled ? 'dark' : 'light');\r\n    \r\n    // HTML 태그에 dark-mode 클래스 적용\r\n    if (enabled) {\r\n      document.documentElement.classList.add('dark-mode');\r\n    } else {\r\n      document.documentElement.classList.remove('dark-mode');\r\n    }\r\n    \r\n    // 로컬 스토리지에 설정 저장\r\n    try {\r\n      const savedSettings = localStorage.getItem('app-settings');\r\n      const settings = savedSettings ? JSON.parse(savedSettings) : {};\r\n      settings.darkMode = enabled;\r\n      localStorage.setItem('app-settings', JSON.stringify(settings));\r\n    } catch (e) {\r\n      console.error('설정 저장 오류:', e);\r\n    }\r\n    \r\n    // Electron API가 있으면 설정 저장\r\n    if (window.electronAPI) {\r\n      window.electronAPI.setDarkMode(enabled);\r\n    }\r\n  };\r\n  \r\n  // 테마 토글 함수\r\n  const toggleTheme = () => {\r\n    const newTheme = theme === 'light' ? 'dark' : 'light';\r\n    setDarkMode(newTheme === 'dark');\r\n  };\r\n  \r\n  useEffect(() => {\r\n    // 로컬 스토리지에서 다크 모드 설정 불러오기\r\n    try {\r\n      const savedSettings = localStorage.getItem('app-settings');\r\n      if (savedSettings) {\r\n        const settings = JSON.parse(savedSettings);\r\n        setDarkMode(settings.darkMode || false);\r\n      } else {\r\n        // 시스템 다크 모드 감지\r\n        const prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;\r\n        setDarkMode(prefersDarkMode);\r\n      }\r\n    } catch (e) {\r\n      console.error('설정 파싱 오류:', e);\r\n    }\r\n  }, []);\r\n\r\n  return (\r\n    <ThemeContext.Provider value={{ theme, toggleTheme, setDarkMode }}>\r\n      {children}\r\n    </ThemeContext.Provider>\r\n  );\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\ThemeProviderWrapper.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\Toast.tsx","messages":[{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":15,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":15,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":20,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":20,"endColumn":30}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useState } from 'react';\r\nimport styles from './Toast.module.css';\r\n\r\ninterface ToastProps {\r\n  message: string;\r\n  type: 'success' | 'error' | 'info' | 'warning'; // warning 타입 추가\r\n  duration?: number;\r\n  onClose?: () => void;\r\n}\r\n\r\nexport function Toast({ message, type, duration = 3000, onClose }: ToastProps) {\r\n  const [visible, setVisible] = useState(true);\r\n  \r\n  useEffect(() => {\r\n    const timer = setTimeout(() => {\r\n      setVisible(false);\r\n      if (onClose) onClose();\r\n    }, duration);\r\n    \r\n    return () => clearTimeout(timer);\r\n  }, [duration, onClose]);\r\n  \r\n  return visible ? (\r\n    <div className={`${styles.toast} ${styles[type]}`}>\r\n      <span className={styles.message}>{message}</span>\r\n    </div>\r\n  ) : null;\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\ToastContext.tsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'message' is defined but never used.","line":7,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":30},{"ruleId":"no-unused-vars","severity":2,"message":"'type' is defined but never used.","line":7,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":47},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":19,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":19,"endColumn":15},{"ruleId":"no-unused-vars","severity":2,"message":"'type' is defined but never used.","line":43,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":43,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'type' is defined but never used. Allowed unused args must match /^_/u.","line":43,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":43,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":44,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":44,"endColumn":16}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState } from 'react';\r\nimport { Toast } from './Toast';\r\n\r\ntype ToastType = 'success' | 'error' | 'info' | 'warning'; // warning 타입 추가\r\n\r\ninterface ToastContextType {\r\n  showToast: (message: string, type: ToastType) => void;\r\n}\r\n\r\nconst ToastContext = createContext<ToastContextType | undefined>(undefined);\r\n\r\nexport function ToastProvider({ children }: { children: React.ReactNode }) {\r\n  const [toast, setToast] = useState<{ message: string; type: ToastType } | null>(null);\r\n  \r\n  const showToast = (message: string, type: ToastType) => {\r\n    setToast({ message, type });\r\n    \r\n    // 3초 후 자동으로 토스트 제거\r\n    setTimeout(() => {\r\n      setToast(null);\r\n    }, 3000);\r\n  };\r\n  \r\n  return (\r\n    <ToastContext.Provider value={{ showToast }}>\r\n      {children}\r\n      {toast && (\r\n        <Toast\r\n          message={toast.message}\r\n          type={toast.type}\r\n          onClose={() => setToast(null)}\r\n        />\r\n      )}\r\n    </ToastContext.Provider>\r\n  );\r\n}\r\n\r\nexport const useToast = () => {\r\n  const context = useContext(ToastContext);\r\n  if (context === undefined) {\r\n    // 오류 대신 더미 함수 반환하여 앱이 중단되지 않도록 함\r\n    return {\r\n      showToast: (message: string, type: ToastType) => {\r\n        console.warn('ToastProvider가 설정되지 않았습니다:', message);\r\n      }\r\n    };\r\n  }\r\n  return context;\r\n};","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\TypingAnalyzer.tsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'result' is defined but never used.","line":28,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":28,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":56,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":56,"endColumn":14}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport { useNativeGpu } from '../hooks/useNativeGpu';\r\nimport styles from './TypingAnalyzer.module.css';\r\n\r\ninterface TypingData {\r\n  keyCount: number;\r\n  typingTime: number;  // 밀리초\r\n  accuracy?: number;\r\n}\r\n\r\ninterface TypingAnalysisResult {\r\n  wpm: number;\r\n  accuracy: number;\r\n  performance_index: number;\r\n  consistency_score: number;\r\n  fatigue_analysis: {\r\n    score: number;\r\n    time_factor: number;\r\n    intensity_factor: number;\r\n    recommendation: string;\r\n  };\r\n}\r\n\r\nexport function TypingAnalyzer({ data, onResult }: { \r\n  data: TypingData; \r\n  onResult?: (result: TypingAnalysisResult) => void \r\n}) {\r\n  const { available, enabled, loading, error, computeWithGpu, toggleGpuAcceleration } = useNativeGpu();\r\n  const [result, setResult] = useState<TypingAnalysisResult | null>(null);\r\n  const [useGpuAcceleration, setUseGpuAcceleration] = useState<boolean>(false);\r\n\r\n  // 타이핑 통계 분석 수행\r\n  const analyzeTyping = useCallback(async () => {\r\n    if (!data.keyCount || !data.typingTime) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      if (useGpuAcceleration && enabled) {\r\n        // GPU 가속 분석\r\n        const computeResult = await computeWithGpu<TypingAnalysisResult>(data, 'typing');\r\n        \r\n        if (computeResult && computeResult.result_summary) {\r\n          setResult(computeResult.result_summary);\r\n          if (onResult) onResult(computeResult.result_summary);\r\n        }\r\n      } else {\r\n        // 자바스크립트로 분석 (폴백)\r\n        const jsResult = analyzeTypingWithJS(data);\r\n        setResult(jsResult);\r\n        if (onResult) onResult(jsResult);\r\n      }\r\n    } catch (err) {\r\n      console.error('타이핑 분석 오류:', err);\r\n      \r\n      // 오류 시 자바스크립트 폴백 사용\r\n      const jsResult = analyzeTypingWithJS(data);\r\n      setResult(jsResult);\r\n      if (onResult) onResult(jsResult);\r\n    }\r\n  }, [data, useGpuAcceleration, enabled, computeWithGpu, onResult]);\r\n\r\n  // GPU 가속 활성화/비활성화 처리\r\n  const handleToggleGpu = useCallback(async () => {\r\n    const newState = !useGpuAcceleration;\r\n    setUseGpuAcceleration(newState);\r\n    \r\n    if (newState && available && !enabled) {\r\n      await toggleGpuAcceleration(true);\r\n    }\r\n  }, [useGpuAcceleration, available, enabled, toggleGpuAcceleration]);\r\n\r\n  // 데이터 변경 시 재분석\r\n  useEffect(() => {\r\n    if (data.keyCount > 0 && data.typingTime > 0) {\r\n      analyzeTyping();\r\n    }\r\n  }, [data, analyzeTyping]);\r\n\r\n  return (\r\n    <div className={styles.container}>\r\n      <div className={styles.header}>\r\n        <h2 className={styles.title}>타이핑 분석</h2>\r\n        {available && (\r\n          <div className={styles.gpuToggle}>\r\n            <label>\r\n              <input\r\n                type=\"checkbox\"\r\n                checked={useGpuAcceleration}\r\n                onChange={handleToggleGpu}\r\n                disabled={loading}\r\n              />\r\n              GPU 가속 사용\r\n            </label>\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {loading && <div className={styles.loading}>분석 중...</div>}\r\n      \r\n      {error && <div className={styles.error}>{error}</div>}\r\n      \r\n      {result && !loading && (\r\n        <div className={styles.results}>\r\n          <div className={styles.stat}>\r\n            <span className={styles.label}>속도</span>\r\n            <span className={styles.value}>{result.wpm} WPM</span>\r\n          </div>\r\n          \r\n          <div className={styles.stat}>\r\n            <span className={styles.label}>정확도</span>\r\n            <span className={styles.value}>{result.accuracy.toFixed(1)}%</span>\r\n          </div>\r\n          \r\n          <div className={styles.stat}>\r\n            <span className={styles.label}>성능 지수</span>\r\n            <span className={styles.value}>{result.performance_index.toFixed(1)}</span>\r\n          </div>\r\n          \r\n          <div className={styles.stat}>\r\n            <span className={styles.label}>일관성</span>\r\n            <span className={styles.value}>{result.consistency_score.toFixed(1)}</span>\r\n          </div>\r\n          \r\n          <div className={styles.fatigue}>\r\n            <h3>피로도 분석</h3>\r\n            <div className={styles.fatigueMeter}>\r\n              <div \r\n                className={styles.fatigueIndicator} \r\n                style={{ width: `${result.fatigue_analysis.score}%` }}\r\n              />\r\n            </div>\r\n            <p className={styles.recommendation}>\r\n              {result.fatigue_analysis.recommendation}\r\n            </p>\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\n// 자바스크립트로 타이핑 통계 분석 (폴백)\r\nfunction analyzeTypingWithJS(data: TypingData): TypingAnalysisResult {\r\n  const { keyCount, typingTime, accuracy = 100 } = data;\r\n  \r\n  // WPM 계산 (1단어 = 5타)\r\n  const minutes = typingTime / 60000;\r\n  const wpm = minutes > 0 ? (keyCount / 5) / minutes : 0;\r\n  \r\n  // 일관성 점수 (간단한 추정)\r\n  const consistency = 65 + (Math.min(keyCount, 500) / 20);\r\n  \r\n  // 피로도 계산\r\n  const fatigue = {\r\n    score: Math.min(100, (minutes * 10) + (wpm / 10)),\r\n    time_factor: minutes,\r\n    intensity_factor: wpm / 100,\r\n    recommendation: minutes > 30 \r\n      ? \"휴식이 필요합니다\" \r\n      : minutes > 15 \r\n        ? \"짧은 휴식을 고려하세요\" \r\n        : \"좋은 상태입니다\"\r\n  };\r\n  \r\n  return {\r\n    wpm,\r\n    accuracy,\r\n    performance_index: (wpm * accuracy / 100),\r\n    consistency_score: consistency,\r\n    fatigue_analysis: fatigue\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\TypingAnalyzerWrapper.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\TypingBox.tsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'record' is defined but never used.","line":6,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":4},{"ruleId":"no-undef","severity":2,"message":"'HTMLDivElement' is not defined.","line":17,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":17,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":28,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":28,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":29,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":70,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":76,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":76,"endColumn":46},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":77,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":77,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":81,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":81,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":82,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":82,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'HTMLDivElement' is not defined.","line":85,"column":61,"nodeType":"Identifier","messageId":"undef","endLine":85,"endColumn":75},{"ruleId":"no-undef","severity":2,"message":"'HTMLDivElement' is not defined.","line":100,"column":71,"nodeType":"Identifier","messageId":"undef","endLine":100,"endColumn":85},{"ruleId":"no-undef","severity":2,"message":"'HTMLDivElement' is not defined.","line":122,"column":55,"nodeType":"Identifier","messageId":"undef","endLine":122,"endColumn":69},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":170,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":170,"endColumn":48},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":171,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":171,"endColumn":45}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useRef, useState, useCallback, useEffect } from 'react';\r\n\r\ninterface TypingBoxProps {\r\n  onComplete: (record: {\r\n    content: string;\r\n    keyCount: number;\r\n    typingTime: number;\r\n    timestamp: string;\r\n  }) => void;\r\n}\r\n\r\nconst IDLE_TIMEOUT = 3000; // 3초\r\n\r\nexport function TypingBox({ onComplete }: TypingBoxProps) {\r\n  const editorRef = useRef<HTMLDivElement>(null);\r\n  const [typingTime, setTypingTime] = useState<number>(0);\r\n  const [keyCount, setKeyCount] = useState<number>(0);\r\n  const [stats, setStats] = useState({\r\n    pages: 0,\r\n    words: 0,\r\n    charCount: 0,\r\n    charCountNoSpace: 0,\r\n    accuracy: 100, // 정확도 추가\r\n  });\r\n  \r\n  const idleTimerRef = useRef<NodeJS.Timeout | null>(null);\r\n  const typingTimerRef = useRef<NodeJS.Timeout | null>(null);\r\n  const compositionHandledRef = useRef<boolean>(false);\r\n  const totalKeystrokesRef = useRef<number>(0); // 전체 입력 타수 (정확도 계산용)\r\n\r\n  // 구글 문서 방식으로 통계 업데이트\r\n  const updateStats = useCallback(() => {\r\n    if (!editorRef.current) return;\r\n    \r\n    const content = editorRef.current.textContent ?? '';\r\n    \r\n    // 구글 문서 방식의 단어 수(공백 기준 어절 분리)\r\n    const words = content.trim().length > 0\r\n      ? content.trim().split(/\\s+/).length\r\n      : 0;\r\n    \r\n    // 글자 수(공백 포함) - 모든 글자 1개씩 카운트\r\n    const charCount = content.length;\r\n    \r\n    // 글자 수(공백 제외)\r\n    const charCountNoSpace = content.replace(/\\s/g, '').length;\r\n    \r\n    // 페이지 수 계산(600자 기준)\r\n    const pages = Math.max(1, Math.ceil(charCount / 600));\r\n    \r\n    // 정확도 계산 (실제 환경에서는 원본 텍스트와 비교해야 함)\r\n    // 여기서는 단순화하여 100% 정확도로 가정\r\n    const accuracy = totalKeystrokesRef.current > 0 \r\n      ? Math.round((keyCount / totalKeystrokesRef.current) * 100)\r\n      : 100;\r\n\r\n    setStats({\r\n      pages,\r\n      words,\r\n      charCount,\r\n      charCountNoSpace,\r\n      accuracy,\r\n    });\r\n  }, [keyCount]);\r\n\r\n  const stopTyping = useCallback(() => {\r\n    if (typingTimerRef.current) {\r\n      clearInterval(typingTimerRef.current);\r\n      typingTimerRef.current = null;\r\n    }\r\n  }, []);\r\n\r\n  const startTyping = useCallback(() => {\r\n    if (typingTimerRef.current) clearInterval(typingTimerRef.current);\r\n    typingTimerRef.current = setInterval(() => {\r\n      setTypingTime(prev => prev + 1);\r\n    }, 1000);\r\n\r\n    if (idleTimerRef.current) clearTimeout(idleTimerRef.current);\r\n    idleTimerRef.current = setTimeout(stopTyping, IDLE_TIMEOUT);\r\n  }, [stopTyping]);\r\n\r\n  const handleKeyDown = useCallback((e: React.KeyboardEvent<HTMLDivElement>) => {\r\n    // e.key가 한 글자이거나 스페이스/엔터일 때만 카운트\r\n    if (e.key.length === 1 || e.key === ' ' || e.key === 'Enter') {\r\n      // 한글 완성형은 2타, 나머지는 1타로 계산\r\n      const isKorean = /[가-힣]/.test(e.key);\r\n      const keystrokeCount = isKorean ? 2 : 1;\r\n      \r\n      setKeyCount(prev => prev + keystrokeCount);\r\n      totalKeystrokesRef.current += keystrokeCount;\r\n      \r\n      startTyping();\r\n      updateStats();\r\n    }\r\n  }, [startTyping, updateStats]);\r\n\r\n  const handleCompositionEnd = useCallback((e: React.CompositionEvent<HTMLDivElement>) => {\r\n    compositionHandledRef.current = true;\r\n    let typeCount = 0;\r\n    \r\n    // 한글 완성형은 2타, 자음/모음은 1타, 다른 문자도 1타로 계산\r\n    for (const char of e.data) {\r\n      if (/[가-힣]/.test(char)) {\r\n        typeCount += 2; // 한글 완성형은 2타\r\n      } else if (/[ㄱ-ㅎ|ㅏ-ㅣ]/.test(char)) {\r\n        typeCount += 1; // 한글 자음/모음은 1타\r\n      } else {\r\n        typeCount += 1; // 그 외 문자는 1타\r\n      }\r\n    }\r\n    \r\n    setKeyCount(prev => prev + typeCount);\r\n    totalKeystrokesRef.current += typeCount;\r\n    \r\n    startTyping();\r\n    updateStats();\r\n  }, [startTyping, updateStats]);\r\n\r\n  const handleInput = useCallback((e: React.FormEvent<HTMLDivElement> & { data?: string }) => {\r\n    if (compositionHandledRef.current) {\r\n      compositionHandledRef.current = false;\r\n      return;\r\n    }\r\n    \r\n    if (e.data) {\r\n      // 각 문자별로 타수 계산\r\n      let inputTypeCount = 0;\r\n      for (const char of e.data) {\r\n        if (/[가-힣]/.test(char)) {\r\n          inputTypeCount += 2; // 한글 완성형은 2타\r\n        } else {\r\n          inputTypeCount += 1; // 그 외 문자는 1타\r\n        }\r\n      }\r\n      \r\n      setKeyCount(prev => prev + inputTypeCount);\r\n      totalKeystrokesRef.current += inputTypeCount;\r\n      \r\n      startTyping();\r\n      updateStats();\r\n    }\r\n  }, [startTyping, updateStats]);\r\n\r\n  const handleSave = async () => {\r\n    if (!editorRef.current) return;\r\n    \r\n    const content = editorRef.current.textContent ?? '';\r\n    const logData = {\r\n      content,\r\n      keyCount,\r\n      typingTime,\r\n      timestamp: new Date().toISOString(),\r\n    };\r\n    \r\n    onComplete(logData);\r\n    \r\n    // 저장 후 초기화\r\n    if (editorRef.current) editorRef.current.textContent = '';\r\n    setKeyCount(0);\r\n    setTypingTime(0);\r\n    totalKeystrokesRef.current = 0;\r\n    updateStats();\r\n  };\r\n\r\n  useEffect(() => {\r\n    return () => {\r\n      if (typingTimerRef.current) clearInterval(typingTimerRef.current);\r\n      if (idleTimerRef.current) clearTimeout(idleTimerRef.current);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"typing-box-container\">\r\n      <div className=\"status-bar\">\r\n        <div className=\"stats-display\">\r\n          <span>글자 수: {stats.charCount}(공백 제외: {stats.charCountNoSpace})</span>\r\n          <span>단어 수: {stats.words}</span>\r\n          <span>페이지 수: {stats.pages}</span>\r\n          <span>타자 수: {keyCount}</span>\r\n          <span>타이핑 시간: {typingTime}초</span>\r\n          <span>타수: {typingTime > 0 ? Math.round((keyCount / typingTime) * 60) : 0}타/분</span>\r\n          <span>정확도: {stats.accuracy}%</span>\r\n        </div>\r\n        <button className=\"save-button\" onClick={handleSave}>저장</button>\r\n      </div>\r\n      \r\n      <div\r\n        ref={editorRef}\r\n        className=\"editor\"\r\n        contentEditable\r\n        onKeyDown={handleKeyDown}\r\n        onCompositionEnd={handleCompositionEnd}\r\n        onInput={handleInput}\r\n      />\r\n    </div>\r\n  );\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\TypingChart.tsx","messages":[{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":67,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":67,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":68,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":68,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'CustomEvent' is not defined.","line":76,"column":42,"nodeType":"Identifier","messageId":"undef","endLine":76,"endColumn":53},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":80,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":80,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'EventListener' is not defined.","line":80,"column":73,"nodeType":"Identifier","messageId":"undef","endLine":80,"endColumn":86},{"ruleId":"no-undef","severity":2,"message":"'MutationObserver' is not defined.","line":83,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":83,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":84,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":84,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":88,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":88,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":100,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":100,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'EventListener' is not defined.","line":100,"column":78,"nodeType":"Identifier","messageId":"undef","endLine":100,"endColumn":91},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":110,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":110,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":112,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":112,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":114,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":114,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":114,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":114,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2822,2846],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":125,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":125,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":130,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":130,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":294,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":294,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":350,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":350,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":356,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":356,"endColumn":32}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useEffect, useState, useCallback, useMemo, useRef } from 'react';\r\nimport {\r\n  Chart as ChartJS,\r\n  CategoryScale,\r\n  LinearScale,\r\n  PointElement,\r\n  LineElement,\r\n  BarElement,\r\n  Title,\r\n  Tooltip,\r\n  Legend,\r\n} from 'chart.js';\r\nimport { Line, Bar } from 'react-chartjs-2';\r\nimport styles from './TypingChart.module.css';\r\n\r\n// Chart.js 컴포넌트 등록\r\nChartJS.register(\r\n  CategoryScale,\r\n  LinearScale,\r\n  PointElement,\r\n  LineElement,\r\n  BarElement,\r\n  Title,\r\n  Tooltip,\r\n  Legend\r\n);\r\n\r\ninterface LogType {\r\n  id: number;\r\n  content: string;\r\n  key_count: number;\r\n  typing_time: number;\r\n  timestamp: string;\r\n  created_at: string;\r\n}\r\n\r\ninterface TypingChartProps {\r\n  logs: LogType[];\r\n}\r\n\r\n// 로그 데이터 필터링 함수 - 컴포넌트 외부로 이동\r\nconst filterLogsForChart = (logs: LogType[]) => {\r\n  // 최근 7일 데이터만 표시 (30일에서 7일로 단축)\r\n  const sevenDaysAgo = new Date();\r\n  sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\r\n  \r\n  return logs\r\n    .filter(log => new Date(log.timestamp) >= sevenDaysAgo)\r\n    .slice(0, 50); // 최대 50개 항목으로 제한 (100개에서 50개로 축소)\r\n};\r\n\r\nexport const TypingChart = React.memo(function TypingChart({ logs }: TypingChartProps) {\r\n  // 다크 모드 상태 추적\r\n  const [isDarkMode, setIsDarkMode] = useState(false);\r\n  \r\n  // 차트 인스턴스 참조 저장\r\n  const chartRefs = useRef<any[]>([]);\r\n  \r\n  // 컴포넌트 마운트/언마운트 감지\r\n  const isMountedRef = useRef(true);\r\n  \r\n  // 다크 모드 감지 함수 개선\r\n  useEffect(() => {\r\n    const checkDarkMode = () => {\r\n      const isDark = document.documentElement.classList.contains('dark-mode') || \r\n                    document.body.classList.contains('dark-mode');\r\n      setIsDarkMode(isDark);\r\n    };\r\n    \r\n    // 초기 확인\r\n    checkDarkMode();\r\n    \r\n    // 커스텀 이벤트 리스너 추가\r\n    const handleDarkModeChange = (event: CustomEvent<{darkMode: boolean}>) => {\r\n      setIsDarkMode(event.detail.darkMode);\r\n    };\r\n    \r\n    window.addEventListener('darkmode-changed', handleDarkModeChange as EventListener);\r\n    \r\n    // DOM 변화 관찰\r\n    const observer = new MutationObserver(checkDarkMode);\r\n    observer.observe(document.documentElement, { \r\n      attributes: true, \r\n      attributeFilter: ['class'] \r\n    });\r\n    observer.observe(document.body, { \r\n      attributes: true, \r\n      attributeFilter: ['class'] \r\n    });\r\n    \r\n    // 컴포넌트 마운트 상태 설정\r\n    isMountedRef.current = true;\r\n    \r\n    return () => {\r\n      // 컴포넌트 언마운트 시 모든 리소스 해제\r\n      isMountedRef.current = false;\r\n      observer.disconnect();\r\n      window.removeEventListener('darkmode-changed', handleDarkModeChange as EventListener);\r\n      \r\n      // 차트 인스턴스 정리\r\n      chartRefs.current.forEach(chart => {\r\n        if (chart && chart.destroy) {\r\n          chart.destroy();\r\n        }\r\n      });\r\n      \r\n      // 메모리 정리 요청\r\n      if (window.gc) {\r\n        try {\r\n          window.gc();\r\n        } catch (e) {\r\n          console.log('GC 호출 실패');\r\n        }\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  // 필터링된 로그 데이터 메모이제이션 (최소 데이터만 사용)\r\n  const filteredLogs = useMemo(() => {\r\n    try {\r\n      // 데이터 검증 추가\r\n      if (!Array.isArray(logs)) {\r\n        console.warn('유효하지 않은 로그 데이터:', logs);\r\n        return [];\r\n      }\r\n      return filterLogsForChart(logs);\r\n    } catch (error) {\r\n      console.error('로그 필터링 중 오류:', error);\r\n      return [];\r\n    }\r\n  }, [logs]);\r\n\r\n  // 차트 옵션 - 다크 모드에 따라 변경되는 옵션들\r\n  const getChartOptions = useCallback((title: string) => {\r\n    return {\r\n      responsive: true,\r\n      maintainAspectRatio: false,\r\n      // 메모리 사용량 감소를 위한 설정 추가\r\n      animation: {\r\n        duration: 0 // 애니메이션 비활성화\r\n      },\r\n      // 데이터 포인트 수 제한\r\n      elements: {\r\n        point: {\r\n          radius: 2, // 더 작은 포인트 크기\r\n          hoverRadius: 4,\r\n        },\r\n        line: {\r\n          tension: 0, // 직선으로 연결 (곡선 없음)\r\n        }\r\n      },\r\n      // 렌더링 성능 개선\r\n      devicePixelRatio: 1,\r\n      plugins: {\r\n        legend: { \r\n          position: 'top' as const,\r\n          labels: {\r\n            color: isDarkMode ? '#E0E0E0' : '#333',\r\n            // 폰트 크기 축소\r\n            font: {\r\n              size: 11,\r\n            }\r\n          }\r\n        },\r\n        title: { \r\n          display: true, \r\n          text: title,\r\n          color: isDarkMode ? '#E0E0E0' : '#333',\r\n          // 수정: 'normal'을 리터럴로 변경\r\n          font: {\r\n            size: 12,\r\n            weight: 'normal' as const, // 타입 문제 해결\r\n          }\r\n        },\r\n        tooltip: {\r\n          enabled: true, // 필요한 경우에만 활성화\r\n          backgroundColor: isDarkMode ? 'rgba(30, 30, 30, 0.8)' : 'rgba(255, 255, 255, 0.8)',\r\n          titleColor: isDarkMode ? '#E0E0E0' : '#333',\r\n          bodyColor: isDarkMode ? '#B0B0B0' : '#666',\r\n          borderColor: isDarkMode ? '#303030' : '#ddd',\r\n          borderWidth: 1,\r\n          // 툴팁 콜백 간소화\r\n          callbacks: {\r\n            label: function(context: any) {\r\n              return context.raw;\r\n            }\r\n          }\r\n        }\r\n      },\r\n      scales: {\r\n        x: {\r\n          ticks: { \r\n            color: isDarkMode ? '#B0B0B0' : '#666',\r\n            // 표시할 틱 수 제한\r\n            maxTicksLimit: 7,\r\n            font: {\r\n              size: 10,\r\n            }\r\n          },\r\n          grid: { \r\n            color: isDarkMode ? 'rgba(60, 60, 60, 0.3)' : 'rgba(0, 0, 0, 0.1)',\r\n            // 그리드 간소화\r\n            display: false\r\n          }\r\n        },\r\n        y: {\r\n          ticks: { \r\n            color: isDarkMode ? '#B0B0B0' : '#666',\r\n            font: {\r\n              size: 10,\r\n            }\r\n          },\r\n          grid: { \r\n            color: isDarkMode ? 'rgba(60, 60, 60, 0.3)' : 'rgba(0, 0, 0, 0.1)',\r\n            // 그리드 선 수 제한\r\n            tickLength: 5\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }, [isDarkMode]);\r\n\r\n  // 날짜별 통계 데이터 가공 - 메모이제이션\r\n  const chartData = useMemo(() => {\r\n    try {\r\n      // 데이터가 없으면 기본값 반환\r\n      if (!Array.isArray(filteredLogs) || filteredLogs.length === 0) {\r\n        return {\r\n          labels: [],\r\n          keyCountData: [],\r\n          timeData: [],\r\n          speedData: [],\r\n          wordData: [],\r\n          charData: []\r\n        };\r\n      }\r\n      \r\n      const dataMap = new Map();\r\n\r\n      // 데이터 검증 추가\r\n      for (let i = 0; i < filteredLogs.length; i++) {\r\n        const log = filteredLogs[i];\r\n        if (!log || typeof log !== 'object') continue;\r\n        \r\n        // timestamp가 없거나 유효하지 않은 경우 건너뛰기\r\n        if (!log.timestamp || !Date.parse(log.timestamp)) continue;\r\n        \r\n        const date = new Date(log.timestamp).toLocaleDateString();\r\n        \r\n        if (!dataMap.has(date)) {\r\n          dataMap.set(date, {\r\n            totalKeyCount: 0,\r\n            totalTime: 0,\r\n            totalChars: 0,\r\n            totalWords: 0,\r\n          });\r\n        }\r\n\r\n        const data = dataMap.get(date);\r\n        data.totalKeyCount += log.key_count || 0;\r\n        data.totalTime += log.typing_time || 0;\r\n        \r\n        // 콘텐츠 길이 기반 계산 (간소화)\r\n        const contentLength = log.content?.length || 0;\r\n        data.totalChars += contentLength;\r\n        data.totalWords += Math.ceil(contentLength / 5);\r\n      }\r\n\r\n      // 배열로 변환 (Object.entries 사용)\r\n      const sortedDates = Array.from(dataMap.keys()).sort((a, b) => \r\n        new Date(a).getTime() - new Date(b).getTime()\r\n      );\r\n      \r\n      return {\r\n        // 날짜 레이블 간략화 (월/일만 표시)\r\n        labels: sortedDates.map(date => {\r\n          const parts = date.split('/');\r\n          return parts.length >= 2 ? `${parts[0]}/${parts[1]}` : date;\r\n        }),\r\n        keyCountData: sortedDates.map(date => dataMap.get(date).totalKeyCount),\r\n        // 분 단위로 변환하고 정수로 반올림\r\n        timeData: sortedDates.map(date => Math.round(dataMap.get(date).totalTime / 60)),\r\n        // 속도 계산도 간소화\r\n        speedData: sortedDates.map(date => {\r\n          const d = dataMap.get(date);\r\n          return d.totalTime > 0 ? Math.round((d.totalKeyCount / d.totalTime) * 60) : 0;\r\n        }),\r\n        wordData: sortedDates.map(date => dataMap.get(date).totalWords),\r\n        charData: sortedDates.map(date => dataMap.get(date).totalChars),\r\n      };\r\n    } catch (error) {\r\n      console.error('차트 데이터 생성 중 오류:', error);\r\n      // 오류 발생 시 빈 데이터 반환\r\n      return {\r\n        labels: [],\r\n        keyCountData: [],\r\n        timeData: [],\r\n        speedData: [],\r\n        wordData: [],\r\n        charData: []\r\n      };\r\n    }\r\n  }, [filteredLogs]);\r\n\r\n  // 차트 데이터 생성 함수 - 메모리 사용 최적화\r\n  const createChartData = useCallback((\r\n    labels: string[], \r\n    data: number[], \r\n    label: string, \r\n    color: string, \r\n    bgColor: string\r\n  ) => {\r\n    return {\r\n      labels,\r\n      datasets: [\r\n        {\r\n          label,\r\n          data,\r\n          borderColor: color,\r\n          backgroundColor: bgColor,\r\n          // 불필요한 옵션 제거\r\n          pointBackgroundColor: color,\r\n          borderWidth: 1,\r\n          fill: false,\r\n        },\r\n      ],\r\n    };\r\n  }, []);\r\n\r\n  // 메모이제이션된 차트 데이터 (함수로 생성)\r\n  const speedChartData = useMemo(() => \r\n    createChartData(\r\n      chartData.labels,\r\n      chartData.speedData,\r\n      '평균 타이핑 속도 (타/분)',\r\n      isDarkMode ? 'rgb(3, 218, 198)' : 'rgb(75, 192, 192)',\r\n      isDarkMode ? 'rgba(3, 218, 198, 0.5)' : 'rgba(75, 192, 192, 0.5)'\r\n    ),\r\n  [chartData.labels, chartData.speedData, isDarkMode, createChartData]);\r\n\r\n  // 더 효율적인 렌더링을 위한 지연 로딩 상태\r\n  const [shouldRenderCharts, setShouldRenderCharts] = useState(false);\r\n\r\n  // 지연 로딩 설정\r\n  useEffect(() => {\r\n    if (!shouldRenderCharts && filteredLogs.length > 0) {\r\n      // 약간의 지연 후 차트 렌더링 시작\r\n      const timer = setTimeout(() => {\r\n        if (isMountedRef.current) {\r\n          setShouldRenderCharts(true);\r\n        }\r\n      }, 100);\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [filteredLogs.length, shouldRenderCharts]);\r\n\r\n  // 차트 참조 설정 콜백\r\n  const setChartRef = useCallback((instance: any) => {\r\n    if (instance) {\r\n      chartRefs.current.push(instance);\r\n    }\r\n  }, []);\r\n\r\n  return (\r\n    <div className={styles.chartContainer}>\r\n      <h2>타이핑 통계 차트</h2>\r\n      \r\n      {filteredLogs.length > 0 ? (\r\n        <div className={styles.charts}>\r\n          {/* 차트 렌더링에 지연 로딩 및 조건부 렌더링 적용 */}\r\n          {shouldRenderCharts && chartData.labels.length > 0 && (\r\n            <div className={styles.chartItem}>\r\n              <h3>일별 평균 타이핑 속도</h3>\r\n              <div className={styles.chartWrapper}>\r\n                <Line \r\n                  data={speedChartData} \r\n                  options={getChartOptions('일별 평균 속도 (타/분)')}\r\n                  redraw={false}\r\n                  ref={setChartRef}\r\n                />\r\n              </div>\r\n            </div>\r\n          )}\r\n          \r\n          {/* 다른 차트들은 사용자가 탭을 전환할 때만 렌더링하도록 지연 로딩 처리 */}\r\n          {shouldRenderCharts && (\r\n            <>\r\n              <div className={styles.chartItem}>\r\n                <h3>일별 총 타자 수</h3>\r\n                <div className={styles.chartWrapper}>\r\n                  <Bar \r\n                    data={{\r\n                      labels: chartData.labels,\r\n                      datasets: [{\r\n                        label: '총 타자 수',\r\n                        data: chartData.keyCountData,\r\n                        backgroundColor: isDarkMode ? 'rgba(30, 136, 229, 0.7)' : 'rgba(54, 162, 235, 0.5)',\r\n                      }]\r\n                    }}\r\n                    options={getChartOptions('일별 총 타자 수')}\r\n                    redraw={false}\r\n                    ref={setChartRef}\r\n                  />\r\n                </div>\r\n              </div>\r\n              \r\n              <div className={styles.chartItem}>\r\n                <h3>일별 총 타이핑 시간</h3>\r\n                <div className={styles.chartWrapper}>\r\n                  <Bar \r\n                    data={{\r\n                      labels: chartData.labels,\r\n                      datasets: [{\r\n                        label: '총 타이핑 시간 (분)',\r\n                        data: chartData.timeData,\r\n                        backgroundColor: isDarkMode ? 'rgba(207, 102, 121, 0.7)' : 'rgba(255, 99, 132, 0.5)',\r\n                      }]\r\n                    }}\r\n                    options={getChartOptions('일별 총 타이핑 시간 (분)')}\r\n                    redraw={false}\r\n                    ref={setChartRef}\r\n                  />\r\n                </div>\r\n              </div>\r\n            </>\r\n          )}\r\n        </div>\r\n      ) : (\r\n        <p className={styles.noData}>저장된 타이핑 데이터가 없습니다.</p>\r\n      )}\r\n    </div>\r\n  );\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\TypingHistory.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\TypingMonitor.tsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'content' is defined but never used.","line":21,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":68,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":68,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":70,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":73,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":73,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":85,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":85,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":86,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":86,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'HTMLTextAreaElement' is not defined.","line":91,"column":69,"nodeType":"Identifier","messageId":"undef","endLine":91,"endColumn":88},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":101,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":101,"endColumn":15}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useState, useEffect, useCallback, useMemo } from 'react';\r\nimport styles from './TypingMonitor.module.css';\r\n\r\ninterface TypingMonitorProps {\r\n  stats: {\r\n    keyCount: number;\r\n    typingTime: number;\r\n    windowTitle: string;\r\n    browserName?: string;\r\n    totalChars?: number;\r\n    totalCharsNoSpace?: number;\r\n    totalWords?: number;\r\n    pages?: number;\r\n    accuracy?: number;\r\n  };\r\n  isTracking: boolean;\r\n  onStartTracking: () => void;\r\n  onStopTracking: () => void;\r\n  onSaveStats: (content: string) => void;\r\n}\r\n\r\n// 포맷 함수를 컴포넌트 외부로 이동하여 렌더링마다 재생성되지 않도록 함\r\nconst formatTime = (seconds: number): string => {\r\n  if (seconds < 60) return `${seconds}초`;\r\n  \r\n  const minutes = Math.floor(seconds / 60);\r\n  const remainingSeconds = seconds % 60;\r\n  \r\n  if (minutes < 60) {\r\n    return `${minutes}분 ${remainingSeconds}초`;\r\n  }\r\n  \r\n  const hours = Math.floor(minutes / 60);\r\n  const remainingMinutes = minutes % 60;\r\n  \r\n  return `${hours}시간 ${remainingMinutes}분 ${remainingSeconds}초`;\r\n};\r\n\r\n// 평균 속도 계산 함수도 외부로 이동\r\nconst getAverageSpeed = (keyCount: number, time: number): string => {\r\n  if (time <= 0) return '0 타/분';\r\n  return `${Math.round((keyCount / time) * 60)} 타/분`;\r\n};\r\n\r\nexport const TypingMonitor = React.memo(function TypingMonitor({ \r\n  stats, \r\n  isTracking, \r\n  onStartTracking, \r\n  onStopTracking,\r\n  onSaveStats\r\n}: TypingMonitorProps) {\r\n  const [description, setDescription] = useState('');\r\n  const [lastAction, setLastAction] = useState<string>('');\r\n  const [activeWebsiteTab, setActiveWebsiteTab] = useState<string>('docs');\r\n  const [activeStatsTab, setActiveStatsTab] = useState<string>('typing'); \r\n  \r\n  // 브라우저 체크 결과를 ref로 변경하여 리렌더링 방지\r\n  const browserCheckResultRef = React.useRef<{\r\n    name: string | null;\r\n    isGoogleDocs: boolean;\r\n    title: string | null;\r\n  } | null>(null);\r\n\r\n  // 브라우저 정보 확인 함수 메모이제이션\r\n  const checkBrowserInfo = useCallback(async () => {\r\n    if (window.electronAPI?.getCurrentBrowserInfo) {\r\n      try {\r\n        const info = await window.electronAPI.getCurrentBrowserInfo();\r\n        browserCheckResultRef.current = info;\r\n      } catch (error) {\r\n        console.error('브라우저 정보 확인 오류:', error);\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  // 정기적으로 브라우저 정보 업데이트 (5초 → 30초로 변경하여 부하 대폭 감소)\r\n  useEffect(() => {\r\n    if (isTracking) {\r\n      // 초기 확인\r\n      checkBrowserInfo();\r\n      \r\n      // 더 긴 간격(30초)으로 업데이트하여 리소스 사용 감소\r\n      const interval = setInterval(checkBrowserInfo, 30000);\r\n      return () => clearInterval(interval);\r\n    }\r\n  }, [isTracking, checkBrowserInfo]);\r\n\r\n  // 메모이제이션된 핸들러 함수들\r\n  const handleDescriptionChange = useCallback((e: React.ChangeEvent<HTMLTextAreaElement>) => {\r\n    setDescription(e.target.value);\r\n  }, []);\r\n\r\n  const handleSave = useCallback(() => {\r\n    onSaveStats(description);\r\n    setDescription('');\r\n    setLastAction('저장됨');\r\n    \r\n    // 2초 후 메시지 제거\r\n    setTimeout(() => {\r\n      setLastAction('');\r\n    }, 2000);\r\n  }, [description, onSaveStats]);\r\n\r\n  const handleToggleTracking = useCallback(() => {\r\n    if (isTracking) {\r\n      onStopTracking();\r\n    } else {\r\n      onStartTracking();\r\n    }\r\n  }, [isTracking, onStartTracking, onStopTracking]);\r\n\r\n  const handleWebsiteTabChange = useCallback((tab: string) => {\r\n    setActiveWebsiteTab(tab);\r\n  }, []);\r\n\r\n  const handleStatsTabChange = useCallback((tab: string) => {\r\n    setActiveStatsTab(tab);\r\n  }, []);\r\n\r\n  // 웹사이트 탭 컨텐츠 메모이제이션\r\n  const websiteTabContent = useMemo(() => {\r\n    switch (activeWebsiteTab) {\r\n      case 'docs':\r\n        return (\r\n          <div className={styles.websiteLinks}>\r\n            <a href=\"https://docs.google.com/document/\" target=\"_blank\" rel=\"noopener noreferrer\" className={styles.websiteLink}>\r\n              구글 문서 열기\r\n            </a>\r\n            <a href=\"https://docs.google.com/spreadsheets/\" target=\"_blank\" rel=\"noopener noreferrer\" className={styles.websiteLink}>\r\n              구글 스프레드시트 열기\r\n            </a>\r\n            <a href=\"https://docs.google.com/presentation/\" target=\"_blank\" rel=\"noopener noreferrer\" className={styles.websiteLink}>\r\n              구글 프레젠테이션 열기\r\n            </a>\r\n            <a href=\"https://www.notion.so/\" target=\"_blank\" rel=\"noopener noreferrer\" className={styles.websiteLink}>\r\n              Notion 열기\r\n            </a>\r\n          </div>\r\n        );\r\n      case 'office':\r\n        return (\r\n          <div className={styles.websiteLinks}>\r\n            <a href=\"https://www.office.com/launch/word\" target=\"_blank\" rel=\"noopener noreferrer\" className={styles.websiteLink}>\r\n              Word 온라인 열기\r\n            </a>\r\n            <a href=\"https://www.office.com/launch/excel\" target=\"_blank\" rel=\"noopener noreferrer\" className={styles.websiteLink}>\r\n              Excel 온라인 열기\r\n            </a>\r\n            <a href=\"https://www.office.com/launch/powerpoint\" target=\"_blank\" rel=\"noopener noreferrer\" className={styles.websiteLink}>\r\n              PowerPoint 온라인 열기\r\n            </a>\r\n            <a href=\"https://www.hancom.com/main/main.do\" target=\"_blank\" rel=\"noopener noreferrer\" className={styles.websiteLink}>\r\n              한글과컴퓨터 열기\r\n            </a>\r\n          </div>\r\n        );\r\n      case 'coding':\r\n        return (\r\n          <div className={styles.websiteLinks}>\r\n            <a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener noreferrer\" className={styles.websiteLink}>\r\n              GitHub 열기\r\n            </a>\r\n            <a href=\"https://gitlab.com/\" target=\"_blank\" rel=\"noopener noreferrer\" className={styles.websiteLink}>\r\n              GitLab 열기\r\n            </a>\r\n            <a href=\"https://codesandbox.io/\" target=\"_blank\" rel=\"noopener noreferrer\" className={styles.websiteLink}>\r\n              CodeSandbox 열기\r\n            </a>\r\n            <a href=\"https://codepen.io/\" target=\"_blank\" rel=\"noopener noreferrer\" className={styles.websiteLink}>\r\n              CodePen 열기\r\n            </a>\r\n          </div>\r\n        );\r\n      case 'sns':\r\n        return (\r\n          <div className={styles.websiteLinks}>\r\n            <a href=\"https://slack.com/\" target=\"_blank\" rel=\"noopener noreferrer\" className={styles.websiteLink}>\r\n              Slack 열기\r\n            </a>\r\n            <a href=\"https://discord.com/\" target=\"_blank\" rel=\"noopener noreferrer\" className={styles.websiteLink}>\r\n              Discord 열기\r\n            </a>\r\n            <a href=\"https://www.messenger.com/\" target=\"_blank\" rel=\"noopener noreferrer\" className={styles.websiteLink}>\r\n              Messenger 열기\r\n            </a>\r\n            <a href=\"https://mail.google.com/\" target=\"_blank\" rel=\"noopener noreferrer\" className={styles.websiteLink}>\r\n              Gmail 열기\r\n            </a>\r\n          </div>\r\n        );\r\n      default:\r\n        return null;\r\n    }\r\n  }, [activeWebsiteTab]);\r\n\r\n  // 통계 탭 컨텐츠 메모이제이션\r\n  const statsTabContent = useMemo(() => {\r\n    switch (activeStatsTab) {\r\n      case 'typing':\r\n        return (\r\n          <div className={styles.statsGroup}>\r\n            <div className={styles.statCard}>\r\n              <div className={styles.statLabel}>타자 수</div>\r\n              <div className={styles.statValue}>{stats.keyCount.toLocaleString()}</div>\r\n            </div>\r\n            \r\n            <div className={styles.statCard}>\r\n              <div className={styles.statLabel}>타이핑 시간</div>\r\n              <div className={styles.statValue}>{formatTime(stats.typingTime)}</div>\r\n            </div>\r\n            \r\n            <div className={styles.statCard}>\r\n              <div className={styles.statLabel}>평균 속도</div>\r\n              <div className={styles.statValue}>{getAverageSpeed(stats.keyCount, stats.typingTime)}</div>\r\n            </div>\r\n          </div>\r\n        );\r\n      case 'document':\r\n        return (\r\n          <div className={styles.statsGroup}>\r\n            <div className={styles.statCard}>\r\n              <div className={styles.statLabel}>페이지 수</div>\r\n              <div className={styles.statValue}>{stats.pages?.toFixed(1) || '0.0'}</div>\r\n            </div>\r\n            \r\n            <div className={styles.statCard}>\r\n              <div className={styles.statLabel}>단어 수</div>\r\n              <div className={styles.statValue}>{stats.totalWords?.toLocaleString() || '0'}</div>\r\n            </div>\r\n            \r\n            <div className={styles.statCard}>\r\n              <div className={styles.statLabel}>글자 수</div>\r\n              <div className={styles.statValue}>{stats.totalChars?.toLocaleString() || '0'}</div>\r\n            </div>\r\n          </div>\r\n        );\r\n      case 'accuracy':\r\n        return (\r\n          <div className={styles.statsGroup}>\r\n            <div className={styles.statCard}>\r\n              <div className={styles.statLabel}>글자 수 (공백 제외)</div>\r\n              <div className={styles.statValue}>{stats.totalCharsNoSpace?.toLocaleString() || '0'}</div>\r\n            </div>\r\n            \r\n            <div className={styles.statCard}>\r\n              <div className={styles.statLabel}>정확도</div>\r\n              <div className={styles.statValue}>{stats.accuracy || 100}%</div>\r\n            </div>\r\n          </div>\r\n        );\r\n      default:\r\n        return null;\r\n    }\r\n  }, [activeStatsTab, stats]);\r\n\r\n  return (\r\n    <div className={styles.container}>\r\n      <div className={styles.monitorHeader}>\r\n        <h2>타이핑 모니터링</h2>\r\n        <button \r\n          className={`${styles.trackingButton} ${isTracking ? styles.trackingActive : ''}`}\r\n          onClick={handleToggleTracking}\r\n        >\r\n          {isTracking ? '모니터링 중지' : '모니터링 시작'}\r\n        </button>\r\n      </div>\r\n\r\n      <div className={styles.statusIndicator}>\r\n        <div className={`${styles.indicator} ${isTracking ? styles.active : ''}`}></div>\r\n        <span>모니터링 상태: <strong>{isTracking ? '활성화' : '비활성화'}</strong></span>\r\n        \r\n        {lastAction && (\r\n          <div className={styles.actionFeedback}>{lastAction}</div>\r\n        )}\r\n      </div>\r\n      \r\n      <div className={styles.contentWrapper}>\r\n        <div className={styles.leftPanel}>\r\n          <div className={styles.browserStatus}>\r\n            <h3>브라우저 상태</h3>\r\n            <div className={styles.browserInfo}>\r\n              <div className={styles.browserRow}>\r\n                <span>감지된 브라우저:</span>\r\n                <span className={styles.browserValue}>\r\n                  {stats.browserName || browserCheckResultRef.current?.name || '없음'}\r\n                </span>\r\n              </div>\r\n              \r\n              <div className={styles.browserRow}>\r\n                <span>구글 문서 감지:</span>\r\n                <span className={styles.browserValue}>\r\n                  {browserCheckResultRef.current?.isGoogleDocs ? (\r\n                    <span className={styles.detectedBadge}>감지됨 ✓</span>\r\n                  ) : (\r\n                    <span className={styles.notDetectedBadge}>아님 ⨯</span>\r\n                  )}\r\n                </span>\r\n              </div>\r\n              \r\n              <div className={styles.browserRow}>\r\n                <span>현재 창:</span>\r\n                <span className={styles.browserValue} title={stats.windowTitle || browserCheckResultRef.current?.title || ''}>\r\n                  {(stats.windowTitle || browserCheckResultRef.current?.title || '없음').substring(0, 60)}\r\n                  {(stats.windowTitle || browserCheckResultRef.current?.title || '').length > 60 ? '...' : ''}\r\n                </span>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          \r\n          <div className={styles.websiteTabs}>\r\n            <div className={styles.websiteTabHeader}>\r\n              <button \r\n                className={`${styles.websiteTabButton} ${activeWebsiteTab === 'docs' ? styles.activeWebsiteTab : ''}`}\r\n                onClick={() => handleWebsiteTabChange('docs')}\r\n              >\r\n                구글 문서\r\n              </button>\r\n              <button \r\n                className={`${styles.websiteTabButton} ${activeWebsiteTab === 'office' ? styles.activeWebsiteTab : ''}`}\r\n                onClick={() => handleWebsiteTabChange('office')}\r\n              >\r\n                오피스\r\n              </button>\r\n              <button \r\n                className={`${styles.websiteTabButton} ${activeWebsiteTab === 'coding' ? styles.activeWebsiteTab : ''}`}\r\n                onClick={() => handleWebsiteTabChange('coding')}\r\n              >\r\n                코딩\r\n              </button>\r\n              <button \r\n                className={`${styles.websiteTabButton} ${activeWebsiteTab === 'sns' ? styles.activeWebsiteTab : ''}`}\r\n                onClick={() => handleWebsiteTabChange('sns')}\r\n              >\r\n                SNS/메신저\r\n              </button>\r\n            </div>\r\n            \r\n            <div className={styles.websiteTabContent}>\r\n              {websiteTabContent}\r\n            </div>\r\n          </div>\r\n        </div>\r\n        \r\n        <div className={styles.rightPanel}>\r\n          {/* 통계 패널을 탭 형식으로 변경 */}\r\n          <div className={styles.statsTabs}>\r\n            <button\r\n              className={`${styles.statsTabButton} ${activeStatsTab === 'typing' ? styles.activeStatsTab : ''}`}\r\n              onClick={() => handleStatsTabChange('typing')}\r\n            >\r\n              타이핑 정보\r\n            </button>\r\n            <button\r\n              className={`${styles.statsTabButton} ${activeStatsTab === 'document' ? styles.activeStatsTab : ''}`}\r\n              onClick={() => handleStatsTabChange('document')}\r\n            >\r\n              문서 정보\r\n            </button>\r\n            <button\r\n              className={`${styles.statsTabButton} ${activeStatsTab === 'accuracy' ? styles.activeStatsTab : ''}`}\r\n              onClick={() => handleStatsTabChange('accuracy')}\r\n            >\r\n              정확도 & 속도\r\n            </button>\r\n          </div>\r\n          \r\n          <div className={styles.statsTabContent}>\r\n            {statsTabContent}\r\n          </div>\r\n          \r\n          <div className={styles.saveSection}>\r\n            <h3>세션 저장</h3>\r\n            <p>작업한 내용에 대한 설명을 입력하세요</p>\r\n            <textarea\r\n              className={styles.descriptionInput}\r\n              value={description}\r\n              onChange={handleDescriptionChange}\r\n              placeholder=\"작업 내용 (예: 보고서 작성, 논문 작성 등)\"\r\n              rows={4}\r\n            />\r\n            <button \r\n              className={styles.saveButton} \r\n              onClick={handleSave}\r\n              disabled={stats.keyCount === 0 || !description.trim()}\r\n            >\r\n              통계 저장\r\n            </button>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n});","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\TypingStats.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\WindowControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\dialogs\\ConfirmDialog.tsx","messages":[{"ruleId":"no-undef","severity":2,"message":"'KeyboardEvent' is not defined.","line":31,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":31,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":37,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":37,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":39,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":39,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'KeyboardEvent' is not defined.","line":45,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":45,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":51,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":51,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":53,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":53,"endColumn":13}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useEffect } from 'react';\r\nimport styles from './ConfirmDialog.module.css';\r\n\r\ninterface ConfirmDialogProps {\r\n  title: string;\r\n  message: string;\r\n  isOpen: boolean;\r\n  onConfirm: () => void;\r\n  onCancel: () => void;\r\n  confirmText?: string;\r\n  cancelText?: string;\r\n  type?: 'info' | 'warning' | 'error' | 'success';\r\n  isDarkMode?: boolean;\r\n}\r\n\r\nexport const ConfirmDialog: React.FC<ConfirmDialogProps> = ({\r\n  title,\r\n  message,\r\n  isOpen,\r\n  onConfirm,\r\n  onCancel,\r\n  confirmText = '확인',\r\n  cancelText = '취소',\r\n  type = 'info',\r\n  isDarkMode = false\r\n}) => {\r\n  // ESC 키 누를 때 닫기\r\n  useEffect(() => {\r\n    const handleKeyDown = (e: KeyboardEvent) => {\r\n      if (e.key === 'Escape' && isOpen) {\r\n        onCancel();\r\n      }\r\n    };\r\n\r\n    window.addEventListener('keydown', handleKeyDown);\r\n    return () => {\r\n      window.removeEventListener('keydown', handleKeyDown);\r\n    };\r\n  }, [isOpen, onCancel]);\r\n  \r\n  // Enter 키로 확인 처리\r\n  useEffect(() => {\r\n    const handleKeyDown = (e: KeyboardEvent) => {\r\n      if (e.key === 'Enter' && isOpen) {\r\n        onConfirm();\r\n      }\r\n    };\r\n\r\n    window.addEventListener('keydown', handleKeyDown);\r\n    return () => {\r\n      window.removeEventListener('keydown', handleKeyDown);\r\n    };\r\n  }, [isOpen, onConfirm]);\r\n\r\n  if (!isOpen) return null;\r\n\r\n  return (\r\n    <div className={`${styles.overlay} ${isDarkMode ? styles.darkMode : ''}`}>\r\n      <div className={styles.dialog}>\r\n        <div className={`${styles.header} ${styles[type]}`}>\r\n          <h2>{title}</h2>\r\n          <button \r\n            className={styles.closeButton} \r\n            onClick={onCancel}\r\n            aria-label=\"닫기\"\r\n          >\r\n            ×\r\n          </button>\r\n        </div>\r\n        <div className={styles.content}>\r\n          <p className={styles.message}>{message}</p>\r\n        </div>\r\n        <div className={styles.actions}>\r\n          <button\r\n            className={`${styles.button} ${styles.cancelButton}`}\r\n            onClick={onCancel}\r\n          >\r\n            {cancelText}\r\n          </button>\r\n          <button\r\n            className={`${styles.button} ${styles.confirmButton} ${styles[type + 'Button']}`}\r\n            onClick={onConfirm}\r\n            autoFocus\r\n          >\r\n            {confirmText}\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ConfirmDialog;\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\dialogs\\SaveConfirmDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\components\\dynamic-components.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\dashboard\\page.tsx","messages":[{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":30,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":30,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":36,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":36,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":48,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":48,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":56,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":56,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":59,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":59,"endColumn":20}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { useState, useEffect } from 'react';\r\nimport { useRouter } from 'next/navigation';\r\nimport MemoryMonitor from '../components/MemoryMonitor';\r\nimport TypingStats from '../components/TypingStats';\r\nimport { useMemoryOptimizer } from '../utils/memory/hooks';\r\nimport { detectGpuCapabilities } from '../utils/gpu-detection';\r\nimport styles from './page.module.css';\r\n\r\nexport default function DashboardPage() {\r\n  const router = useRouter();\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [stats, setStats] = useState<any>(null);\r\n  const [gpuInfo, setGpuInfo] = useState<any>(null);\r\n  \r\n  // 메모리 최적화 기능 사용\r\n  const memoryOptimizer = useMemoryOptimizer({\r\n    threshold: 100,       // 100MB 이상일 때 경고\r\n    autoOptimize: true,   // 자동 최적화 활성화\r\n    showWarnings: true,   // 경고 표시\r\n    debug: false          // 디버그 모드 비활성화\r\n  });\r\n  \r\n  // 통계 데이터 가져오기\r\n  useEffect(() => {\r\n    const fetchStats = async () => {\r\n      try {\r\n        // 서버에서 통계 데이터 가져오기\r\n        const response = await fetch('/api/stats');\r\n        if (response.ok) {\r\n          const data = await response.json();\r\n          setStats(data);\r\n        }\r\n      } catch (error) {\r\n        console.error('통계 데이터 가져오기 오류:', error);\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    };\r\n    \r\n    // GPU 정보 감지\r\n    const detectGpu = async () => {\r\n      try {\r\n        const capabilities = await detectGpuCapabilities();\r\n        setGpuInfo(capabilities);\r\n      } catch (error) {\r\n        console.error('GPU 감지 오류:', error);\r\n      }\r\n    };\r\n    \r\n    fetchStats();\r\n    detectGpu();\r\n    \r\n    // 주기적 데이터 업데이트 (60초마다)\r\n    const intervalId = setInterval(fetchStats, 60000);\r\n    \r\n    return () => {\r\n      clearInterval(intervalId);\r\n    };\r\n  }, []);\r\n  \r\n  // 새 세션 시작 처리\r\n  const handleStartNewSession = () => {\r\n    router.push('/session/new');\r\n  };\r\n  \r\n  return (\r\n    <div className={styles.container}>\r\n      <section className={styles.header}>\r\n        <h1 className={styles.title}>대시보드</h1>\r\n        <p className={styles.subtitle}>타이핑 통계 및 시스템 모니터링</p>\r\n        \r\n        <button \r\n          className={styles.newSessionButton}\r\n          onClick={handleStartNewSession}\r\n        >\r\n          새 세션 시작\r\n        </button>\r\n      </section>\r\n      \r\n      <div className={styles.grid}>\r\n        <section className={styles.statsSection}>\r\n          <h2 className={styles.sectionTitle}>타이핑 통계</h2>\r\n          {isLoading ? (\r\n            <div className={styles.loading}>데이터 로딩 중...</div>\r\n          ) : (\r\n            <TypingStats data={stats} />\r\n          )}\r\n        </section>\r\n        \r\n        <section className={styles.monitoringSection}>\r\n          <h2 className={styles.sectionTitle}>시스템 모니터링</h2>\r\n          <MemoryMonitor \r\n            pollInterval={10000}     // 10초마다 갱신\r\n            historyLength={15}       // 15개 데이터 포인트 표시\r\n            showControls={true}      // 컨트롤 버튼 표시\r\n            height={250}             // 차트 높이\r\n            detailed={true}          // 상세 정보 표시\r\n          />\r\n          \r\n          {/* GPU 정보 표시 */}\r\n          {gpuInfo && (\r\n            <div className={styles.gpuInfo}>\r\n              <h3 className={styles.infoTitle}>GPU 정보</h3>\r\n              <div className={styles.infoGrid}>\r\n                <div className={styles.infoItem}>\r\n                  <span className={styles.infoLabel}>벤더:</span>\r\n                  <span className={styles.infoValue}>{gpuInfo.vendor}</span>\r\n                </div>\r\n                <div className={styles.infoItem}>\r\n                  <span className={styles.infoLabel}>렌더러:</span>\r\n                  <span className={styles.infoValue}>{gpuInfo.renderer}</span>\r\n                </div>\r\n                <div className={styles.infoItem}>\r\n                  <span className={styles.infoLabel}>하드웨어 가속:</span>\r\n                  <span className={styles.infoValue}>\r\n                    {gpuInfo.hardwareAccelerated ? '사용 가능' : '사용 불가'}\r\n                  </span>\r\n                </div>\r\n                <div className={styles.infoItem}>\r\n                  <span className={styles.infoLabel}>성능 수준:</span>\r\n                  <span className={styles.infoValue}>\r\n                    티어 {gpuInfo.gpuTier} ({\r\n                      gpuInfo.gpuTier === 0 ? '소프트웨어 렌더링' :\r\n                      gpuInfo.gpuTier === 1 ? '저사양' :\r\n                      gpuInfo.gpuTier === 2 ? '중간 사양' :\r\n                      '고사양'\r\n                    })\r\n                  </span>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          )}\r\n        </section>\r\n      </div>\r\n      \r\n      {/* 메모리 최적화 상태 및 컨트롤 */}\r\n      <section className={styles.memoryControls}>\r\n        <h3 className={styles.controlsTitle}>메모리 관리</h3>\r\n        <div className={styles.controlsGrid}>\r\n          <div className={styles.memoryStatus}>\r\n            <span className={styles.statusLabel}>현재 상태:</span>\r\n            <span className={styles.statusValue}>\r\n              {memoryOptimizer.isOptimizing ? '최적화 중...' : '준비됨'}\r\n            </span>\r\n          </div>\r\n          \r\n          <div className={styles.memoryActions}>\r\n            <button \r\n              className={styles.optimizeButton}\r\n              onClick={memoryOptimizer.optimizeMemory}\r\n              disabled={memoryOptimizer.isOptimizing}\r\n            >\r\n              메모리 최적화\r\n            </button>\r\n            \r\n            <button \r\n              className={styles.emergencyButton}\r\n              onClick={memoryOptimizer.emergencyOptimize}\r\n              disabled={memoryOptimizer.isOptimizing}\r\n            >\r\n              긴급 최적화\r\n            </button>\r\n          </div>\r\n        </div>\r\n      </section>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\global.d.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'callback' is defined but never used.","line":86,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":86,"endColumn":68},{"ruleId":"no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":86,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":86,"endColumn":59},{"ruleId":"no-unused-vars","severity":2,"message":"'callback' is defined but never used.","line":87,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":87,"endColumn":54},{"ruleId":"no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":87,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":87,"endColumn":45},{"ruleId":"no-unused-vars","severity":2,"message":"'content' is defined but never used.","line":90,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":90,"endColumn":30},{"ruleId":"no-unused-vars","severity":2,"message":"'settings' is defined but never used.","line":98,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":98,"endColumn":41},{"ruleId":"no-unused-vars","severity":2,"message":"'enabled' is defined but never used.","line":100,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":100,"endColumn":33},{"ruleId":"no-unused-vars","severity":2,"message":"'mode' is defined but never used.","line":101,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":101,"endColumn":39},{"ruleId":"no-unused-vars","severity":2,"message":"'command' is defined but never used.","line":104,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":104,"endColumn":90},{"ruleId":"no-unused-vars","severity":2,"message":"'param' is defined but never used.","line":105,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":105,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'shouldAutoStart' is defined but never used.","line":107,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":107,"endColumn":44},{"ruleId":"no-unused-vars","severity":2,"message":"'callback' is defined but never used.","line":108,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":108,"endColumn":56},{"ruleId":"no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":108,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":108,"endColumn":47},{"ruleId":"no-unused-vars","severity":2,"message":"'emergency' is defined but never used.","line":112,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":112,"endColumn":40},{"ruleId":"no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":114,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":114,"endColumn":35},{"ruleId":"no-unused-vars","severity":2,"message":"'callback' is defined but never used.","line":115,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":115,"endColumn":64},{"ruleId":"no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":115,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":115,"endColumn":55},{"ruleId":"no-unused-vars","severity":2,"message":"'callback' is defined but never used.","line":118,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":118,"endColumn":49},{"ruleId":"no-unused-vars","severity":2,"message":"'tab' is defined but never used.","line":118,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":118,"endColumn":40},{"ruleId":"no-unused-vars","severity":2,"message":"'callback' is defined but never used.","line":119,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":119,"endColumn":48},{"ruleId":"no-unused-vars","severity":2,"message":"'callback' is defined but never used.","line":121,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":121,"endColumn":57},{"ruleId":"no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":121,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":121,"endColumn":48},{"ruleId":"no-unused-vars","severity":2,"message":"'settings' is defined but never used.","line":125,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":125,"endColumn":47},{"ruleId":"no-unused-vars","severity":2,"message":"'callback' is defined but never used.","line":128,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":128,"endColumn":70},{"ruleId":"no-unused-vars","severity":2,"message":"'isBackground' is defined but never used.","line":128,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":128,"endColumn":61},{"ruleId":"no-unused-vars","severity":2,"message":"'callback' is defined but never used.","line":129,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":129,"endColumn":55},{"ruleId":"no-unused-vars","severity":2,"message":"'command' is defined but never used.","line":129,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":129,"endColumn":46},{"ruleId":"no-unused-vars","severity":2,"message":"'message' is defined but never used.","line":133,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":133,"endColumn":38},{"ruleId":"no-unused-vars","severity":2,"message":"'callback' is defined but never used.","line":141,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":141,"endColumn":71},{"ruleId":"no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":141,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":141,"endColumn":62},{"ruleId":"no-unused-vars","severity":2,"message":"'aggressive' is defined but never used.","line":184,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":184,"endColumn":44},{"ruleId":"no-unused-vars","severity":2,"message":"'emergency' is defined but never used.","line":186,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":186,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":201,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":201,"endColumn":54},{"ruleId":"no-unused-vars","severity":2,"message":"'GCResult' is defined but never used.","line":213,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":213,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GCResult' is defined but never used.","line":213,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":213,"endColumn":30},{"ruleId":"no-unused-vars","severity":2,"message":"'OptimizationResult' is defined but never used.","line":213,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":213,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'OptimizationResult' is defined but never used.","line":213,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":213,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'RestartAPI' is not defined.","line":219,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":219,"endColumn":26},{"ruleId":"no-unused-vars","severity":2,"message":"'aggressive' is defined but never used.","line":226,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":226,"endColumn":42},{"ruleId":"no-unused-vars","severity":2,"message":"'emergency' is defined but never used.","line":228,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":228,"endColumn":37},{"ruleId":"no-unused-vars","severity":2,"message":"'interval' is defined but never used.","line":229,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":229,"endColumn":51},{"ruleId":"no-unused-vars","severity":2,"message":"'threshold' is defined but never used.","line":229,"column":53,"nodeType":"Identifier","messageId":"unusedVar","endLine":229,"endColumn":71},{"ruleId":"no-undef","severity":2,"message":"'EventListenerOrEventListenerObject' is not defined.","line":271,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":271,"endColumn":46},{"ruleId":"no-undef","severity":2,"message":"'AddEventListenerOptions' is not defined.","line":272,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":272,"endColumn":46},{"ruleId":"no-unused-vars","severity":2,"message":"'info' is defined but never used.","line":277,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":277,"endColumn":41},{"ruleId":"no-redeclare","severity":2,"message":"'Window' is already defined.","line":298,"column":11,"nodeType":"Identifier","messageId":"redeclared","endLine":298,"endColumn":17},{"ruleId":"no-unused-vars","severity":2,"message":"'aggressive' is defined but never used.","line":302,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":302,"endColumn":41},{"ruleId":"no-unused-vars","severity":2,"message":"'interval' is defined but never used.","line":303,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":303,"endColumn":50},{"ruleId":"no-unused-vars","severity":2,"message":"'threshold' is defined but never used.","line":303,"column":52,"nodeType":"Identifier","messageId":"unusedVar","endLine":303,"endColumn":70},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":307,"column":36,"nodeType":"Identifier","messageId":"undef","endLine":307,"endColumn":52},{"ruleId":"no-redeclare","severity":2,"message":"'Window' is already defined.","line":324,"column":11,"nodeType":"Identifier","messageId":"redeclared","endLine":324,"endColumn":17},{"ruleId":"no-unused-vars","severity":2,"message":"'level' is defined but never used.","line":328,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":328,"endColumn":35},{"ruleId":"no-unused-vars","severity":2,"message":"'emergency' is defined but never used.","line":328,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":328,"endColumn":55},{"ruleId":"no-unused-vars","severity":2,"message":"'settings' is defined but never used.","line":330,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":330,"endColumn":33},{"ruleId":"no-unused-vars","severity":2,"message":"'functionName' is defined but never used.","line":332,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":332,"endColumn":38},{"ruleId":"no-unused-vars","severity":2,"message":"'args' is defined but never used.","line":332,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":332,"endColumn":47},{"ruleId":"no-unused-vars","severity":2,"message":"'level' is defined but never used.","line":334,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":334,"endColumn":24},{"ruleId":"no-unused-vars","severity":2,"message":"'message' is defined but never used.","line":334,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":334,"endColumn":41},{"ruleId":"no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":334,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":334,"endColumn":53},{"ruleId":"no-unused-vars","severity":2,"message":"'title' is defined but never used.","line":336,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":336,"endColumn":27},{"ruleId":"no-unused-vars","severity":2,"message":"'body' is defined but never used.","line":336,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":336,"endColumn":41},{"ruleId":"no-unused-vars","severity":2,"message":"'type' is defined but never used.","line":336,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":336,"endColumn":56},{"ruleId":"no-redeclare","severity":2,"message":"'Window' is already defined.","line":374,"column":11,"nodeType":"Identifier","messageId":"redeclared","endLine":374,"endColumn":17},{"ruleId":"no-unused-vars","severity":2,"message":"'aggressive' is defined but never used.","line":398,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":398,"endColumn":42},{"ruleId":"no-unused-vars","severity":2,"message":"'interval' is defined but never used.","line":413,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":413,"endColumn":50},{"ruleId":"no-unused-vars","severity":2,"message":"'threshold' is defined but never used.","line":413,"column":52,"nodeType":"Identifier","messageId":"unusedVar","endLine":413,"endColumn":70},{"ruleId":"no-unused-vars","severity":2,"message":"'channel' is defined but never used.","line":430,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":430,"endColumn":34},{"ruleId":"no-unused-vars","severity":2,"message":"'args' is defined but never used.","line":430,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":430,"endColumn":43},{"ruleId":"no-unused-vars","severity":2,"message":"'channel' is defined but never used.","line":431,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":431,"endColumn":37},{"ruleId":"no-unused-vars","severity":2,"message":"'func' is defined but never used.","line":431,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":431,"endColumn":69},{"ruleId":"no-unused-vars","severity":2,"message":"'args' is defined but never used.","line":431,"column":49,"nodeType":"Identifier","messageId":"unusedVar","endLine":431,"endColumn":53}],"suppressedMessages":[],"errorCount":69,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"interface TypingStatsUpdate {\r\n  keyCount: number;\r\n  typingTime: number;\r\n  windowTitle?: string;\r\n  browserName?: string;\r\n  totalChars?: number;\r\n  totalCharsNoSpace?: number;\r\n  totalWords?: number;\r\n  pages?: number;\r\n  accuracy?: number;\r\n  isTracking?: boolean; // isTracking 필드 추가\r\n}\r\n\r\ninterface RecordData {\r\n  content: string;\r\n  keyCount: number;\r\n  typingTime: number;\r\n  timestamp: string;\r\n  windowTitle?: string;\r\n  browserName?: string;\r\n  totalChars?: number;\r\n  // totalCharsNoSpace 속성은 제거\r\n  totalWords?: number;\r\n  pages?: number;\r\n  accuracy?: number;\r\n}\r\n\r\ninterface StatsSaved extends RecordData {\r\n  success: boolean;\r\n}\r\n\r\ninterface DebugInfo {\r\n  isTracking: boolean;\r\n  currentStats: {\r\n    keyCount: number;\r\n    typingTime: number;\r\n    startTime: number | null;\r\n    lastActiveTime: number | null;\r\n    currentWindow: string | null;\r\n    currentBrowser: string | null;\r\n    totalChars: number;\r\n    totalWords: number;\r\n    totalCharsNoSpace: number;\r\n    pages: number;\r\n    accuracy: number;\r\n  };\r\n  platform: string;\r\n  electronVersion: string;\r\n  nodeVersion: string;\r\n}\r\n\r\ntype WindowModeType = 'windowed' | 'fullscreen' | 'fullscreen-auto-hide';\r\n\r\ntype ProcessingModeType = 'auto' | 'normal' | 'cpu-intensive' | 'gpu-intensive';\r\n\r\ninterface TraySettings {\r\n  minimizeToTray: boolean;\r\n  showTrayNotifications: boolean;\r\n  reduceMemoryInBackground: boolean;\r\n}\r\n\r\ninterface SettingsState {\r\n  enabledCategories: {\r\n    docs: boolean;\r\n    office: boolean;\r\n    coding: boolean;\r\n    sns: boolean;\r\n  };\r\n  autoStartMonitoring: boolean;\r\n  resumeAfterIdle: boolean; // 옵셔널 제거, 필수 속성으로 변경\r\n  darkMode: boolean;\r\n  windowMode: WindowModeType;\r\n  // 트레이 관련 설정\r\n  minimizeToTray: boolean;\r\n  showTrayNotifications: boolean;\r\n  reduceMemoryInBackground: boolean;\r\n  // 미니뷰 설정\r\n  enableMiniView: boolean;\r\n  // GPU 가속 관련 설정\r\n  useHardwareAcceleration: boolean;\r\n  processingMode: ProcessingModeType;\r\n  maxMemoryThreshold: number;\r\n}\r\n\r\ninterface ElectronAPI {\r\n  onTypingStatsUpdate: (callback: (data: TypingStatsUpdate) => void) => () => void;\r\n  onStatsSaved: (callback: (data: StatsSaved) => void) => () => void;\r\n  startTracking: () => void;\r\n  stopTracking: () => void;\r\n  saveStats: (content: string) => void;\r\n  getCurrentBrowserInfo: () => Promise<{\r\n    name: string | null;\r\n    isGoogleDocs: boolean;\r\n    title: string | null;\r\n  }>;\r\n  getDebugInfo: () => Promise<DebugInfo>;\r\n  // Promise 반환 타입으로 변경\r\n  saveSettings: (settings: SettingsState) => Promise<any>;\r\n  loadSettings: () => Promise<SettingsState>;\r\n  setDarkMode: (enabled: boolean) => Promise<any>;\r\n  setWindowMode: (mode: WindowModeType) => Promise<any>;\r\n  getWindowMode: () => Promise<WindowModeType>;\r\n  windowControl: (\r\n    command: 'minimize' | 'maximize' | 'close' | 'showHeader' | 'hideHeader' | 'setTitle',\r\n    param?: string\r\n  ) => void;\r\n  checkAutoStart: (shouldAutoStart: boolean) => void;\r\n  onAutoTrackingStarted: (callback: (data: any) => void) => () => void;\r\n  \r\n  // 메모리 관련 메서드\r\n  getMemoryUsage?: () => Promise<MemoryInfo>;\r\n  optimizeMemory?: (emergency?: boolean) => Promise<any>;\r\n  requestGC?: () => Promise<any>;\r\n  rendererGCCompleted?: (data: any) => void;\r\n  onRequestGC?: (callback: (data: {emergency: boolean}) => void) => () => void;\r\n  \r\n  // 탭 전환 및 UI 상호작용 관련 메서드\r\n  onSwitchTab?: (callback: (tab: string) => void) => () => void;\r\n  onOpenSaveStatsDialog?: (callback: () => void) => () => void;\r\n  requestStatsUpdate?: () => void;\r\n  onMiniViewStatsUpdate?: (callback: (data: any) => void) => () => void;\r\n  toggleMiniView?: () => void;\r\n  \r\n  // 트레이 관련 메서드\r\n  updateTraySettings?: (settings: TraySettings) => Promise<any>;\r\n  quitApp?: () => void;\r\n  toggleWindow?: () => void;\r\n  onBackgroundModeChange?: (callback: (isBackground: boolean) => void) => () => void;\r\n  onTrayCommand?: (callback: (command: string) => void) => () => void;\r\n  \r\n  // 재시작 관련 API\r\n  restartApp: () => void;\r\n  showRestartPrompt: (message: string) => void;\r\n  closeWindow: () => void;\r\n  getDarkMode: () => Promise<boolean>;\r\n  \r\n  /**\r\n   * 재시작 로딩 상태 이벤트 수신\r\n   * @param callback 재시작 로딩 상태 변경 핸들러\r\n   */\r\n  onShowRestartLoading?: (callback: (data: RestartLoadingData) => void) => () => void;\r\n}\r\n\r\n// RestartLoadingData 인터페이스 추가\r\ninterface RestartLoadingData {\r\n  message?: string;\r\n  timeout?: number;\r\n}\r\n\r\ninterface LogEntry {\r\n  id: number;\r\n  content: string;\r\n  key_count: number;\r\n  typing_time: number;\r\n  timestamp: string;\r\n  created_at: string;\r\n  window_title?: string;\r\n  browser_name?: string;\r\n  total_chars?: number;\r\n  total_words?: number;\r\n  pages?: number;\r\n  accuracy?: number;\r\n}\r\n\r\ndeclare global {\r\n  interface Window {\r\n    electronAPI?: ElectronAPI;\r\n    electron?: ElectronAPI; // 명시적으로 추가\r\n    \r\n    // GPU 관련 전역 객체\r\n    __gpuInfo?: {\r\n      renderer?: string;\r\n      vendor?: string;\r\n      isAccelerated: () => boolean;\r\n      getGPUTier?: () => { tier: number; type: string; };\r\n      isHardwareAccelerated?: () => boolean;\r\n    };\r\n    \r\n    // 메모리 최적화 관련 전역 객체\r\n    __memoryOptimizer?: {\r\n      [key: string]: any;\r\n      getMemoryInfo?: () => any;\r\n      getMemoryUsagePercentage?: () => number;\r\n      optimizeMemory?: (aggressive: boolean) => Promise<any>;\r\n      suggestGarbageCollection?: () => void;\r\n      requestGC?: (emergency?: boolean) => Promise<any>;\r\n      determineOptimizationLevel?: () => number;\r\n      settings?: any;\r\n      cleanupPeriodicOptimization?: () => void;\r\n    };\r\n    \r\n    // GPU 가속화 관련 전역 객체\r\n    __gpuAccelerator?: {\r\n      [key: string]: any;\r\n    };\r\n  \r\n    // 리소스 최적화를 위한 전역 캐시 객체들\r\n    __objectUrls?: Map<string, string>;\r\n    __widgetCache?: Map<string, any>;\r\n    __styleCache?: Map<string, any> | Record<string, any>;\r\n    __imageResizeCache?: Map<string, HTMLImageElement>;\r\n    \r\n    // 동적 모듈 관리\r\n    _dynamicModules?: Map<string, any>;\r\n  }\r\n}\r\n\r\n/**\r\n * 전역 타입 정의 파일\r\n * Window 객체와 전역 인터페이스 확장\r\n */\r\n\r\nimport { MemoryInfo, GCResult, OptimizationResult } from '@/types/native-module';\r\n\r\n// Window 인터페이스 확장\r\ninterface Window {\r\n  // 기존 API 확장\r\n  electronAPI?: ElectronAPI;\r\n  restartAPI?: RestartAPI;\r\n  \r\n  // 네이티브 모듈 관련\r\n  __nativeBinding?: boolean;\r\n  __memoryOptimizer?: {\r\n    getMemoryInfo?: () => any;\r\n    getMemoryUsagePercentage?: () => number;\r\n    optimizeMemory?: (aggressive: boolean) => Promise<any>;\r\n    suggestGarbageCollection?: () => void;\r\n    requestGC?: (emergency?: boolean) => Promise<any>;\r\n    setupPeriodicOptimization?: (interval?: number, threshold?: number) => void;\r\n    cleanupPeriodicOptimization?: () => void;\r\n  };\r\n  \r\n  // GPU 관련\r\n  __gpuInfo?: {\r\n    isAccelerated: () => boolean;\r\n    renderer: string;\r\n    vendor: string;\r\n    getGPUTier?: () => { tier: number; type: string; };\r\n    isHardwareAccelerated?: () => boolean;\r\n  };\r\n  \r\n  // 캐시 관련\r\n  __objectUrls?: Map<string, string>;\r\n  __widgetCache?: Map<string, any>;\r\n  __styleCache?: Map<string, any> | Record<string, any>;\r\n  __imageResizeCache?: Record<string, any>;\r\n  \r\n  // GC 관련\r\n  gc?: () => void;\r\n}\r\n\r\n// 특수 캐시 확장 Window 인터페이스\r\ninterface WindowWithCache extends Window {\r\n  __cachedData?: Record<string, any>;\r\n  __bufferCache?: Record<string, ArrayBuffer>;\r\n  __memoryCache?: Map<string, any>;\r\n  __animationFrameIds?: number[];\r\n  __intervalIds?: number[];\r\n  __timeoutIds?: number[];\r\n}\r\n\r\n// 동적 모듈 인터페이스\r\ninterface DynamicModule {\r\n  lastUsed: number;\r\n  loaded: boolean;\r\n  unload: () => void;\r\n}\r\n\r\n// 이벤트 리스너 데이터 인터페이스\r\ninterface EventListenerData {\r\n  handler: EventListenerOrEventListenerObject;\r\n  options?: boolean | AddEventListenerOptions;\r\n}\r\n\r\ndeclare global {\r\n  // 전역 함수 정의\r\n  function normalizeMemoryInfo(info: any): MemoryInfo;\r\n  \r\n  // 네임스페이스 정의\r\n  namespace NodeJS {\r\n    interface Global {\r\n      gc?: () => void;\r\n    }\r\n  }\r\n}\r\n\r\n// 모듈 선언\r\ndeclare module '*.module.css' {\r\n  const classes: { [key: string]: string };\r\n  export default classes;\r\n}\r\n\r\ndeclare module '*.module.scss' {\r\n  const classes: { [key: string]: string };\r\n  export default classes;\r\n}\r\n\r\ninterface Window {\r\n  __memoryOptimizer?: {\r\n    getMemoryInfo: () => Promise<any>;\r\n    getMemoryUsagePercentage: () => Promise<number>;\r\n    optimizeMemory: (aggressive: boolean) => Promise<any>;\r\n    setupPeriodicOptimization: (interval?: number, threshold?: number) => () => void;\r\n  };\r\n  \r\n  // 캐시 관련 전역 객체들\r\n  __imageResizeCache?: Map<string, HTMLImageElement>;\r\n  __objectUrls?: Map<string, string>;\r\n  __memoryCache?: Map<string, any>;\r\n  __styleCache?: Map<string, any> | Record<string, any>;\r\n  __widgetCache?: Map<string, any>;\r\n  \r\n  // 기타 전역 객체\r\n  electronAPI?: any;\r\n  __appRecovery?: any;\r\n  __gpuAccelerator?: any;\r\n}\r\n\r\n/**\r\n * 전역 타입 정의\r\n */\r\n\r\n// window 객체 확장\r\ninterface Window {\r\n  // Electron IPC 통신\r\n  electronAPI?: {\r\n    // 메모리 최적화\r\n    optimizeMemory: (level: number, emergency: boolean) => Promise<any>;\r\n    // 설정 저장\r\n    saveSettings: (settings: any) => Promise<boolean>;\r\n    // 네이티브 기능 호출\r\n    callNative: (functionName: string, ...args: any[]) => Promise<any>;\r\n    // 로그 전송\r\n    log: (level: string, message: string, data?: any) => void;\r\n    // 알림\r\n    notify: (title: string, body: string, type?: string) => void;\r\n  };\r\n\r\n  // GPU 가속기 설정\r\n  __gpuAccelerator?: {\r\n    settings: {\r\n      useHardwareAcceleration: boolean;\r\n      processingMode: string;\r\n      optimizeForBattery: boolean;\r\n      memoryOptimization: string;\r\n      threadCount: number;\r\n    };\r\n  };\r\n\r\n  // 메모리 모니터링/최적화 설정\r\n  __memoryManager?: {\r\n    settings: {\r\n      autoOptimize: boolean;\r\n      autoOptimizeThreshold: number;\r\n      aggressiveGC: boolean;\r\n      optimizeOnIdle: boolean;\r\n      memoryLimit: number;\r\n    };\r\n    memoryInfo?: any;\r\n    lastOptimization?: number;\r\n  };\r\n\r\n  // 성능 지표\r\n  __performance?: {\r\n    metrics: Record<string, any>;\r\n    startTime: number;\r\n  };\r\n}\r\n\r\n/**\r\n * 글로벌 타입 선언\r\n */\r\n\r\ninterface Window {\r\n  /**\r\n   * GC를 직접 수행하는 함수\r\n   * 디버깅 및 테스트 목적으로만 사용해야 함\r\n   */\r\n  gc?: () => void;\r\n  \r\n  /**\r\n   * 메모리 최적화 유틸리티\r\n   */\r\n  __memoryOptimizer?: {\r\n    /**\r\n     * 현재 메모리 정보를 가져오는 함수\r\n     */\r\n    getMemoryInfo: () => Promise<any>;\r\n    \r\n    /**\r\n     * 메모리 사용량 백분율 가져오는 함수\r\n     */\r\n    getMemoryUsagePercentage: () => Promise<number>;\r\n    \r\n    /**\r\n     * 메모리 최적화 수행 함수\r\n     */\r\n    optimizeMemory: (aggressive?: boolean) => Promise<{ success: boolean }>;\r\n    \r\n    /**\r\n     * 가비지 컬렉션 제안 함수\r\n     */\r\n    suggestGarbageCollection: () => void;\r\n    \r\n    /**\r\n     * 모든 캐시 지우기 함수\r\n     */\r\n    clearAllCaches: () => boolean;\r\n    \r\n    /**\r\n     * 주기적 최적화 설정 함수\r\n     */\r\n    setupPeriodicOptimization: (interval?: number, threshold?: number) => () => void;\r\n    \r\n    /**\r\n     * 주기적 최적화 정리 함수\r\n     */\r\n    cleanupPeriodicOptimization: () => void;\r\n    \r\n    /**\r\n     * 메모리 최적화 설정\r\n     */\r\n    settings: Record<string, any>;\r\n  };\r\n  \r\n  /**\r\n   * 전자 API\r\n   */\r\n  electron?: {\r\n    sendMessage: (channel: string, ...args: any[]) => void;\r\n    receiveMessage: (channel: string, func: (...args: any[]) => void) => void;\r\n  };\r\n  \r\n  /**\r\n   * 네이티브 모듈 접근자\r\n   */\r\n  __nativeModuleCache?: {\r\n    [key: string]: any;\r\n  };\r\n}\r\n\r\n/**\r\n * 성능 메모리 타입 확장 (Chrome 브라우저용)\r\n */\r\ninterface Performance {\r\n  memory?: {\r\n    jsHeapSizeLimit: number;\r\n    totalJSHeapSize: number;\r\n    usedJSHeapSize: number;\r\n  };\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\hooks\\useAutoHideHeader.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":11,"column":37,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'MouseEvent' is not defined.","line":25,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":25,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":36,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":36,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":42,"column":40,"nodeType":"Identifier","messageId":"undef","endLine":42,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":54,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":54,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":60,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":60,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":62,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":62,"endColumn":21}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useRef, useCallback } from 'react';\r\nimport { ElectronAPI } from '../types/electron';\r\n\r\nexport interface AutoHideHeaderOptions {\r\n  windowMode: string; \r\n  electronAPI: ElectronAPI | null;\r\n}\r\n\r\nexport function useAutoHideHeader({ windowMode, electronAPI }: AutoHideHeaderOptions) {\r\n  const [isHeaderVisible, setIsHeaderVisible] = useState(true);\r\n  const autoHideTimeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n  \r\n  // 자동 숨김 기능 처리 (윈도우 기본 헤더용)\r\n  useEffect(() => {\r\n    const isAutoHideMode = windowMode === 'fullscreen-auto-hide';\r\n    \r\n    if (!isAutoHideMode) {\r\n      // 자동 숨김이 아닌 경우 항상 표시\r\n      if (electronAPI?.windowControl) {\r\n        electronAPI.windowControl('showHeader');\r\n      }\r\n      return;\r\n    }\r\n    \r\n    const handleMouseMove = (e: MouseEvent) => {\r\n      const { clientY } = e;\r\n      \r\n      // 마우스가 화면 상단 100px 이내에 있을 때 헤더 표시\r\n      if (clientY < 100) {\r\n        setIsHeaderVisible(true);\r\n        if (electronAPI?.windowControl) {\r\n          electronAPI.windowControl('showHeader');\r\n        }\r\n        \r\n        if (autoHideTimeoutRef.current) {\r\n          clearTimeout(autoHideTimeoutRef.current);\r\n          autoHideTimeoutRef.current = null;\r\n        }\r\n      } else if (clientY > 150 && isHeaderVisible) {\r\n        // 마우스가 아래로 이동했을 때 타이머 설정\r\n        if (!autoHideTimeoutRef.current) {\r\n          autoHideTimeoutRef.current = setTimeout(() => {\r\n            setIsHeaderVisible(false);\r\n            if (electronAPI?.windowControl) {\r\n              electronAPI.windowControl('hideHeader');\r\n            }\r\n            autoHideTimeoutRef.current = null;\r\n          }, 1500);\r\n        }\r\n      }\r\n    };\r\n    \r\n    // 캡처 옵션과 우선순위 높임\r\n    window.addEventListener('mousemove', handleMouseMove, { \r\n      passive: true, \r\n      capture: true \r\n    });\r\n    \r\n    return () => {\r\n      window.removeEventListener('mousemove', handleMouseMove, { capture: true });\r\n      if (autoHideTimeoutRef.current) {\r\n        clearTimeout(autoHideTimeoutRef.current);\r\n      }\r\n    };\r\n  }, [windowMode, isHeaderVisible, electronAPI]);\r\n  \r\n  // 헤더 표시/숨김 설정을 위한 함수\r\n  const setHeaderVisibility = useCallback((isVisible: boolean) => {\r\n    setIsHeaderVisible(isVisible);\r\n    if (electronAPI?.windowControl) {\r\n      electronAPI.windowControl(isVisible ? 'showHeader' : 'hideHeader');\r\n    }\r\n  }, [electronAPI]);\r\n\r\n  return {\r\n    isHeaderVisible,\r\n    setHeaderVisibility\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\hooks\\useElectronApi.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":6,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":6,"endColumn":37},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":6,"column":30,"nodeType":"MemberExpression","messageId":"unexpected","endLine":6,"endColumn":41},{"ruleId":"no-unused-vars","severity":2,"message":"'_callback' is defined but never used.","line":7,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":8,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":8,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":8,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":8,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[297,343],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":9,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":25},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":9,"column":18,"nodeType":"MemberExpression","messageId":"unexpected","endLine":9,"endColumn":29},{"ruleId":"no-unused-vars","severity":2,"message":"'_callback' is defined but never used.","line":11,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":12,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":12,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":12,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[454,493],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":13,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":13,"endColumn":25},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":13,"column":18,"nodeType":"MemberExpression","messageId":"unexpected","endLine":13,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":15,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":15,"endColumn":31},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":15,"column":24,"nodeType":"MemberExpression","messageId":"unexpected","endLine":15,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":16,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":30},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":16,"column":23,"nodeType":"MemberExpression","messageId":"unexpected","endLine":16,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":18,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":18,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":18,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":18,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[710,749],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":22,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":22,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":22,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[821,856],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":26,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":26,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":26,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":26,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[956,1002],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'WindowModeType' is not defined.","line":51,"column":54,"nodeType":"Identifier","messageId":"undef","endLine":51,"endColumn":68},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":60,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":60,"endColumn":25},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":60,"column":18,"nodeType":"MemberExpression","messageId":"unexpected","endLine":60,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":61,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":61,"endColumn":30},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":61,"column":23,"nodeType":"MemberExpression","messageId":"unexpected","endLine":61,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":64,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":64,"endColumn":28},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":64,"column":21,"nodeType":"MemberExpression","messageId":"unexpected","endLine":64,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":65,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":65,"endColumn":35},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":65,"column":28,"nodeType":"MemberExpression","messageId":"unexpected","endLine":65,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":66,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":29},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":66,"column":22,"nodeType":"MemberExpression","messageId":"unexpected","endLine":66,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":77,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":77,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":92,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":92,"endColumn":31}],"suppressedMessages":[],"errorCount":20,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\r\nimport { ElectronAPI } from '../types/electron';\r\n\r\n// 더미 일렉트론 API 생성 함수\r\nconst createDummyElectronAPI = (): ElectronAPI => ({\r\n  windowControl: (action) => console.log(`개발용 windowControl 호출: ${action}`),\r\n  onTypingStatsUpdate: (_callback) => {\r\n    console.log('개발용 onTypingStatsUpdate 리스너 등록');\r\n    return () => console.log('개발용 onTypingStatsUpdate 리스너 제거');\r\n  },\r\n  onStatsSaved: (_callback) => {\r\n    console.log('개발용 onStatsSaved 리스너 등록');\r\n    return () => console.log('개발용 onStatsSaved 리스너 제거');\r\n  },\r\n  startTracking: () => console.log('개발용 startTracking 호출'),\r\n  stopTracking: () => console.log('개발용 stopTracking 호출'),\r\n  saveStats: (data?) => {\r\n    console.log('개발용 saveStats 호출:', data);\r\n    return Promise.resolve(true);\r\n  },\r\n  loadSettings: () => {\r\n    console.log('개발용 loadSettings 호출');\r\n    return { darkMode: false, windowMode: 'normal' };\r\n  },\r\n  saveSettings: (settings) => {\r\n    console.log('개발용 saveSettings 호출:', settings);\r\n    return true;\r\n  },\r\n  getCurrentBrowserInfo: () => Promise.resolve({ name: null, isGoogleDocs: false, title: null }),\r\n  getDebugInfo: () => Promise.resolve({\r\n    isTracking: false,\r\n    currentStats: {\r\n      keyCount: 0,\r\n      typingTime: 0,\r\n      startTime: null,\r\n      lastActiveTime: null,\r\n      currentWindow: null,\r\n      currentBrowser: null,\r\n      totalChars: 0,\r\n      totalWords: 0,\r\n      totalCharsNoSpace: 0,\r\n      pages: 0,\r\n      accuracy: 100\r\n    },\r\n    platform: 'web',\r\n    electronVersion: 'N/A',\r\n    nodeVersion: 'N/A'\r\n  }),\r\n  setDarkMode: () => Promise.resolve({ success: true }),\r\n  setWindowMode: () => Promise.resolve({ success: true }),\r\n  getWindowMode: () => Promise.resolve('windowed' as WindowModeType),\r\n  checkAutoStart: () => {},\r\n  onAutoTrackingStarted: () => () => {},\r\n  onSwitchTab: () => () => {},\r\n  onOpenSaveStatsDialog: () => () => {},\r\n  requestStatsUpdate: () => {},\r\n  onMiniViewStatsUpdate: () => () => {},\r\n  toggleMiniView: () => {},\r\n  updateTraySettings: () => Promise.resolve({ success: true }),\r\n  quitApp: () => console.log('개발용 quitApp 호출'),\r\n  toggleWindow: () => console.log('개발용 toggleWindow 호출'),\r\n  onBackgroundModeChange: () => () => {},\r\n  onTrayCommand: () => () => {},\r\n  restartApp: () => console.log('개발용 restartApp 호출'),\r\n  showRestartPrompt: () => console.log('개발용 showRestartPrompt 호출'),\r\n  closeWindow: () => console.log('개발용 closeWindow 호출'),\r\n  getDarkMode: () => Promise.resolve(false)\r\n});\r\n\r\nexport function useElectronApi() {\r\n  const [api, setApi] = useState<ElectronAPI | null>(null);\r\n\r\n  useEffect(() => {\r\n    // 브라우저 환경 확인\r\n    if (typeof window !== 'undefined') {\r\n      // window 객체에 electronAPI가 있는지 확인\r\n      const electronAPI = (window as any).electronAPI as ElectronAPI | undefined;\r\n      \r\n      if (electronAPI) {\r\n        // Electron 환경에서 실행 중\r\n        setApi(electronAPI);\r\n      } else {\r\n        // 브라우저 환경에서 실행 중이므로 더미 API 생성\r\n        setApi(createDummyElectronAPI());\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  return { \r\n    electronAPI: api,\r\n    api, // 호환성을 위해 alias로도 제공\r\n    isElectron: typeof (window as any).electronAPI !== 'undefined'\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\hooks\\useMemoryManagement.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'MemoryInfo' is defined but never used.","line":4,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MemoryInfo' is defined but never used.","line":4,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":29,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":40,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":40,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":41,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":41,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":47,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":47,"endColumn":16},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":47,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":47,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1469,1553],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":57,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":57,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":67,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":67,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":68,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":68,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":70,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":22},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":70,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":70,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2499,2529],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":75,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":75,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":76,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":76,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":78,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":78,"endColumn":22},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":78,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":78,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2692,2714],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":97,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":97,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":102,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":102,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":109,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":109,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":113,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":113,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":116,"column":36,"nodeType":"Identifier","messageId":"undef","endLine":116,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":120,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":120,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":123,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":123,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":125,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":125,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":127,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":127,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":139,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":139,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":140,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":140,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":142,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":142,"endColumn":16},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":142,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":142,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4433,4463],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":148,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":148,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":150,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":150,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":152,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":152,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":152,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":152,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4620,4644],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":156,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":156,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":165,"column":46,"nodeType":"Identifier","messageId":"undef","endLine":165,"endColumn":52},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":170,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":170,"endColumn":47}],"suppressedMessages":[],"errorCount":31,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useRef, useCallback } from 'react';\r\n\r\n// Define MemoryInfo interface locally\r\ninterface MemoryInfo {\r\n  usedJSHeapSize: number;\r\n  totalJSHeapSize: number;\r\n  jsHeapSizeLimit: number;\r\n}\r\n\r\nexport interface MemoryManagementOptions {\r\n  debugMode?: boolean;\r\n  checkInterval?: number;\r\n  memoryThreshold?: number;\r\n  activeTab?: string;\r\n  onClearLogs?: () => void;\r\n}\r\n\r\n/**\r\n * 메모리 관리를 위한 커스텀 훅\r\n * 주기적으로 메모리 상태를 확인하고 필요시 정리 작업을 수행합니다.\r\n */\r\nexport function useMemoryManagement({ \r\n  debugMode = false,\r\n  checkInterval = 30000, // 기본 30초\r\n  memoryThreshold = 100, // 기본 100MB\r\n  activeTab = 'monitor',\r\n  onClearLogs = () => {}\r\n}: MemoryManagementOptions = {}) {\r\n  const intervalsRef = useRef<NodeJS.Timeout[]>([]);\r\n  const memoryWarningShownRef = useRef<boolean>(false);\r\n  const lastCleanupTimeRef = useRef<number>(0);\r\n  const CLEANUP_COOLDOWN = 60000; // 정리 작업 간 최소 시간 간격 (1분)\r\n  \r\n  // 메모리 사용량 확인 및 정리 함수\r\n  const checkMemoryUsage = useCallback(() => {\r\n    // 브라우저에서 실행 중인지 확인\r\n    if (typeof window === 'undefined') return;\r\n\r\n    // 성능 API를 통한 메모리 정보 수집\r\n    if (window.performance && (window.performance as any).memory) {\r\n      const memoryInfo = (window.performance as any).memory;\r\n      const usedHeapSize = memoryInfo.usedJSHeapSize / (1024 * 1024);\r\n      const totalHeapSize = memoryInfo.totalJSHeapSize / (1024 * 1024);\r\n      const percentUsed = (usedHeapSize / totalHeapSize) * 100;\r\n      \r\n      if (debugMode) {\r\n        console.log(`메모리 사용량: ${Math.round(usedHeapSize)}MB (${Math.round(percentUsed)}%)`);\r\n      }\r\n      \r\n      // 임계치 이상이면 불필요한 데이터 해제 (쿨다운 시간 체크)\r\n      const now = Date.now();\r\n      if (usedHeapSize > memoryThreshold && (now - lastCleanupTimeRef.current > CLEANUP_COOLDOWN)) {\r\n        lastCleanupTimeRef.current = now;\r\n        \r\n        // 경고 로그 (한 번만 표시)\r\n        if (!memoryWarningShownRef.current && debugMode) {\r\n          console.warn(`메모리 사용량 경고: ${Math.round(usedHeapSize)}MB (임계치: ${memoryThreshold}MB)`);\r\n          memoryWarningShownRef.current = true;\r\n        }\r\n        \r\n        // 필요하지 않은 큰 객체 참조 해제\r\n        if (activeTab !== 'history' && activeTab !== 'stats' && activeTab !== 'chart') {\r\n          // 로그 데이터가 필요 없는 탭에서는 메모리에서 해제\r\n          onClearLogs();\r\n          \r\n          // 자동 최적화 수행\r\n          if (typeof window.__memoryOptimizer?.optimizeMemory === 'function') {\r\n            window.__memoryOptimizer.optimizeMemory(usedHeapSize > memoryThreshold * 1.5);\r\n            if (debugMode) {\r\n              console.log('메모리 자동 최적화 수행됨');\r\n            }\r\n          }\r\n          \r\n          // GC 힌트 제공\r\n          if (window.gc) {\r\n            window.gc();\r\n            if (debugMode) {\r\n              console.log('GC 호출됨');\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      // 메모리 사용량이 임계치 아래로 내려가면 경고 상태 초기화\r\n      if (usedHeapSize < memoryThreshold * 0.8) {\r\n        memoryWarningShownRef.current = false;\r\n      }\r\n    }\r\n  }, [activeTab, debugMode, memoryThreshold, onClearLogs]);\r\n  \r\n  // 컴포넌트 마운트 시 타이머 설정\r\n  useEffect(() => {\r\n    // 초기 메모리 체크\r\n    checkMemoryUsage();\r\n    \r\n    // 주기적으로 메모리 사용량 체크\r\n    const memoryCheckInterval = setInterval(checkMemoryUsage, checkInterval);\r\n    intervalsRef.current.push(memoryCheckInterval);\r\n    \r\n    // 페이지 가시성 변경 이벤트 핸들러\r\n    const handleVisibilityChange = () => {\r\n      if (document.visibilityState === 'visible') {\r\n        // 탭이 다시 보이게 되면 메모리 체크 실행\r\n        checkMemoryUsage();\r\n      }\r\n    };\r\n    \r\n    // 이벤트 리스너 등록\r\n    document.addEventListener('visibilitychange', handleVisibilityChange);\r\n    \r\n    // 페이지 언마운트 시 정리\r\n    return () => {\r\n      clearInterval(memoryCheckInterval);\r\n      \r\n      // 등록된 모든 인터벌 제거\r\n      intervalsRef.current.forEach(clearInterval);\r\n      intervalsRef.current = [];\r\n      \r\n      // 이벤트 리스너 제거\r\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\r\n      \r\n      // 메모리 해제 요청\r\n      if (window.gc) {\r\n        try {\r\n          window.gc();\r\n        } catch (e) {\r\n          console.warn('GC 호출 실패');\r\n        }\r\n      }\r\n    };\r\n  }, [checkMemoryUsage, checkInterval]);\r\n  \r\n  // 수동으로 메모리 정리 실행 함수\r\n  const cleanupMemory = useCallback(() => {\r\n    // 브라우저 환경 확인\r\n    if (typeof window === 'undefined') return false;\r\n    \r\n    // 최적화 유틸리티 사용 시도\r\n    if (typeof window.__memoryOptimizer?.optimizeMemory === 'function') {\r\n      window.__memoryOptimizer.optimizeMemory(true);\r\n      if (debugMode) {\r\n        console.log('수동 메모리 최적화 실행됨');\r\n      }\r\n      return true;\r\n    }\r\n    \r\n    // 브라우저에 GC 권장\r\n    if (window.gc) {\r\n      try {\r\n        window.gc();\r\n        if (debugMode) {\r\n          console.log('GC 호출 성공');\r\n        }\r\n        return true;\r\n      } catch (e) {\r\n        console.warn('GC 호출 실패');\r\n        return false;\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }, [debugMode]);\r\n\r\n  // 인터벌 관리를 위한 추가 함수\r\n  const addInterval = useCallback((interval: NodeJS.Timeout) => {\r\n    intervalsRef.current.push(interval);\r\n  }, []);\r\n  \r\n  const clearIntervals = useCallback(() => {\r\n    intervalsRef.current.forEach(clearInterval);\r\n    intervalsRef.current = [];\r\n  }, []);\r\n\r\n  return {\r\n    cleanupMemory,\r\n    addInterval,\r\n    clearIntervals,\r\n    checkMemoryUsage\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\hooks\\useMemoryOptimizer.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":52,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":52,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":59,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":59,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":60,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":60,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":66,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":83,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":83,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":95,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":95,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":96,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":96,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":99,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":99,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":99,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":99,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2415,2442],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":104,"column":36,"nodeType":"Identifier","messageId":"undef","endLine":104,"endColumn":46},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":109,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":109,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":123,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":123,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":124,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":124,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":128,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":128,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":129,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":129,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":133,"column":36,"nodeType":"Identifier","messageId":"undef","endLine":133,"endColumn":46},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":142,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":142,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":154,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":154,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":158,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":158,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":163,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":163,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":168,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":168,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":170,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":170,"endColumn":15}],"suppressedMessages":[],"errorCount":21,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback, useRef } from 'react';\r\nimport { useToast } from '../components/ToastContext';\r\n\r\ninterface MemoryOptimizationOptions {\r\n  /**\r\n   * 메모리 사용량 임계치 (MB)\r\n   * 이 값을 초과하면 자동 최적화가 실행됩니다.\r\n   */\r\n  threshold?: number;\r\n  \r\n  /**\r\n   * 메모리 확인 주기 (ms)\r\n   */\r\n  checkInterval?: number;\r\n  \r\n  /**\r\n   * 경고 메시지 표시 여부\r\n   */\r\n  showWarnings?: boolean;\r\n  \r\n  /**\r\n   * 자동 최적화 활성화 여부\r\n   */\r\n  autoOptimize?: boolean;\r\n  \r\n  /**\r\n   * 디버그 모드 활성화 여부\r\n   */\r\n  debug?: boolean;\r\n}\r\n\r\n/**\r\n * 메모리 최적화 훅\r\n * \r\n * 앱의 메모리 사용량을 모니터링하고 최적화하는 훅입니다.\r\n * \r\n * @param options 메모리 최적화 옵션\r\n * @returns 메모리 정보 및 최적화 관련 함수\r\n */\r\nexport function useMemoryOptimizer(options: MemoryOptimizationOptions = {}) {\r\n  const {\r\n    threshold = 75, // 임계치를 80MB에서 75MB로 낮춤\r\n    checkInterval = 30000, // 기본 확인 주기 30초\r\n    showWarnings = true,\r\n    autoOptimize = true,\r\n    debug = false\r\n  } = options;\r\n  \r\n  const [memoryInfo, setMemoryInfo] = useState<any>(null);\r\n  const [isOptimizing, setIsOptimizing] = useState(false);\r\n  const { showToast } = useToast();\r\n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\r\n  \r\n  // 메모리 정보 갱신\r\n  const updateMemoryInfo = useCallback(() => {\r\n    try {\r\n      if (typeof window === 'undefined') return null;\r\n      \r\n      if (window.__memoryOptimizer?.getMemoryInfo) {\r\n        const info = window.__memoryOptimizer.getMemoryInfo();\r\n        setMemoryInfo(info);\r\n        \r\n        // 임계치 초과 시 처리\r\n        if (info && info.heapUsedMB > threshold) {\r\n          if (debug) {\r\n            console.warn(`메모리 사용량 경고: ${info.heapUsedMB}MB (임계치: ${threshold}MB)`);\r\n          }\r\n          \r\n          if (showWarnings) {\r\n            showToast(`메모리 사용량이 높습니다: ${Math.round(info.heapUsedMB)}MB`, 'warning');\r\n          }\r\n          \r\n          if (autoOptimize) {\r\n            optimizeMemory();\r\n          }\r\n        }\r\n        \r\n        return info;\r\n      }\r\n      \r\n      return null;\r\n    } catch (error) {\r\n      console.error('메모리 정보 갱신 중 오류:', error);\r\n      return null;\r\n    }\r\n  }, [threshold, showWarnings, autoOptimize, debug, showToast]);\r\n  \r\n  // 메모리 최적화 실행\r\n  const optimizeMemory = useCallback(async () => {\r\n    if (isOptimizing) return;\r\n    \r\n    try {\r\n      setIsOptimizing(true);\r\n      \r\n      if (window.__memoryOptimizer?.optimizeMemory) {\r\n        window.__memoryOptimizer.optimizeMemory(false);\r\n        \r\n        if (debug) {\r\n          console.log('메모리 최적화 실행됨');\r\n        }\r\n      }\r\n      \r\n      // 잠시 후 GC 요청 (브라우저에서 GC가 실행될 시간 제공)\r\n      await new Promise(resolve => setTimeout(resolve, 500));\r\n      \r\n      // 최적화 후 메모리 정보 갱신\r\n      updateMemoryInfo();\r\n    } catch (error) {\r\n      console.error('메모리 최적화 중 오류:', error);\r\n    } finally {\r\n      setIsOptimizing(false);\r\n    }\r\n  }, [isOptimizing, updateMemoryInfo, debug]);\r\n  \r\n  // 긴급 메모리 최적화 (적극적 모드)\r\n  const emergencyOptimize = useCallback(async () => {\r\n    if (isOptimizing) return;\r\n    \r\n    try {\r\n      setIsOptimizing(true);\r\n      showToast('긴급 메모리 최적화 실행 중...', 'info');\r\n      \r\n      if (window.__memoryOptimizer?.optimizeMemory) {\r\n        window.__memoryOptimizer.optimizeMemory(true); // 적극적 모드\r\n      }\r\n      \r\n      // 이미지 리소스도 최적화\r\n      if (window.__memoryOptimizer?.optimizeImageResources) {\r\n        await window.__memoryOptimizer.optimizeImageResources();\r\n      }\r\n      \r\n      // GC 실행 시간 제공\r\n      await new Promise(resolve => setTimeout(resolve, 1000));\r\n      \r\n      // 결과 확인 및 알림\r\n      const newInfo = updateMemoryInfo();\r\n      \r\n      if (newInfo && debug) {\r\n        showToast(`메모리 최적화 완료: ${Math.round(newInfo.heapUsedMB)}MB`, 'success');\r\n      }\r\n    } catch (error) {\r\n      console.error('긴급 메모리 최적화 중 오류:', error);\r\n    } finally {\r\n      setIsOptimizing(false);\r\n    }\r\n  }, [isOptimizing, updateMemoryInfo, debug, showToast]);\r\n  \r\n  // 메모리 모니터링 설정\r\n  useEffect(() => {\r\n    // 초기 메모리 정보 확인\r\n    updateMemoryInfo();\r\n    \r\n    // 주기적 메모리 확인 설정\r\n    intervalRef.current = setInterval(updateMemoryInfo, checkInterval);\r\n    \r\n    // 페이지 가시성 변경 감지\r\n    const handleVisibilityChange = () => {\r\n      if (document.visibilityState === 'visible') {\r\n        updateMemoryInfo();\r\n      }\r\n    };\r\n    \r\n    document.addEventListener('visibilitychange', handleVisibilityChange);\r\n    \r\n    // 클린업\r\n    return () => {\r\n      if (intervalRef.current) {\r\n        clearInterval(intervalRef.current);\r\n      }\r\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\r\n    };\r\n  }, [updateMemoryInfo, checkInterval]);\r\n  \r\n  return {\r\n    memoryInfo,\r\n    isOptimizing,\r\n    updateMemoryInfo,\r\n    optimizeMemory,\r\n    emergencyOptimize\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\hooks\\useNativeGpu.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":37,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":37,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":62,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":62,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":86,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":86,"endColumn":14}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback } from 'react';\r\nimport { \r\n  getGpuInfo, \r\n  setGpuAcceleration,\r\n  performGpuComputation\r\n} from '../utils/nativeModuleClient';\r\nimport type { GpuInfo, GpuComputationResult } from '@/types/native-module';\r\n\r\n/**\r\n * 네이티브 GPU 가속 훅\r\n * 네이티브 모듈을 사용한 GPU 가속 기능을 제공합니다.\r\n */\r\nexport function useNativeGpu() {\r\n  const [gpuInfo, setGpuInfo] = useState<GpuInfo | null>(null);\r\n  const [available, setAvailable] = useState<boolean>(false);\r\n  const [enabled, setEnabled] = useState<boolean>(false);\r\n  const [loading, setLoading] = useState<boolean>(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const [lastComputationResult, setLastComputationResult] = useState<GpuComputationResult | null>(null);\r\n\r\n  // GPU 정보 가져오기\r\n  const fetchGpuInfo = useCallback(async () => {\r\n    setLoading(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      const response = await getGpuInfo();\r\n      \r\n      if (response.success) {\r\n        setGpuInfo(response.gpuInfo || null);\r\n        setAvailable(response.available);\r\n        setEnabled(response.gpuInfo?.acceleration_enabled || false);\r\n      } else {\r\n        setError('GPU 정보를 가져오는데 실패했습니다.');\r\n      }\r\n    } catch (err) {\r\n      console.error('GPU 정보 가져오기 오류:', err);\r\n      setError(err instanceof Error ? err.message : '알 수 없는 오류');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, []);\r\n\r\n  // GPU 가속 활성화/비활성화\r\n  const toggleGpuAcceleration = useCallback(async (enable: boolean) => {\r\n    setLoading(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      const response = await setGpuAcceleration(enable);\r\n      \r\n      if (response.success) {\r\n        setEnabled(response.enabled);\r\n        // GPU 정보 업데이트\r\n        await fetchGpuInfo();\r\n        return response.result;\r\n      } else {\r\n        setError(response.error || 'GPU 가속 설정 변경 실패');\r\n        return false;\r\n      }\r\n    } catch (err) {\r\n      console.error('GPU 가속 변경 오류:', err);\r\n      setError(err instanceof Error ? err.message : '알 수 없는 오류');\r\n      return false;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [fetchGpuInfo]);\r\n\r\n  // GPU 계산 수행\r\n  const computeWithGpu = useCallback(async <T = any>(data: any, computationType: string) => {\r\n    setLoading(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      const response = await performGpuComputation<T>(data, computationType);\r\n      \r\n      if (response.success && response.result) {\r\n        setLastComputationResult(response.result);\r\n        return response.result;\r\n      } else {\r\n        setError(response.error || 'GPU 계산 실패');\r\n        return null;\r\n      }\r\n    } catch (err) {\r\n      console.error('GPU 계산 오류:', err);\r\n      setError(err instanceof Error ? err.message : '알 수 없는 오류');\r\n      return null;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, []);\r\n\r\n  // 초기 로드 시 GPU 정보 가져오기\r\n  useEffect(() => {\r\n    fetchGpuInfo();\r\n  }, [fetchGpuInfo]);\r\n\r\n  return {\r\n    gpuInfo,\r\n    available,\r\n    enabled,\r\n    loading,\r\n    error,\r\n    lastComputationResult,\r\n    fetchGpuInfo,\r\n    toggleGpuAcceleration,\r\n    computeWithGpu,\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\hooks\\useNativeMemory.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":27,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":27,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":40,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":61,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":61,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":82,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":82,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":93,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":93,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":97,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":97,"endColumn":31}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport { MemoryInfo, OptimizationLevel, OptimizationResult } from '../../types';\r\nimport { formatBytes } from '../utils/common-utils';\r\n\r\n/**\r\n * 네이티브 메모리 사용량 및 최적화 기능을 제공하는 Hook\r\n * \r\n * @returns 메모리 정보, 최적화 함수 및 상태값들\r\n */\r\nexport function useNativeMemory() {\r\n  const [memoryInfo, setMemoryInfo] = useState<MemoryInfo | null>(null);\r\n  const [isLoading, setIsLoading] = useState<boolean>(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const [lastOptimization, setLastOptimization] = useState<OptimizationResult | null>(null);\r\n  const [isOptimizing, setIsOptimizing] = useState<boolean>(false);\r\n\r\n  /**\r\n   * 메모리 정보를 가져옵니다.\r\n   */\r\n  const fetchMemoryInfo = useCallback(async () => {\r\n    setIsLoading(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      const response = await fetch('/api/native/memory');\r\n      if (!response.ok) {\r\n        throw new Error(`API 요청 실패: ${response.status} ${response.statusText}`);\r\n      }\r\n      \r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        setMemoryInfo(data.data);\r\n      } else {\r\n        setError(data.error || '알 수 없는 오류가 발생했습니다.');\r\n      }\r\n    } catch (err) {\r\n      console.error('메모리 정보 가져오기 실패:', err);\r\n      setError(err instanceof Error ? err.message : String(err));\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, []);\r\n\r\n  /**\r\n   * 메모리 최적화를 수행합니다.\r\n   * \r\n   * @param level - 최적화 레벨\r\n   * @param emergency - 긴급 상황 여부\r\n   */\r\n  const optimizeMemory = useCallback(async (\r\n    level: OptimizationLevel = OptimizationLevel.MEDIUM,\r\n    emergency: boolean = false\r\n  ) => {\r\n    setIsOptimizing(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      const response = await fetch('/api/native/memory', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json'\r\n        },\r\n        body: JSON.stringify({ level, emergency })\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`API 요청 실패: ${response.status} ${response.statusText}`);\r\n      }\r\n      \r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        setLastOptimization(data.result);\r\n        setMemoryInfo(data.memoryInfo);\r\n      } else {\r\n        setError(data.error || '알 수 없는 오류가 발생했습니다.');\r\n      }\r\n    } catch (err) {\r\n      console.error('메모리 최적화 실패:', err);\r\n      setError(err instanceof Error ? err.message : String(err));\r\n    } finally {\r\n      setIsOptimizing(false);\r\n    }\r\n  }, []);\r\n\r\n  // 주기적으로 메모리 정보 가져오기 (15초마다)\r\n  useEffect(() => {\r\n    fetchMemoryInfo();\r\n    \r\n    const intervalId = setInterval(() => {\r\n      fetchMemoryInfo();\r\n    }, 15000);\r\n    \r\n    return () => clearInterval(intervalId);\r\n  }, [fetchMemoryInfo]);\r\n\r\n  // 메모리 사용량 문자열 포맷\r\n  const formattedMemoryUsage = memoryInfo\r\n    ? `${formatBytes(memoryInfo.heapUsed)} / ${formatBytes(memoryInfo.heapTotal)} (${memoryInfo.percentUsed.toFixed(1)}%)`\r\n    : 'Loading...';\r\n\r\n  return {\r\n    memoryInfo,\r\n    isLoading,\r\n    error,\r\n    lastOptimization,\r\n    isOptimizing,\r\n    optimizeMemory,\r\n    fetchMemoryInfo,\r\n    formattedMemoryUsage\r\n  };\r\n}\r\n\r\nexport default useNativeMemory;\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\hooks\\useSettings.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":58,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":58,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":60,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":60,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":67,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":67,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":97,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":97,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":146,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":146,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":170,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":170,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":179,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":179,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":183,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":183,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":186,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":186,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'CustomEvent' is not defined.","line":201,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":201,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":202,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":202,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":211,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":211,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":214,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":214,"endColumn":13}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback } from 'react';\r\nimport { useToast } from '../components/ToastContext';\r\nimport { applyDarkModeToAllElements } from '../utils/darkModeUtils';\r\nimport type { ElectronAPI } from '../types/electron';\r\nimport type { WindowModeType } from '../global';\r\n\r\n// SettingsState 타입 인터페이스를 export하여 다른 파일에서 import할 수 있게 함\r\nexport interface SettingsState {\r\n  enabledCategories: {\r\n    docs: boolean;\r\n    office: boolean;\r\n    coding: boolean;\r\n    sns: boolean;\r\n  };\r\n  autoStartMonitoring: boolean;\r\n  resumeAfterIdle: boolean;\r\n  darkMode: boolean;\r\n  windowMode: WindowModeType;\r\n  minimizeToTray: boolean;\r\n  showTrayNotifications: boolean;\r\n  reduceMemoryInBackground: boolean;\r\n  enableMiniView: boolean;\r\n  useHardwareAcceleration: boolean;\r\n  processingMode: 'auto' | 'normal' | 'cpu-intensive' | 'gpu-intensive';\r\n  maxMemoryThreshold: number;\r\n}\r\n\r\n// 기본 설정 값 - GPU 및 처리 모드 추가\r\nconst defaultSettings: SettingsState = {\r\n  enabledCategories: {\r\n    docs: true,\r\n    office: true,\r\n    coding: true,\r\n    sns: true\r\n  },\r\n  autoStartMonitoring: true,\r\n  resumeAfterIdle: true, // 필수 속성으로 추가\r\n  darkMode: false,\r\n  windowMode: 'windowed',\r\n  minimizeToTray: true,\r\n  showTrayNotifications: true,\r\n  reduceMemoryInBackground: true,\r\n  enableMiniView: true,\r\n  useHardwareAcceleration: false, // GPU 하드웨어 가속 기본값 추가\r\n  processingMode: 'auto', // 처리 모드 기본값 추가\r\n  maxMemoryThreshold: 100 // 메모리 임계치 기본값\r\n};\r\n\r\nexport function useSettings(electronAPI: ElectronAPI | null) {\r\n  const [settings, setSettings] = useState<SettingsState>(defaultSettings);\r\n  const [darkMode, setDarkMode] = useState(false);\r\n  const [windowMode, setWindowMode] = useState<WindowModeType>('windowed');\r\n  const { showToast } = useToast();\r\n\r\n  // 로컬 스토리지에 설정 저장\r\n  const saveSettingsToLocalStorage = useCallback((settingsToSave: SettingsState) => {\r\n    try {\r\n      localStorage.setItem('app-settings', JSON.stringify(settingsToSave));\r\n    } catch (error) {\r\n      console.error('설정 저장 중 오류:', error);\r\n    }\r\n  }, []);\r\n\r\n  // 로컬 스토리지에서 설정 로드\r\n  const loadSettingsFromLocalStorage = useCallback(() => {\r\n    try {\r\n      const savedSettings = localStorage.getItem('app-settings');\r\n      if (savedSettings) {\r\n        const parsedSettings = JSON.parse(savedSettings) as Partial<SettingsState>;\r\n        \r\n        // 누락된 필드가 있을 경우 기본값 추가\r\n        const completeSettings: SettingsState = {\r\n          enabledCategories: {\r\n            docs: parsedSettings.enabledCategories?.docs ?? true,\r\n            office: parsedSettings.enabledCategories?.office ?? true,\r\n            coding: parsedSettings.enabledCategories?.coding ?? true,\r\n            sns: parsedSettings.enabledCategories?.sns ?? true\r\n          },\r\n          autoStartMonitoring: parsedSettings.autoStartMonitoring ?? true,\r\n          resumeAfterIdle: parsedSettings.resumeAfterIdle ?? true, // 필수 속성으로 추가\r\n          darkMode: parsedSettings.darkMode ?? false,\r\n          windowMode: parsedSettings.windowMode ?? 'windowed',\r\n          minimizeToTray: parsedSettings.minimizeToTray ?? true,\r\n          showTrayNotifications: parsedSettings.showTrayNotifications ?? true,\r\n          reduceMemoryInBackground: parsedSettings.reduceMemoryInBackground ?? true,\r\n          enableMiniView: parsedSettings.enableMiniView ?? true,\r\n          useHardwareAcceleration: parsedSettings.useHardwareAcceleration ?? false, // GPU 가속 설정 추가\r\n          processingMode: parsedSettings.processingMode ?? 'auto', // 처리 모드 설정 추가\r\n          maxMemoryThreshold: parsedSettings.maxMemoryThreshold ?? 100 // 메모리 임계치 추가\r\n        };\r\n        \r\n        setSettings(completeSettings);\r\n        setDarkMode(completeSettings.darkMode);\r\n        return completeSettings;\r\n      }\r\n    } catch (error) {\r\n      console.error('설정 로드 중 오류:', error);\r\n    }\r\n    return null;\r\n  }, []);\r\n\r\n  // 설정 저장 핸들러\r\n  const handleSaveSettings = useCallback(async (newSettings: SettingsState) => {\r\n    setSettings(newSettings);\r\n    saveSettingsToLocalStorage(newSettings);\r\n    setDarkMode(newSettings.darkMode);\r\n    \r\n    // Electron API로 설정 저장\r\n    try {\r\n      if (!electronAPI) return;\r\n      \r\n      // 옵셔널 체이닝 사용하여 saveSettings 메서드 존재 여부 확인\r\n      const savePromise = electronAPI?.saveSettings?.(newSettings);\r\n      if (savePromise instanceof Promise) {\r\n        const result = await savePromise;\r\n        \r\n        // result가 객체인 경우와 boolean인 경우 모두 처리\r\n        if (typeof result === 'object' && result !== null && 'success' in result) {\r\n          // 객체이고 success 속성이 있는 경우\r\n          const resultWithSuccess = result as { success: boolean };\r\n          if (resultWithSuccess.success) {\r\n            showToast('설정이 저장되었습니다.', 'success');\r\n          } else {\r\n            showToast('설정 저장에 실패했습니다.', 'error');\r\n          }\r\n        } else {\r\n          // 단순 boolean인 경우 (또는 다른 타입)\r\n          if (result === true || (typeof result === 'boolean' && result)) {\r\n            showToast('설정이 저장되었습니다.', 'success');\r\n          } else {\r\n            showToast('설정 저장에 실패했습니다.', 'error');\r\n          }\r\n        }\r\n      }\r\n      \r\n      // 다크 모드 적용\r\n      if (electronAPI?.setDarkMode) {\r\n        await electronAPI.setDarkMode(newSettings.darkMode);\r\n      }\r\n      \r\n      // 창 모드 적용\r\n      if (electronAPI?.setWindowMode) {\r\n        await electronAPI.setWindowMode(newSettings.windowMode);\r\n      }\r\n    } catch (error) {\r\n      console.error('Electron 설정 적용 오류:', error);\r\n      showToast('설정 적용 중 오류가 발생했습니다.', 'error');\r\n    }\r\n  }, [saveSettingsToLocalStorage, electronAPI, showToast]);\r\n\r\n  // 다크 모드 변경 핸들러\r\n  const handleDarkModeChange = useCallback((enabled: boolean) => {\r\n    setDarkMode(enabled);\r\n    \r\n    // 전역 요소에 다크 모드 적용\r\n    applyDarkModeToAllElements(enabled);\r\n    \r\n    if (electronAPI) {\r\n      electronAPI.setDarkMode(enabled);\r\n    }\r\n  }, [electronAPI]);\r\n\r\n  // 창 모드 변경 핸들러\r\n  const handleWindowModeChange = useCallback(async (mode: WindowModeType) => {\r\n    try {\r\n      setWindowMode(mode); // UI 즉시 업데이트\r\n      \r\n      if (electronAPI && typeof electronAPI.setWindowMode === 'function') {\r\n        const timeoutPromise = new Promise((_, reject) => {\r\n          setTimeout(() => reject(new Error('창 모드 변경 시간 초과')), 3000);\r\n        });\r\n        \r\n        const result = await Promise.race([\r\n          electronAPI.setWindowMode(mode),\r\n          timeoutPromise\r\n        ]) as {success: boolean, error?: string};\r\n        \r\n        if (!result.success) {\r\n          console.error(`창 모드 변경 실패: ${result.error || '알 수 없는 오류'}`);\r\n          showToast('창 모드 변경에 실패했습니다.', 'error');\r\n        }\r\n      } else {\r\n        console.warn('setWindowMode API를 사용할 수 없습니다. UI만 업데이트됩니다.');\r\n      }\r\n    } catch (error) {\r\n      console.error('창 모드 변경 중 오류:', error);\r\n      showToast('창 모드 변경 중 오류가 발생했습니다.', 'error');\r\n    }\r\n  }, [electronAPI, showToast]);\r\n\r\n  // 초기 설정 로드 및 다크모드 적용\r\n  useEffect(() => {\r\n    loadSettingsFromLocalStorage();\r\n  }, [loadSettingsFromLocalStorage]);\r\n\r\n  // 다크 모드 변경 시 전역 클래스 적용\r\n  useEffect(() => {\r\n    applyDarkModeToAllElements(darkMode);\r\n    \r\n    // 다크 모드 변경 이벤트 발생\r\n    const darkModeEvent = new CustomEvent('darkmode-changed', { detail: { darkMode } });\r\n    window.dispatchEvent(darkModeEvent);\r\n  }, [darkMode]);\r\n\r\n  // 앱이 종료되거나 페이지가 새로고침될 때 설정 저장\r\n  useEffect(() => {\r\n    const handleBeforeUnload = () => {\r\n      saveSettingsToLocalStorage(settings);\r\n    };\r\n    \r\n    window.addEventListener('beforeunload', handleBeforeUnload);\r\n    \r\n    return () => {\r\n      window.removeEventListener('beforeunload', handleBeforeUnload);\r\n    };\r\n  }, [settings, saveSettingsToLocalStorage]);\r\n\r\n  return {\r\n    settings,\r\n    darkMode,\r\n    windowMode,\r\n    handleSaveSettings,\r\n    handleDarkModeChange,\r\n    handleWindowModeChange,\r\n    loadSettingsFromLocalStorage\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\hooks\\useTabNavigation.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'electronAPI' is defined but never used.","line":14,"column":48,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":59},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'electronAPI' is defined but never used. Allowed unused args must match /^_/u.","line":14,"column":48,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":59}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useEffect } from 'react';\r\nimport { ElectronAPI } from '../types/electron';\r\n\r\n// API 인터페이스 정의 수정 - ElectronAPI와 호환되도록 변경\r\ninterface TabNavigationAPI extends Partial<ElectronAPI> {\r\n  // ElectronAPI의 모든 속성을 선택적으로 상속\r\n}\r\n\r\ninterface UseTabNavigationProps {\r\n  initialTab: string;\r\n  electronAPI?: TabNavigationAPI | null; // 옵셔널로 변경\r\n}\r\n\r\nexport function useTabNavigation({ initialTab, electronAPI }: UseTabNavigationProps) {\r\n  const [activeTab, setActiveTab] = useState(initialTab);\r\n  const [debugMode, setDebugMode] = useState(false);\r\n\r\n  // 탭 변경 핸들러\r\n  const handleTabChange = useCallback((tab: string) => {\r\n    setActiveTab(tab);\r\n  }, []);\r\n\r\n  // 디버그 모드 토글\r\n  const toggleDebugMode = useCallback(() => {\r\n    setDebugMode(prev => !prev);\r\n  }, []);\r\n\r\n  // 컴포넌트 마운트 시 실행할 코드\r\n  useEffect(() => {\r\n    // 여기에 필요한 초기화 로직 추가\r\n  }, []);\r\n\r\n  return {\r\n    activeTab,\r\n    debugMode,\r\n    handleTabChange,\r\n    toggleDebugMode\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\hooks\\useToast.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":29,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":15}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { useState, useCallback } from 'react';\r\n\r\ninterface ToastOptions {\r\n  duration?: number;\r\n  type?: 'info' | 'success' | 'warning' | 'error';\r\n}\r\n\r\ninterface Toast {\r\n  id: number;\r\n  message: string;\r\n  type: 'info' | 'success' | 'warning' | 'error';\r\n}\r\n\r\nexport function useToast() {\r\n  const [toasts, setToasts] = useState<Toast[]>([]);\r\n  \r\n  // 토스트 메시지 표시\r\n  const showToast = useCallback((message: string, options: ToastOptions = {}) => {\r\n    const id = Date.now();\r\n    const type = options.type || 'info';\r\n    const duration = options.duration || 3000;\r\n    \r\n    // 토스트 추가\r\n    setToasts(prev => [...prev, { id, message, type }]);\r\n    \r\n    // 자동 제거 타이머 설정\r\n    setTimeout(() => {\r\n      setToasts(prev => prev.filter(toast => toast.id !== id));\r\n    }, duration);\r\n    \r\n    return id;\r\n  }, []);\r\n  \r\n  // 특정 토스트 제거\r\n  const hideToast = useCallback((id: number) => {\r\n    setToasts(prev => prev.filter(toast => toast.id !== id));\r\n  }, []);\r\n  \r\n  // 모든 토스트 제거\r\n  const clearAllToasts = useCallback(() => {\r\n    setToasts([]);\r\n  }, []);\r\n  \r\n  return {\r\n    toasts,\r\n    showToast,\r\n    hideToast,\r\n    clearAllToasts\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\hooks\\useTypingStats.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":72,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":72,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":93,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":93,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":102,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":102,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":112,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":112,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":116,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":116,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":128,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":128,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":132,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":132,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":142,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":142,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":174,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":174,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":178,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":178,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":189,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":189,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":200,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":200,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":203,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":203,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":230,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":230,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":289,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":289,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":303,"column":36,"nodeType":"Identifier","messageId":"undef","endLine":303,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":321,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":321,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":323,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":323,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":325,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":325,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":325,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":325,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9088,9112],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useRef, useCallback, useEffect } from 'react';\r\nimport { useToast } from '../components/ToastContext';\r\nimport { ElectronAPI } from '../types/electron';\r\n\r\nconst MAX_LOGS_TO_LOAD = 100; // 최대 로그 수 제한\r\n\r\n// 타입 정의 추가\r\ninterface LogEntry {\r\n  id: number;\r\n  content: string;\r\n  key_count: number;\r\n  typing_time: number;\r\n  timestamp: string;\r\n  created_at: string;\r\n  is_saved?: boolean;\r\n  window_title?: string;\r\n  browser_name?: string;\r\n  total_chars?: number;\r\n  total_chars_no_space?: number;\r\n  total_words?: number;\r\n  pages?: number;\r\n  accuracy?: number;\r\n}\r\n\r\n// 통계 업데이트 인터페이스 정의 추가\r\ninterface TypingStatsUpdate {\r\n  keyCount: number;\r\n  typingTime: number;\r\n  windowTitle?: string;\r\n  browserName?: string;\r\n  totalChars?: number;\r\n  totalCharsNoSpace?: number;\r\n  totalWords?: number;\r\n  pages?: number;\r\n  accuracy?: number;\r\n}\r\n\r\n// 저장 데이터 인터페이스 정의 추가\r\ninterface RecordData {\r\n  content: string;\r\n  keyCount: number;\r\n  typingTime: string;\r\n  timestamp: string;\r\n  windowTitle?: string;\r\n  browserName?: string;\r\n  totalChars?: number;\r\n  totalWords?: number;\r\n  pages?: number;\r\n  accuracy?: number;\r\n}\r\n\r\nexport interface TypingStatsState {\r\n  keyCount: number;\r\n  typingTime: number;\r\n  windowTitle: string;\r\n  browserName: string;\r\n  totalChars: number;\r\n  totalCharsNoSpace: number;\r\n  totalWords: number;\r\n  pages: number;\r\n  accuracy: number;\r\n}\r\n\r\nexport function useTypingStats(electronAPI: ElectronAPI | null) {\r\n  // API에서 가져온 로그 데이터\r\n  const [logs, setLogs] = useState<LogEntry[]>([]);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [isTracking, setIsTracking] = useState(false);\r\n  \r\n  // 메모리 관리를 위한 ref 사용\r\n  const eventsCleanupRef = useRef<(() => void)[]>([]);\r\n  const intervalsRef = useRef<NodeJS.Timeout[]>([]);\r\n  \r\n  // 현재 통계 상태 - useRef로 관리하여 불필요한 렌더링 방지\r\n  const currentStatsRef = useRef<TypingStatsState>({\r\n    keyCount: 0,\r\n    typingTime: 0,\r\n    windowTitle: '',\r\n    browserName: '',\r\n    totalChars: 0,\r\n    totalCharsNoSpace: 0,\r\n    totalWords: 0,\r\n    pages: 0,\r\n    accuracy: 100\r\n  });\r\n  \r\n  // 화면에 표시할 통계만 useState로 관리\r\n  const [displayStats, setDisplayStats] = useState({...currentStatsRef.current});\r\n  const { showToast } = useToast();\r\n  \r\n  // 주기적으로 표시 통계 업데이트 (불필요한 렌더링 방지)\r\n  useEffect(() => {\r\n    const updateInterval = setInterval(() => {\r\n      // 변경사항이 있는 경우에만 상태 업데이트\r\n      if (JSON.stringify(currentStatsRef.current) !== JSON.stringify(displayStats)) {\r\n        setDisplayStats({...currentStatsRef.current});\r\n      }\r\n    }, 2000); // 2초마다 업데이트\r\n    \r\n    intervalsRef.current.push(updateInterval);\r\n    \r\n    return () => clearInterval(updateInterval);\r\n  }, [displayStats]);\r\n\r\n  // 통계 시작 핸들러\r\n  const handleStartTracking = useCallback(() => {\r\n    try {\r\n      if (electronAPI) {\r\n        electronAPI.startTracking?.();\r\n        setIsTracking(true);\r\n      } else {\r\n        console.warn('electronAPI가 없습니다.');\r\n        setIsTracking(true); // API가 없어도 UI는 tracking 상태 표시\r\n      }\r\n    } catch (error) {\r\n      console.error('startTracking 호출 오류:', error);\r\n      setIsTracking(true);\r\n    }\r\n  }, [electronAPI]);\r\n\r\n  // 통계 중지 핸들러\r\n  const handleStopTracking = useCallback(() => {\r\n    try {\r\n      if (electronAPI) {\r\n        electronAPI.stopTracking?.();\r\n        setIsTracking(false);\r\n      } else {\r\n        console.warn('electronAPI가 없습니다.');\r\n        setIsTracking(false);\r\n      }\r\n    } catch (error) {\r\n      console.error('stopTracking 호출 오류:', error);\r\n      setIsTracking(false);\r\n    }\r\n  }, [electronAPI]);\r\n\r\n  // 로그 데이터 로드 함수\r\n  const fetchLogs = useCallback(async (limit = MAX_LOGS_TO_LOAD) => {\r\n    try {\r\n      setIsLoading(true);\r\n      const endpoint = `/api/getLogs?limit=${limit}`;\r\n      const response = await fetch(endpoint);\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`API 요청 실패: ${response.status} ${response.statusText}`);\r\n      }\r\n      \r\n      const contentType = response.headers.get('content-type');\r\n      if (!contentType || !contentType.includes('application/json')) {\r\n        throw new Error('서버에서 잘못된 응답 형식 반환');\r\n      }\r\n      \r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        // 필요한 필드만 추출하여 메모리 최적화\r\n        const optimizedLogs = data.logs.map((log: any) => ({\r\n          id: log.id,\r\n          content: log.content,\r\n          key_count: log.key_count,\r\n          typing_time: log.typing_time,\r\n          timestamp: log.timestamp,\r\n          created_at: log.created_at,\r\n          window_title: log.window_title,\r\n          browser_name: log.browser_name,\r\n          total_chars: log.total_chars,\r\n          total_words: log.total_words,\r\n          pages: log.pages,\r\n          accuracy: log.accuracy\r\n        }));\r\n        \r\n        setLogs(optimizedLogs);\r\n      } else {\r\n        console.error('로그 불러오기 실패:', data.error);\r\n        setLogs([]);\r\n      }\r\n    } catch (error) {\r\n      console.error('로그 API 요청 오류:', error);\r\n      setLogs([]);\r\n      showToast?.('데이터 로드 중 오류가 발생했습니다', 'error');\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [showToast]);\r\n\r\n  // 데이터베이스 저장 함수\r\n  const saveToDatabase = useCallback(async (record: RecordData) => {\r\n    try {\r\n      const response = await fetch('/api/saveLogs', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify(record)\r\n      });\r\n\r\n      const result = await response.json();\r\n      \r\n      if (response.ok) {\r\n        await fetchLogs(); // 로그 다시 불러오기\r\n      } else {\r\n        console.error('저장 실패:', result.error);\r\n      }\r\n    } catch (error) {\r\n      console.error('저장 API 요청 오류:', error);\r\n    }\r\n  }, [fetchLogs]);\r\n\r\n  // 통계 저장 핸들러\r\n  const handleSaveStats = useCallback((content: string) => {\r\n    try {\r\n      if (electronAPI) {\r\n        electronAPI.saveStats?.(content);\r\n      }\r\n      \r\n      // DB에도 저장\r\n      const recordData: RecordData = {\r\n        content,\r\n        keyCount: currentStatsRef.current.keyCount,\r\n        typingTime: currentStatsRef.current.typingTime.toString(), // number를 string으로 변환\r\n        timestamp: new Date().toISOString(),\r\n        windowTitle: currentStatsRef.current.windowTitle,\r\n        browserName: currentStatsRef.current.browserName,\r\n        totalChars: currentStatsRef.current.totalChars,\r\n        totalWords: currentStatsRef.current.totalWords,\r\n        pages: currentStatsRef.current.pages,\r\n        accuracy: currentStatsRef.current.accuracy\r\n      };\r\n      \r\n      saveToDatabase(recordData);\r\n    } catch (error) {\r\n      console.error('saveStats 호출 오류:', error);\r\n      // API 호출 실패해도 데이터베이스에는 저장 시도\r\n      const recordData: RecordData = {\r\n        content,\r\n        keyCount: currentStatsRef.current.keyCount,\r\n        typingTime: currentStatsRef.current.typingTime.toString(), // number를 string으로 변환\r\n        timestamp: new Date().toISOString(),\r\n        windowTitle: currentStatsRef.current.windowTitle,\r\n        browserName: currentStatsRef.current.browserName || 'Unknown'\r\n      };\r\n      \r\n      saveToDatabase(recordData);\r\n    }\r\n  }, [electronAPI, saveToDatabase]);\r\n\r\n  // 초기화 함수\r\n  const initializeEventListeners = useCallback(() => {\r\n    if (!electronAPI) return;\r\n    \r\n    // 이벤트 리스너 설정 및 정리 함수 모음\r\n    const cleanupFunctions: (() => void)[] = [];\r\n    \r\n    // 타이핑 통계 업데이트 이벤트 리스너\r\n    if (electronAPI.onTypingStatsUpdate) {\r\n      const cleanup = electronAPI.onTypingStatsUpdate((data: TypingStatsUpdate) => {\r\n        // 통계 상태 업데이트 로직\r\n        currentStatsRef.current = {\r\n          ...currentStatsRef.current,\r\n          ...data\r\n        };\r\n      });\r\n      \r\n      cleanupFunctions.push(cleanup);\r\n    }\r\n    \r\n    // 저장된 통계 이벤트 리스너\r\n    if (electronAPI.onStatsSaved) {\r\n      const cleanup = electronAPI.onStatsSaved(() => {\r\n        // 저장 완료 후 로직\r\n        fetchLogs();\r\n      });\r\n      \r\n      cleanupFunctions.push(cleanup);\r\n    }\r\n    \r\n    // 정리 함수를 ref에 저장\r\n    eventsCleanupRef.current = cleanupFunctions;\r\n  }, [electronAPI, fetchLogs]);\r\n\r\n  // 컴포넌트 마운트 시 이벤트 리스너 설정\r\n  useEffect(() => {\r\n    initializeEventListeners();\r\n    \r\n    // 컴포넌트 언마운트 시 이벤트 리스너 정리\r\n    return () => {\r\n      eventsCleanupRef.current.forEach(cleanup => {\r\n        try {\r\n          cleanup();\r\n        } catch (error) {\r\n          console.error('이벤트 리스너 정리 오류:', error);\r\n        }\r\n      });\r\n    };\r\n  }, [initializeEventListeners]);\r\n\r\n  // 메모리 관리를 위한 정리 함수\r\n  useEffect(() => {\r\n    return () => {\r\n      // 등록된 모든 이벤트 리스너 제거\r\n      eventsCleanupRef.current.forEach(cleanup => cleanup());\r\n      eventsCleanupRef.current = [];\r\n      \r\n      // 등록된 모든 인터벌 제거\r\n      intervalsRef.current.forEach(clearInterval);\r\n      intervalsRef.current = [];\r\n      \r\n      // 대용량 객체 참조 끊기\r\n      setLogs([]);\r\n      currentStatsRef.current = {\r\n        keyCount: 0,\r\n        typingTime: 0,\r\n        windowTitle: '',\r\n        browserName: '',\r\n        totalChars: 0,\r\n        totalCharsNoSpace: 0,\r\n        totalWords: 0,\r\n        pages: 0,\r\n        accuracy: 100\r\n      };\r\n      \r\n      // 메모리 해제 요청\r\n      if (window.gc) {\r\n        try {\r\n          window.gc();\r\n        } catch (e) {\r\n          console.log('GC 호출 실패');\r\n        }\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  // 초기 로딩시 로그 데이터 가져오기\r\n  useEffect(() => {\r\n    fetchLogs();\r\n  }, [fetchLogs]);\r\n\r\n  return {\r\n    logs,\r\n    isLoading, \r\n    isTracking,\r\n    displayStats,\r\n    handleStartTracking,\r\n    handleStopTracking,\r\n    handleSaveStats,\r\n    fetchLogs,\r\n    currentStatsRef\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\mini-view\\page.tsx","messages":[{"ruleId":"no-undef","severity":2,"message":"'MouseEvent' is not defined.","line":11,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'Element' is not defined.","line":12,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":17,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":17,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":20,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":20,"endColumn":15}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useEffect } from 'react';\r\nimport MiniView from '../components/MiniView';\r\nimport { ToastProvider } from '../components/ToastContext';\r\n\r\nexport default function MiniViewPage() {\r\n  // 페이지 로드 시 웹킷 제외 영역 설정\r\n  useEffect(() => {\r\n    // 모든 클릭 이벤트 중단\r\n    const handler = (e: MouseEvent) => {\r\n      if (!e.target || !(e.target as Element).closest('.content')) {\r\n        e.stopPropagation();\r\n      }\r\n    };\r\n    \r\n    document.addEventListener('click', handler, true);\r\n    \r\n    return () => {\r\n      document.removeEventListener('click', handler, true);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <ToastProvider>\r\n      <div style={{ \r\n        width: '100vw', \r\n        height: '100vh', \r\n        overflow: 'hidden',\r\n        padding: 0,\r\n        margin: 0,\r\n        outline: 'none',\r\n        border: 'none',\r\n        WebkitUserSelect: 'none',\r\n        WebkitAppRegion: 'drag'\r\n      }}>\r\n        <style jsx global>{`\r\n          * {\r\n            outline: none !important;\r\n            -webkit-tap-highlight-color: transparent !important;\r\n            border: none !important;\r\n          }\r\n          \r\n          body, html {\r\n            -webkit-app-region: drag !important;\r\n          }\r\n          \r\n          button, img {\r\n            border: none !important;\r\n            outline: none !important;\r\n            pointer-events: none !important;\r\n          }\r\n        `}</style>\r\n        <MiniView />\r\n      </div>\r\n    </ToastProvider>\r\n  );\r\n}\r\n\r\nexport const dynamic = 'force-dynamic';\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\page.tsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'initialStats' is assigned a value but never used.","line":14,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'initialStats' is assigned a value but never used.","line":14,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'router' is assigned a value but never used.","line":22,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'router' is assigned a value but never used.","line":22,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":15}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport { useEffect, useState } from 'react';\nimport { useRouter } from 'next/navigation';\nimport HomeContent from './components/HomeContent';\nimport styles from './page.module.css';\nimport TypingAnalyzerWrapper from './components/TypingAnalyzerWrapper';\nimport type { HomeStats } from '@/types';\n\n// 'use client' 컴포넌트에서는 metadata를 export할 수 없으므로 제거\n// metadata는 layout.tsx로 이동\n\n// 초기 통계 더미 데이터\nconst initialStats: HomeStats = {\n  keyCount: 2500,\n  typingTime: 1800,\n  wpm: 42,\n  accuracy: 97.2\n};\n\nexport default function Home() {\n  const router = useRouter();\n  const [mounted, setMounted] = useState(false);\n  \n  // 컴포넌트 마운트 상태 추적\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  if (!mounted) {\n    return null;\n  }\n\n  return (\n    <main className={styles.main}>\n      <HomeContent />\n      <TypingAnalyzerWrapper />\n    </main>\n  );\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\pages\\analysis\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\pages\\debug.tsx","messages":[{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":35,"column":57,"nodeType":"Identifier","messageId":"undef","endLine":35,"endColumn":63},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":38,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":38,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":39,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":39,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":42,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":42,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":44,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":44,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":47,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":47,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":49,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":49,"endColumn":25}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { useEffect, useState } from 'react';\r\nimport styles from '../page.module.css';\r\n\r\ninterface DebugInfo {\r\n  isTracking: boolean;\r\n  currentStats: {\r\n    keyCount: number;\r\n    typingTime: number;\r\n    startTime: number | null;\r\n    lastActiveTime: number | null;\r\n    currentWindow: string | null;\r\n    currentBrowser: string | null;\r\n  };\r\n  platform: string;\r\n  electronVersion: string;\r\n  nodeVersion: string;\r\n}\r\n\r\ninterface BrowserInfo {\r\n  name: string | null;\r\n  isGoogleDocs: boolean;\r\n  title: string | null;\r\n}\r\n\r\nexport default function DebugPage() {\r\n  const [debugInfo, setDebugInfo] = useState<DebugInfo | null>(null);\r\n  const [browserInfo, setBrowserInfo] = useState<BrowserInfo | null>(null);\r\n  const [isElectron, setIsElectron] = useState(false);\r\n  const [apiMethods, setApiMethods] = useState<string[]>([]);\r\n\r\n  useEffect(() => {\r\n    const checkElectronAPI = () => {\r\n      const hasApi = typeof window !== 'undefined' && !!window.electronAPI;\r\n      setIsElectron(hasApi);\r\n      \r\n      if (hasApi && window.electronAPI) {\r\n        setApiMethods(Object.keys(window.electronAPI));\r\n        \r\n        // 디버그 정보 로드\r\n        window.electronAPI.getDebugInfo()\r\n          .then((info: DebugInfo) => setDebugInfo(info))\r\n          .catch(console.error);\r\n          \r\n        // 브라우저 정보 로드\r\n        window.electronAPI.getCurrentBrowserInfo()\r\n          .then((info: BrowserInfo) => setBrowserInfo(info))\r\n          .catch(console.error);\r\n      }\r\n    };\r\n    \r\n    checkElectronAPI();\r\n  }, []);\r\n\r\n  return (\r\n    <div className={styles.container}>\r\n      <h1>디버그 페이지</h1>\r\n      \r\n      <section>\r\n        <h2>환경 정보</h2>\r\n        <div className={styles.debugPanel}>\r\n          <p>Electron 환경: {isElectron ? '예' : '아니오'}</p>\r\n          {debugInfo && (\r\n            <>\r\n              <p>플랫폼: {debugInfo.platform}</p>\r\n              <p>Electron 버전: {debugInfo.electronVersion}</p>\r\n              <p>Node 버전: {debugInfo.nodeVersion}</p>\r\n            </>\r\n          )}\r\n        </div>\r\n      </section>\r\n      \r\n      <section>\r\n        <h2>ElectronAPI 메서드</h2>\r\n        <div className={styles.debugPanel}>\r\n          {apiMethods.length > 0 ? (\r\n            <ul>\r\n              {apiMethods.map((method) => (\r\n                <li key={method}>{method}</li>\r\n              ))}\r\n            </ul>\r\n          ) : (\r\n            <p>사용 가능한 API 메서드가 없습니다.</p>\r\n          )}\r\n        </div>\r\n      </section>\r\n      \r\n      <section>\r\n        <h2>현재 브라우저 정보</h2>\r\n        <div className={styles.debugPanel}>\r\n          {browserInfo ? (\r\n            <>\r\n              <p>브라우저 이름: {browserInfo.name || '감지되지 않음'}</p>\r\n              <p>구글 문서: {browserInfo.isGoogleDocs ? '예' : '아니오'}</p>\r\n              <p>창 제목: {browserInfo.title || 'N/A'}</p>\r\n            </>\r\n          ) : (\r\n            <p>브라우저 정보가 없습니다.</p>\r\n          )}\r\n        </div>\r\n      </section>\r\n      \r\n      <section>\r\n        <h2>추적 상태</h2>\r\n        <div className={styles.debugPanel}>\r\n          {debugInfo ? (\r\n            <>\r\n              <p>추적 중: {debugInfo.isTracking ? '예' : '아니오'}</p>\r\n              <p>키 카운트: {debugInfo.currentStats.keyCount}</p>\r\n              <p>타이핑 시간: {debugInfo.currentStats.typingTime}초</p>\r\n              <p>시작 시간: {debugInfo.currentStats.startTime ? new Date(debugInfo.currentStats.startTime).toLocaleString() : 'N/A'}</p>\r\n              <p>마지막 활성 시간: {debugInfo.currentStats.lastActiveTime ? new Date(debugInfo.currentStats.lastActiveTime).toLocaleString() : 'N/A'}</p>\r\n              <p>현재 창: {debugInfo.currentStats.currentWindow || 'N/A'}</p>\r\n              <p>현재 브라우저: {debugInfo.currentStats.currentBrowser || 'N/A'}</p>\r\n            </>\r\n          ) : (\r\n            <p>추적 정보가 없습니다.</p>\r\n          )}\r\n        </div>\r\n      </section>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\restart\\page.tsx","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":15,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":15,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":15,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":15,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[331,375],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":16,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":16,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":16,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[383,441],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":16,"column":46,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":52},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":18,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":18,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":20,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":20,"endColumn":16},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":20,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":20,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[520,643],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":21,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":21,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":26,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":26,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":26,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":26,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[688,748],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":26,"column":47,"nodeType":"Identifier","messageId":"undef","endLine":26,"endColumn":53},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":27,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":27,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":28,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":28,"endColumn":16},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":28,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":28,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[791,896],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":29,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":19}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { useEffect } from 'react';\r\nimport RestartPrompt from '../components/RestartPrompt';\r\nimport '../globals.css';\r\n\r\n/**\r\n * 재시작 안내 페이지\r\n */\r\nexport default function RestartPage() {\r\n  // 페이지 로드 시 API 사용 가능 여부 확인\r\n  useEffect(() => {\r\n    if (typeof window !== 'undefined') {\r\n      // API 사용 가능 여부 로깅\r\n      console.log('RestartPage: API 사용 가능 여부 확인');\r\n      console.log('window.restartAPI 존재:', !!window.restartAPI);\r\n      \r\n      if (window.restartAPI) {\r\n        // 사용 가능한 API 함수 로깅\r\n        console.log('사용 가능한 restartAPI 함수:', \r\n          Object.keys(window.restartAPI).map(key => `${key}`).join(', ')\r\n        );\r\n      }\r\n      \r\n      // 대체 API 확인\r\n      console.log('window.electronAPI 존재:', !!window.electronAPI);\r\n      if (window.electronAPI) {\r\n        console.log('window.electronAPI에 restartApp 존재:', \r\n          !!window.electronAPI.restartApp\r\n        );\r\n      }\r\n    }\r\n  }, []);\r\n  \r\n  return <RestartPrompt />;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\settings\\memory-settings.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":39,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":39,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":53,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":53,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":69,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":69,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":71,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":71,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":85,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":85,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":87,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":87,"endColumn":12}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 메모리 설정 관리 모듈\r\n */\r\n\r\nimport { MemorySettings, ProcessingMode } from '@/types';\r\n\r\n// 기본 메모리 설정 상수\r\nconst DEFAULT_MEMORY_SETTINGS: MemorySettings = {\r\n  preferNativeImplementation: true,\r\n  enableAutomaticFallback: true,\r\n  enableAutomaticOptimization: true,\r\n  optimizationThreshold: 200, // MB\r\n  optimizationInterval: 120000, // 2분\r\n  aggressiveGC: false,\r\n  enableLogging: false,\r\n  enablePerformanceMetrics: true,\r\n  useMemoryPool: true,\r\n  fallbackRetryDelay: 300000, // 5분\r\n  poolCleanupInterval: 180000, // 3분\r\n  processingMode: 'auto',\r\n  componentSpecificSettings: {}\r\n};\r\n\r\n// 로컬 스토리지 키 상수\r\nconst STORAGE_KEY = 'typing_stats_memory_settings';\r\n\r\n/**\r\n * 메모리 설정 로드 함수\r\n * 로컬 스토리지에서 메모리 설정을 가져오고, 없으면 기본값 반환\r\n * \r\n * @returns 로드된 메모리 설정\r\n */\r\nexport function loadMemorySettings(): MemorySettings {\r\n  if (typeof window === 'undefined') {\r\n    return DEFAULT_MEMORY_SETTINGS;\r\n  }\r\n  \r\n  try {\r\n    const savedSettings = localStorage.getItem(STORAGE_KEY);\r\n    \r\n    if (!savedSettings) {\r\n      return DEFAULT_MEMORY_SETTINGS;\r\n    }\r\n    \r\n    const parsedSettings = JSON.parse(savedSettings);\r\n    \r\n    // 기본값과 병합하여 누락된 필드가 있으면 기본값으로 채움\r\n    return {\r\n      ...DEFAULT_MEMORY_SETTINGS,\r\n      ...parsedSettings\r\n    };\r\n  } catch (error) {\r\n    console.error('메모리 설정 로드 오류:', error);\r\n    return DEFAULT_MEMORY_SETTINGS;\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 설정 저장 함수\r\n * \r\n * @param settings 저장할 메모리 설정\r\n */\r\nexport function saveMemorySettings(settings: MemorySettings): void {\r\n  if (typeof window === 'undefined') {\r\n    return;\r\n  }\r\n  \r\n  try {\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));\r\n  } catch (error) {\r\n    console.error('메모리 설정 저장 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 설정 초기화 함수\r\n * 설정을 기본값으로 되돌림\r\n */\r\nexport function resetMemorySettings(): void {\r\n  if (typeof window === 'undefined') {\r\n    return;\r\n  }\r\n  \r\n  try {\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(DEFAULT_MEMORY_SETTINGS));\r\n  } catch (error) {\r\n    console.error('메모리 설정 초기화 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 처리 모드 가져오기 (auto, normal, cpu-intensive, gpu-intensive)\r\n */\r\nexport function getProcessingMode(): ProcessingMode {\r\n  const settings = loadMemorySettings();\r\n  return settings.processingMode;\r\n}\r\n\r\n/**\r\n * 적극적 GC 활성화 여부 확인\r\n */\r\nexport function isAggressiveGCEnabled(): boolean {\r\n  const settings = loadMemorySettings();\r\n  return settings.aggressiveGC;\r\n}\r\n\r\n/**\r\n * 자동 최적화 활성화 여부 확인\r\n */\r\nexport function isAutomaticOptimizationEnabled(): boolean {\r\n  const settings = loadMemorySettings();\r\n  return settings.enableAutomaticOptimization;\r\n}\r\n\r\n/**\r\n * 최적화 임계값 가져오기 (메가바이트)\r\n */\r\nexport function getOptimizationThreshold(): number {\r\n  const settings = loadMemorySettings();\r\n  return settings.optimizationThreshold;\r\n}\r\n\r\n/**\r\n * 하드웨어 가속화 활성화 여부 확인\r\n */\r\nexport function isHardwareAccelerationEnabled(): boolean {\r\n  const settings = loadMemorySettings();\r\n  const processingMode = settings.processingMode;\r\n  \r\n  // CPU 집약적 모드에서는 하드웨어 가속을 사용하지 않음\r\n  if (processingMode === 'cpu-intensive') {\r\n    return false;\r\n  }\r\n  \r\n  // GPU 집약적 모드 또는 auto 모드에서는 하드웨어 가속 사용\r\n  return true;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\types\\electron.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\types\\electron.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'action' is defined but never used.","line":9,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":34},{"ruleId":"no-unused-vars","severity":2,"message":"'callback' is defined but never used.","line":15,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":55},{"ruleId":"no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":15,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":46},{"ruleId":"no-unused-vars","severity":2,"message":"'callback' is defined but never used.","line":16,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":48},{"ruleId":"no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":16,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":39},{"ruleId":"no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":19,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":26},{"ruleId":"no-unused-vars","severity":2,"message":"'settings' is defined but never used.","line":23,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":32},{"ruleId":"no-unused-vars","severity":2,"message":"'path' is defined but never used.","line":26,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":27},{"ruleId":"no-unused-vars","severity":2,"message":"'path' is defined but never used.","line":27,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":28},{"ruleId":"no-unused-vars","severity":2,"message":"'content' is defined but never used.","line":27,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":45},{"ruleId":"no-unused-vars","severity":2,"message":"'callback' is defined but never used.","line":30,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":56},{"ruleId":"no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":30,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":47},{"ruleId":"no-unused-vars","severity":2,"message":"'callback' is defined but never used.","line":36,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":49},{"ruleId":"no-unused-vars","severity":2,"message":"'tab' is defined but never used.","line":36,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":40},{"ruleId":"no-unused-vars","severity":2,"message":"'callback' is defined but never used.","line":37,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":37,"endColumn":48}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Electron 브릿지 API 타입 정의\r\n * \r\n * 이 인터페이스는 Electron 메인 프로세스와 렌더러 프로세스 간의\r\n * 통신에 사용되는 메서드들을 정의합니다.\r\n */\r\nexport interface ElectronAPI {\r\n  // 창 컨트롤 관련\r\n  windowControl?: (action: string) => void;\r\n  minimizeWindow?: () => void;\r\n  maximizeWindow?: () => void;\r\n  closeWindow?: () => void;\r\n  \r\n  // 타이핑 통계 관련\r\n  onTypingStatsUpdate?: (callback: (data: any) => void) => () => void;\r\n  onStatsSaved?: (callback: (data: any) => void) => () => void;\r\n  startTracking?: () => Promise<void> | void;\r\n  stopTracking?: () => Promise<void> | void;\r\n  saveStats?: (data?: any) => Promise<boolean> | void;\r\n  \r\n  // 설정 관련\r\n  loadSettings?: () => Promise<any> | any;\r\n  saveSettings?: (settings: any) => Promise<boolean> | boolean;\r\n  \r\n  // 파일 시스템 관련\r\n  readFile?: (path: string) => Promise<string> | string;\r\n  writeFile?: (path: string, content: string) => Promise<boolean> | boolean;\r\n  \r\n  // 앱 관련\r\n  onShowRestartLoading?: (callback: (data: any) => void) => () => void;\r\n  \r\n  // 기타 메서드들\r\n  [key: string]: any;\r\n\r\n  // 선택적 메서드로 추가\r\n  onSwitchTab?: (callback: (tab: string) => void) => void;\r\n  onOpenSaveStatsDialog?: (callback: () => void) => void;\r\n}\r\n\r\n/**\r\n * 재시작 관련 API 타입 정의\r\n * \r\n * 앱 재시작 관련 기능들을 제공하는 인터페이스입니다.\r\n */\r\nexport interface RestartAPI {\r\n  /**\r\n   * 앱 재시작 실행\r\n   */\r\n  restartApp: () => void;\r\n  \r\n  /**\r\n   * 현재 창 닫기\r\n   */\r\n  closeWindow: () => void;\r\n  \r\n  /**\r\n   * 다크 모드 설정 가져오기\r\n   * @returns 다크 모드 활성화 여부\r\n   */\r\n  getDarkMode: () => Promise<boolean>;\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\TypingSpeedCalculator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\api-utils.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'RequestCredentials' is not defined.","line":23,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":23,"endColumn":51},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":38,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":38,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":75,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":75,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":86,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":86,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":86,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":86,"endColumn":35}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * API 관련 유틸리티 함수들\r\n */\r\n\r\n/**\r\n * API 요청에 사용할 기본 헤더\r\n */\r\nexport const DEFAULT_HEADERS = {\r\n  'Content-Type': 'application/json',\r\n  'Accept': 'application/json',\r\n};\r\n\r\n/**\r\n * API 요청에 적용할 타임아웃(ms)\r\n */\r\nexport const API_TIMEOUT = 30000; // 30초\r\n\r\n/**\r\n * API 요청을 위한 기본 옵션\r\n */\r\nexport const API_DEFAULT_OPTIONS = {\r\n  headers: DEFAULT_HEADERS,\r\n  credentials: 'same-origin' as RequestCredentials,\r\n};\r\n\r\n/**\r\n * API 요청에 타임아웃을 적용하는 래퍼 함수\r\n * @param promise API 요청 Promise\r\n * @param timeout 타임아웃(ms)\r\n */\r\nexport function withTimeout<T>(\r\n  promise: Promise<T>,\r\n  timeout: number = API_TIMEOUT\r\n): Promise<T> {\r\n  return Promise.race([\r\n    promise,\r\n    new Promise<T>((_, reject) => {\r\n      setTimeout(() => reject(new Error('Request timeout')), timeout);\r\n    }),\r\n  ]);\r\n}\r\n\r\n/**\r\n * API 요청 에러 처리 함수\r\n * @param error API 요청 중 발생한 에러\r\n */\r\nexport function handleApiError(error: unknown): { message: string; status?: number } {\r\n  if (error instanceof Error) {\r\n    return { message: error.message };\r\n  }\r\n  \r\n  if (typeof error === 'string') {\r\n    return { message: error };\r\n  }\r\n  \r\n  return { message: 'Unknown API error' };\r\n}\r\n\r\n/**\r\n * 요청 재시도 함수\r\n * @param fn 실행할 함수\r\n * @param retries 재시도 횟수\r\n * @param delay 재시도 간격(ms)\r\n */\r\nexport async function retry<T>(\r\n  fn: () => Promise<T>,\r\n  retries: number = 3,\r\n  delay: number = 1000\r\n): Promise<T> {\r\n  try {\r\n    return await fn();\r\n  } catch (error) {\r\n    if (retries <= 1) throw error;\r\n    \r\n    await new Promise(resolve => setTimeout(resolve, delay));\r\n    return retry(fn, retries - 1, delay);\r\n  }\r\n}\r\n\r\n/**\r\n * API 엔드포인트 URL 생성 함수\r\n * @param path API 경로\r\n * @param params 쿼리 파라미터\r\n */\r\nexport function createApiUrl(path: string, params?: Record<string, string>): string {\r\n  const url = new URL(path, window.location.origin);\r\n  \r\n  if (params) {\r\n    Object.entries(params).forEach(([key, value]) => {\r\n      url.searchParams.append(key, value);\r\n    });\r\n  }\r\n  \r\n  return url.toString();\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\cache-utils.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":122,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":122,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":124,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":124,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":136,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":136,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":143,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":143,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":149,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":149,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":163,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":163,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":165,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":165,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":177,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":177,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":183,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":183,"endColumn":12}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 캐시 관련 유틸리티 함수들\r\n */\r\n\r\n/**\r\n * 메모리 캐시 클래스\r\n */\r\nexport class MemoryCache<T> {\r\n  private cache: Map<string, { value: T; expires?: number }>;\r\n  private maxSize: number;\r\n  \r\n  constructor(maxSize: number = 100) {\r\n    this.cache = new Map();\r\n    this.maxSize = maxSize;\r\n  }\r\n  \r\n  /**\r\n   * 캐시에 항목 저장\r\n   * @param key 캐시 키\r\n   * @param value 저장할 값\r\n   * @param ttl 유효 시간(초)\r\n   */\r\n  set(key: string, value: T, ttl?: number): void {\r\n    // 캐시가 최대 크기에 도달한 경우 가장 오래된 항목 제거\r\n    if (this.cache.size >= this.maxSize) {\r\n      const oldestKey = this.cache.keys().next().value;\r\n      this.cache.delete(oldestKey);\r\n    }\r\n    \r\n    this.cache.set(key, {\r\n      value,\r\n      expires: ttl ? Date.now() + ttl * 1000 : undefined\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * 캐시에서 항목 가져오기\r\n   * @param key 캐시 키\r\n   */\r\n  get(key: string): T | undefined {\r\n    const item = this.cache.get(key);\r\n    \r\n    if (!item) return undefined;\r\n    \r\n    // 만료 시간 확인\r\n    if (item.expires && item.expires < Date.now()) {\r\n      this.cache.delete(key);\r\n      return undefined;\r\n    }\r\n    \r\n    return item.value;\r\n  }\r\n  \r\n  /**\r\n   * 캐시에 키가 존재하는지 확인\r\n   * @param key 캐시 키\r\n   */\r\n  has(key: string): boolean {\r\n    const item = this.cache.get(key);\r\n    \r\n    if (!item) return false;\r\n    \r\n    // 만료 시간 확인\r\n    if (item.expires && item.expires < Date.now()) {\r\n      this.cache.delete(key);\r\n      return false;\r\n    }\r\n    \r\n    return true;\r\n  }\r\n  \r\n  /**\r\n   * 캐시에서 항목 삭제\r\n   * @param key 캐시 키\r\n   */\r\n  delete(key: string): boolean {\r\n    return this.cache.delete(key);\r\n  }\r\n  \r\n  /**\r\n   * 모든 캐시 항목 삭제\r\n   */\r\n  clear(): void {\r\n    this.cache.clear();\r\n  }\r\n  \r\n  /**\r\n   * 만료된 모든 항목 삭제\r\n   */\r\n  cleanup(): void {\r\n    const now = Date.now();\r\n    for (const [key, item] of this.cache.entries()) {\r\n      if (item.expires && item.expires < now) {\r\n        this.cache.delete(key);\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 캐시 크기 가져오기\r\n   */\r\n  size(): number {\r\n    return this.cache.size;\r\n  }\r\n}\r\n\r\n/**\r\n * 로컬 스토리지 캐시 함수\r\n * @param key 캐시 키\r\n * @param value 저장할 값\r\n * @param ttl 유효 시간(초)\r\n */\r\nexport function setLocalStorage(key: string, value: unknown, ttl?: number): void {\r\n  if (typeof window === 'undefined') return;\r\n  \r\n  const item = {\r\n    value,\r\n    expires: ttl ? Date.now() + ttl * 1000 : undefined\r\n  };\r\n  \r\n  try {\r\n    localStorage.setItem(key, JSON.stringify(item));\r\n  } catch (e) {\r\n    console.error('로컬 스토리지 캐시 저장 오류:', e);\r\n  }\r\n}\r\n\r\n/**\r\n * 로컬 스토리지에서 항목 가져오기\r\n * @param key 캐시 키\r\n */\r\nexport function getLocalStorage<T>(key: string): T | null {\r\n  if (typeof window === 'undefined') return null;\r\n  \r\n  try {\r\n    const itemStr = localStorage.getItem(key);\r\n    if (!itemStr) return null;\r\n    \r\n    const item = JSON.parse(itemStr);\r\n    \r\n    // 만료 시간 확인\r\n    if (item.expires && item.expires < Date.now()) {\r\n      localStorage.removeItem(key);\r\n      return null;\r\n    }\r\n    \r\n    return item.value as T;\r\n  } catch (e) {\r\n    console.error('로컬 스토리지 캐시 조회 오류:', e);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * 세션 스토리지 캐시 함수\r\n * @param key 캐시 키\r\n * @param value 저장할 값\r\n */\r\nexport function setSessionStorage(key: string, value: unknown): void {\r\n  if (typeof window === 'undefined') return;\r\n  \r\n  try {\r\n    sessionStorage.setItem(key, JSON.stringify({ value }));\r\n  } catch (e) {\r\n    console.error('세션 스토리지 캐시 저장 오류:', e);\r\n  }\r\n}\r\n\r\n/**\r\n * 세션 스토리지에서 항목 가져오기\r\n * @param key 캐시 키\r\n */\r\nexport function getSessionStorage<T>(key: string): T | null {\r\n  if (typeof window === 'undefined') return null;\r\n  \r\n  try {\r\n    const itemStr = sessionStorage.getItem(key);\r\n    if (!itemStr) return null;\r\n    \r\n    const { value } = JSON.parse(itemStr);\r\n    return value as T;\r\n  } catch (e) {\r\n    console.error('세션 스토리지 캐시 조회 오류:', e);\r\n    return null;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\common-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\darkModeUtils.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":6,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":6,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":7,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":7,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":10,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":10,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":14,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":14,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":15,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":15,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":18,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":18,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":29,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":16}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 다크 모드 클래스를 전역 요소에 적용하는 함수\r\n */\r\nexport function applyDarkModeToAllElements(isDark: boolean) {\r\n  if (isDark) {\r\n    document.body.classList.add('dark-mode');\r\n    document.documentElement.classList.add('dark-mode');\r\n    \r\n    // 주요 컨테이너에도 클래스 추가\r\n    document.querySelectorAll('.tab-content, .chart-container, .history-table').forEach(el => {\r\n      el.classList.add('dark-mode');\r\n    });\r\n  } else {\r\n    document.body.classList.remove('dark-mode');\r\n    document.documentElement.classList.remove('dark-mode');\r\n    \r\n    // 주요 컨테이너에서도 클래스 제거\r\n    document.querySelectorAll('.tab-content, .chart-container, .history-table').forEach(el => {\r\n      el.classList.remove('dark-mode');\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * 현재 시스템이 다크 모드인지 확인하는 함수\r\n */\r\nexport function isSystemInDarkMode(): boolean {\r\n  if (typeof window === 'undefined') return false;\r\n  return window.matchMedia('(prefers-color-scheme: dark)').matches;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\date-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\enum-converters.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'AppOptimizationLevel' is defined but never used.","line":4,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AppOptimizationLevel' is defined but never used.","line":4,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":51},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":38,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":38,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":202,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":202,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":218,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":218,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":236,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":236,"endColumn":14}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 최적화 레벨 열거형 변환 유틸리티\r\n */\r\nimport { OptimizationLevel as AppOptimizationLevel } from '@/types';\r\nimport { OptimizationLevel as NativeOptimizationLevel } from '@/types/native-module';\r\nimport { \r\n  OptimizationLevel, \r\n  MemoryEventType, \r\n  MemoryUsageLevel,\r\n  GpuTaskType\r\n} from '@/types';\r\n\r\n/**\r\n * 최적화 레벨 문자열을 열거형으로 변환\r\n * @param level 레벨 문자열 또는 숫자\r\n */\r\nexport function parseOptimizationLevel(level: string | number): OptimizationLevel {\r\n  if (typeof level === 'number') {\r\n    if (level >= 0 && level <= 4) {\r\n      return level as OptimizationLevel;\r\n    }\r\n    return OptimizationLevel.NORMAL;\r\n  }\r\n  \r\n  switch (level.toLowerCase()) {\r\n    case 'normal':\r\n      return OptimizationLevel.NORMAL;\r\n    case 'low':\r\n      return OptimizationLevel.LOW;\r\n    case 'medium':\r\n      return OptimizationLevel.MEDIUM;\r\n    case 'high':\r\n      return OptimizationLevel.HIGH;\r\n    case 'critical':\r\n      return OptimizationLevel.CRITICAL;\r\n    default:\r\n      // 숫자 문자열인 경우 변환 시도\r\n      const num = parseInt(level, 10);\r\n      if (!isNaN(num) && num >= 0 && num <= 4) {\r\n        return num as OptimizationLevel;\r\n      }\r\n      return OptimizationLevel.NORMAL;\r\n  }\r\n}\r\n\r\n/**\r\n * 최적화 레벨을 사람이 읽기 쉬운 문자열로 변환\r\n * @param level 최적화 레벨\r\n */\r\nexport function formatOptimizationLevel(level: OptimizationLevel): string {\r\n  switch (level) {\r\n    case OptimizationLevel.NORMAL:\r\n      return '일반';\r\n    case OptimizationLevel.LOW:\r\n      return '낮음';\r\n    case OptimizationLevel.MEDIUM:\r\n      return '중간';\r\n    case OptimizationLevel.HIGH:\r\n      return '높음';\r\n    case OptimizationLevel.CRITICAL:\r\n      return '위험';\r\n    default:\r\n      return '알 수 없음';\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 이벤트 타입을 사람이 읽기 쉬운 문자열로 변환\r\n * @param eventType 메모리 이벤트 타입\r\n */\r\nexport function formatMemoryEventType(eventType: MemoryEventType): string {\r\n  switch (eventType) {\r\n    case MemoryEventType.PERIODIC_CHECK:\r\n      return '주기적 확인';\r\n    case MemoryEventType.PAGE_NAVIGATION:\r\n      return '페이지 탐색';\r\n    case MemoryEventType.OPTIMIZATION:\r\n      return '최적화';\r\n    case MemoryEventType.COMPONENT_MOUNT:\r\n      return '컴포넌트 마운트';\r\n    case MemoryEventType.COMPONENT_UNMOUNT:\r\n      return '컴포넌트 언마운트';\r\n    case MemoryEventType.USER_ACTION:\r\n      return '사용자 액션';\r\n    case MemoryEventType.GARBAGE_COLLECTION:\r\n      return '가비지 컬렉션';\r\n    case MemoryEventType.RESOURCE_LOADING:\r\n      return '리소스 로딩';\r\n    case MemoryEventType.ERROR:\r\n      return '오류';\r\n    case MemoryEventType.WARNING:\r\n      return '경고';\r\n    case MemoryEventType.CUSTOM:\r\n      return '사용자 정의';\r\n    default:\r\n      return '알 수 없음';\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 작업 타입을 확인하고 표준화\r\n * @param taskType 작업 타입 문자열 또는 열거형\r\n */\r\nexport function normalizeGpuTaskType(taskType: string | GpuTaskType): string {\r\n  if (typeof taskType === 'number') {\r\n    // 열거형에서 문자열로 변환\r\n    switch (taskType) {\r\n      case GpuTaskType.MATRIX_MULTIPLICATION:\r\n        return 'matrix';\r\n      case GpuTaskType.TEXT_ANALYSIS:\r\n        return 'text';\r\n      case GpuTaskType.PATTERN_DETECTION:\r\n        return 'pattern';\r\n      case GpuTaskType.IMAGE_PROCESSING:\r\n        return 'image';\r\n      case GpuTaskType.DATA_AGGREGATION:\r\n        return 'data';\r\n      case GpuTaskType.TYPING_STATISTICS:\r\n        return 'typing';\r\n      case GpuTaskType.CUSTOM:\r\n        return 'custom';\r\n      default:\r\n        return 'matrix'; // 기본값\r\n    }\r\n  }\r\n  \r\n  // 이미 문자열인 경우 표준화\r\n  switch (taskType.toLowerCase()) {\r\n    case 'matrix':\r\n    case 'matrixmultiplication':\r\n    case 'matrix-multiplication':\r\n      return 'matrix';\r\n    case 'text':\r\n    case 'textanalysis':\r\n    case 'text-analysis':\r\n      return 'text';\r\n    case 'pattern':\r\n    case 'patterndetection':\r\n    case 'pattern-detection':\r\n      return 'pattern';\r\n    case 'image':\r\n    case 'imageprocessing':\r\n    case 'image-processing':\r\n      return 'image';\r\n    case 'data':\r\n    case 'dataaggregation':\r\n    case 'data-aggregation':\r\n      return 'data';\r\n    case 'typing':\r\n    case 'typingstatistics':\r\n    case 'typing-statistics':\r\n      return 'typing';\r\n    case 'custom':\r\n      return 'custom';\r\n    default:\r\n      return 'matrix'; // 기본값\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 사용량 백분율을 메모리 레벨로 변환\r\n * @param percentUsed 메모리 사용량 백분율 (0-100)\r\n */\r\nexport function getMemoryUsageLevel(percentUsed: number): MemoryUsageLevel {\r\n  if (percentUsed >= 90) {\r\n    return MemoryUsageLevel.CRITICAL;\r\n  } else if (percentUsed >= 70) {\r\n    return MemoryUsageLevel.HIGH;\r\n  } else if (percentUsed >= 50) {\r\n    return MemoryUsageLevel.MEDIUM;\r\n  } else {\r\n    return MemoryUsageLevel.LOW;\r\n  }\r\n}\r\n\r\n// 열거형 값 매핑 테이블 (더 안전한 방식)\r\nconst APP_TO_NATIVE_LEVEL_MAP: Record<number, NativeOptimizationLevel> = {\r\n  [OptimizationLevel.NORMAL]: NativeOptimizationLevel.Normal,\r\n  [OptimizationLevel.LOW]: NativeOptimizationLevel.Low,\r\n  [OptimizationLevel.MEDIUM]: NativeOptimizationLevel.Medium,\r\n  [OptimizationLevel.HIGH]: NativeOptimizationLevel.High,\r\n  [OptimizationLevel.CRITICAL]: NativeOptimizationLevel.Critical\r\n};\r\n\r\nconst NATIVE_TO_APP_LEVEL_MAP: Record<NativeOptimizationLevel, OptimizationLevel> = {\r\n  [NativeOptimizationLevel.Normal]: OptimizationLevel.NORMAL,\r\n  [NativeOptimizationLevel.Low]: OptimizationLevel.LOW,\r\n  [NativeOptimizationLevel.Medium]: OptimizationLevel.MEDIUM,\r\n  [NativeOptimizationLevel.High]: OptimizationLevel.HIGH,\r\n  [NativeOptimizationLevel.Critical]: OptimizationLevel.CRITICAL\r\n};\r\n\r\n/**\r\n * 애플리케이션 OptimizationLevel을 네이티브 OptimizationLevel로 변환\r\n */\r\nexport function toNativeOptimizationLevel(level: OptimizationLevel): NativeOptimizationLevel {\r\n  // 매핑 테이블에서 바로 조회 (더 안전하고 직관적임)\r\n  const nativeLevel = APP_TO_NATIVE_LEVEL_MAP[level];\r\n  \r\n  // 매핑 테이블에 없는 경우 기본값 반환\r\n  if (nativeLevel === undefined) {\r\n    console.warn(`알 수 없는 최적화 레벨 (${level}), 기본값 사용`);\r\n    return NativeOptimizationLevel.Medium;\r\n  }\r\n  \r\n  return nativeLevel;\r\n}\r\n\r\n/**\r\n * 네이티브 OptimizationLevel을 애플리케이션 OptimizationLevel로 변환\r\n */\r\nexport function toAppOptimizationLevel(level: NativeOptimizationLevel): OptimizationLevel {\r\n  // 매핑 테이블에서 바로 조회 (더 안전하고 직관적임)\r\n  const appLevel = NATIVE_TO_APP_LEVEL_MAP[level];\r\n  \r\n  // 매핑 테이블에 없는 경우 기본값 반환\r\n  if (appLevel === undefined) {\r\n    console.warn(`알 수 없는 네이티브 최적화 레벨 (${level}), 기본값 사용`);\r\n    return OptimizationLevel.MEDIUM;\r\n  }\r\n  \r\n  return appLevel;\r\n}\r\n\r\n/**\r\n * 숫자를 적절한 최적화 레벨로 안전하게 변환\r\n */\r\nexport function safeOptimizationLevel(level: number): OptimizationLevel {\r\n  switch (level) {\r\n    case 0: return OptimizationLevel.NORMAL;\r\n    case 1: return OptimizationLevel.LOW;\r\n    case 2: return OptimizationLevel.MEDIUM;\r\n    case 3: return OptimizationLevel.HIGH;\r\n    case 4: return OptimizationLevel.CRITICAL;\r\n    default:\r\n      console.warn(`유효하지 않은 최적화 레벨 (${level}), 기본값 사용`);\r\n      return OptimizationLevel.MEDIUM;\r\n  }\r\n}\r\n\r\n/**\r\n * 타입 변환 유틸리티 - 네이티브 메모리 정보를 앱 메모리 정보로 변환\r\n */\r\nexport function convertNativeMemoryInfo(nativeInfo: any): any {\r\n  if (!nativeInfo) return null;\r\n  \r\n  return {\r\n    timestamp: nativeInfo.timestamp || Date.now(),\r\n    heap_used: nativeInfo.heap_used,\r\n    heapUsed: nativeInfo.heap_used,\r\n    heap_total: nativeInfo.heap_total,\r\n    heapTotal: nativeInfo.heap_total,\r\n    heap_used_mb: nativeInfo.heap_used_mb,\r\n    heapUsedMB: nativeInfo.heap_used_mb,\r\n    rss: nativeInfo.rss,\r\n    rss_mb: nativeInfo.rss_mb,\r\n    rssMB: nativeInfo.rss_mb,\r\n    percent_used: nativeInfo.percent_used,\r\n    percentUsed: nativeInfo.percent_used,\r\n    heap_limit: nativeInfo.heap_limit,\r\n    heapLimit: nativeInfo.heap_limit\r\n  };\r\n}\r\n\r\n/**\r\n * 타입 변환 유틸리티 - 네이티브 GC 결과를 앱 GC 결과로 변환\r\n */\r\nexport function convertNativeGCResult(nativeResult: any): any {\r\n  if (!nativeResult) return null;\r\n  \r\n  return {\r\n    success: nativeResult.success,\r\n    timestamp: nativeResult.timestamp || Date.now(),\r\n    freedMemory: nativeResult.freed_memory,\r\n    freed_memory: nativeResult.freed_memory,\r\n    freedMB: nativeResult.freed_mb,\r\n    freed_mb: nativeResult.freed_mb,\r\n    error: nativeResult.error\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\file-utils.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":34,"column":30,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":34,"endColumn":31,"suggestions":[{"messageId":"removeEscape","fix":{"range":[800,801],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[800,800],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-undef","severity":2,"message":"'File' is not defined.","line":41,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":41,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":42,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":42,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":50,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":50,"endColumn":6},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":85,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":85,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":88,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":88,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":90,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":90,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'File' is not defined.","line":97,"column":39,"nodeType":"Identifier","messageId":"undef","endLine":97,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'FileReader' is not defined.","line":99,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":99,"endColumn":34}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 파일 관련 유틸리티 함수\r\n */\r\n\r\nimport { formatBytes } from './common-utils';\r\n\r\n/**\r\n * 파일 확장자를 추출합니다.\r\n * @param filename - 파일 이름\r\n * @returns 확장자 (점 포함)\r\n */\r\nexport function getFileExtension(filename: string): string {\r\n  const lastDotIndex = filename.lastIndexOf('.');\r\n  if (lastDotIndex === -1) return '';\r\n  return filename.slice(lastDotIndex);\r\n}\r\n\r\n/**\r\n * 파일 이름에서 확장자를 제외한 부분을 반환합니다.\r\n * @param filename - 파일 이름\r\n * @returns 확장자를 제외한 파일 이름\r\n */\r\nexport function getFileNameWithoutExtension(filename: string): string {\r\n  const lastDotIndex = filename.lastIndexOf('.');\r\n  if (lastDotIndex === -1) return filename;\r\n  return filename.slice(0, lastDotIndex);\r\n}\r\n\r\n/**\r\n * 파일명 추출 함수\r\n * @param path 파일 경로\r\n */\r\nexport function getFileName(path: string): string {\r\n  return path.replace(/^.*[\\\\\\/]/, '');\r\n}\r\n\r\n/**\r\n * 파일을 Blob URL로 변환\r\n * @param file File 객체\r\n */\r\nexport function fileToUrl(file: File): string {\r\n  return URL.createObjectURL(file);\r\n}\r\n\r\n/**\r\n * Blob URL 정리 함수\r\n * @param url 정리할 Blob URL\r\n */\r\nexport function cleanupFileUrl(url: string): void {\r\n  URL.revokeObjectURL(url);\r\n}\r\n\r\n/**\r\n * 파일 MIME 유형에 따른 카테고리 확인\r\n * @param mimeType 파일의 MIME 타입\r\n */\r\nexport function getFileCategory(mimeType: string): 'image' | 'video' | 'audio' | 'document' | 'other' {\r\n  if (mimeType.startsWith('image/')) return 'image';\r\n  if (mimeType.startsWith('video/')) return 'video';\r\n  if (mimeType.startsWith('audio/')) return 'audio';\r\n  \r\n  const documentTypes = [\r\n    'application/pdf',\r\n    'application/msword',\r\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\r\n    'application/vnd.ms-excel',\r\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\r\n    'application/vnd.ms-powerpoint',\r\n    'application/vnd.openxmlformats-officedocument.presentationml.presentation',\r\n    'text/plain',\r\n    'application/rtf'\r\n  ];\r\n  \r\n  if (documentTypes.includes(mimeType)) return 'document';\r\n  \r\n  return 'other';\r\n}\r\n\r\n/**\r\n * 브라우저에서 파일 다운로드 함수\r\n * @param url 다운로드할 파일 URL\r\n * @param filename 저장할 파일명\r\n */\r\nexport function downloadFile(url: string, filename: string): void {\r\n  const a = document.createElement('a');\r\n  a.href = url;\r\n  a.download = filename;\r\n  document.body.appendChild(a);\r\n  a.click();\r\n  document.body.removeChild(a);\r\n}\r\n\r\n/**\r\n * 파일 내용 읽기 함수\r\n * @param file 파일 객체\r\n */\r\nexport function readFileContent(file: File): Promise<string> {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader();\r\n    \r\n    reader.onload = (event) => {\r\n      if (event.target?.result) {\r\n        resolve(event.target.result as string);\r\n      } else {\r\n        reject(new Error('파일을 읽을 수 없습니다.'));\r\n      }\r\n    };\r\n    \r\n    reader.onerror = () => reject(new Error('파일 읽기 오류'));\r\n    reader.readAsText(file);\r\n  });\r\n}\r\n\r\n/**\r\n * 파일 크기 정보를 반환합니다.\r\n * @param sizeInBytes - 파일 크기 (바이트)\r\n * @returns 파일 크기 정보 문자열\r\n */\r\nexport function getFileSizeInfo(sizeInBytes: number): string {\r\n  return `파일 크기: ${formatBytes(sizeInBytes)}`;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\format-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\gpu-acceleration.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":51,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":51,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":81,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":81,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":103,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":103,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":159,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":159,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":178,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":178,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":186,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":186,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":192,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":192,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":215,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":215,"endColumn":9}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GPU 언어어 유틸리티\r\n * \r\n * 이 모듈은 네이티브 모듈을 사용하여 GPU 가속화를 관\r\n\r\n * 리합니다.\r\n */\r\n\r\nimport { getGpuInfo, performGpuComputation } from './nativeModuleClient';\r\nimport { setGpuAcceleration as remoteSetGpuAcceleration } from './nativeModuleClient';\r\nimport { GpuTaskType } from '@/types';\r\n\r\n/**\r\n * GPU 정보 인터페이스\r\n */\r\ninterface GpuInfo {\r\n  available: boolean;\r\n  accelerationEnabled: boolean;\r\n  driverVersion: string;\r\n  deviceName: string;\r\n  deviceType: string;\r\n  vendor: string;\r\n  timestamp: number;\r\n}\r\n\r\n// GpuAccelerationResponse 인터페이스는 파일 내에서 사용되지 않지만\r\n// 다른 컴포넌트에서 활용할 수 있도록 export 추가\r\nexport interface GpuAccelerationResponse {\r\n  success: boolean;\r\n  enabled?: boolean;\r\n  available?: boolean;\r\n  error?: string;\r\n  details?: Partial<GpuInfo>;\r\n}\r\n\r\n// 캐시된 GPU 정보\r\nlet gpuInfoCache: GpuInfo | null = null;\r\nlet gpuInfoExpiration = 0;\r\nconst GPU_INFO_TTL = 5000; // 5초\r\n\r\n/**\r\n * GPU 가속화 상태 확인\r\n * @returns 가속화 활성화 여부\r\n */\r\nexport async function isGpuAccelerationEnabled(): Promise<boolean> {\r\n  try {\r\n    // GPU 정보 가져오기 (캐시 사용)\r\n    const gpuInfo = await getGpuInformation();\r\n    return gpuInfo?.accelerationEnabled || false;\r\n  } catch (error) {\r\n    console.error('GPU 가속 상태 확인 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 정보 가져오기\r\n * @returns GPU 정보 객체\r\n */\r\nexport async function getGpuInformation(): Promise<GpuInfo | null> {\r\n  // 캐시된 정보가 있고 유효하다면 그것을 사용\r\n  const now = Date.now();\r\n  if (gpuInfoCache && now < gpuInfoExpiration) {\r\n    return gpuInfoCache;\r\n  }\r\n\r\n  try {\r\n    // 새로운 정보 가져오기\r\n    const response = await getGpuInfo();\r\n    \r\n    if (!response.success || !response.gpuInfo) {\r\n      return null;\r\n    }\r\n    \r\n    // 캐시 업데이트\r\n    gpuInfoCache = response.gpuInfo;\r\n    gpuInfoExpiration = now + GPU_INFO_TTL;\r\n    \r\n    return response.gpuInfo;\r\n  } catch (error) {\r\n    console.error('GPU 정보 가져오기 오류:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 가속화 활성화/비활성화\r\n * @param enable 활성화 여부\r\n * @returns 성공 여부\r\n */\r\nexport async function toggleGpuAcceleration(enable: boolean): Promise<boolean> {\r\n  try {\r\n    const response = await remoteSetGpuAcceleration(enable);\r\n    \r\n    if (response && response.success) {\r\n      // 캐시 무효화\r\n      gpuInfoCache = null;\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  } catch (error) {\r\n    console.error(`GPU 가속화 ${enable ? '활성화' : '비활성화'} 오류:`, error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 가속화 활성화/비활성화\r\n * @param enable 활성화 여부\r\n * @returns 성공 여부\r\n */\r\nexport async function setGpuAcceleration(enable: boolean): Promise<boolean> {\r\n  return await toggleGpuAcceleration(enable);\r\n}\r\n\r\n/**\r\n * 기기 GPU 성능 평가\r\n * @returns 성능 점수 (0-100)\r\n */\r\nexport async function evaluateGpuPerformance(): Promise<number> {\r\n  try {\r\n    const gpuInfo = await getGpuInformation();\r\n    \r\n    if (!gpuInfo || !gpuInfo.available) {\r\n      return 0;\r\n    }\r\n    \r\n    // GPU 타입에 따른 기본 점수 할당\r\n    let score = 0;\r\n    \r\n    if (gpuInfo.deviceType === 'DiscreteGpu') {\r\n      score = 70; // 독립 GPU는 높은 기본 점수\r\n    } else if (gpuInfo.deviceType === 'IntegratedGpu') {\r\n      score = 40; // 통합 GPU는 중간 기본 점수\r\n    } else {\r\n      score = 10; // 기타 GPU 타입은 낮은 기본 점수\r\n    }\r\n    \r\n    // 벤더 정보에 따른 추가 점수\r\n    if (gpuInfo.vendor && gpuInfo.deviceName) {\r\n      const vendorLower = gpuInfo.vendor.toLowerCase();\r\n      const nameLower = gpuInfo.deviceName.toLowerCase();\r\n      \r\n      if (vendorLower.includes('nvidia') && \r\n          (nameLower.includes('rtx') || nameLower.includes('gtx'))) {\r\n        score += 20;\r\n      } else if (vendorLower.includes('amd') && \r\n                (nameLower.includes('radeon') || nameLower.includes('vega'))) {\r\n        score += 15;\r\n      } else if (vendorLower.includes('intel') && nameLower.includes('iris')) {\r\n        score += 10;\r\n      }\r\n    }\r\n    \r\n    // 점수를 0-100 범위로 제한\r\n    return Math.min(100, Math.max(0, score));\r\n  } catch (error) {\r\n    console.error('GPU 성능 평가 오류:', error);\r\n    return 0;\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 작업 분석 및 계산 수행\r\n * @param taskType 작업 유형\r\n * @param data 작업 데이터\r\n * @returns 계산 결과\r\n */\r\nexport async function executeGpuTask<T = unknown>(\r\n  taskType: GpuTaskType | string, \r\n  data: unknown\r\n): Promise<T | null> {\r\n  try {\r\n    // GPU 가용성 확인\r\n    const gpuInfo = await getGpuInformation();\r\n    if (!gpuInfo || !gpuInfo.available || !gpuInfo.accelerationEnabled) {\r\n      console.warn('GPU 가속이 비활성화되었거나 사용할 수 없습니다.');\r\n      return null;\r\n    }\r\n    \r\n    // GPU 작업 실행\r\n    const response = await performGpuComputation<T>(data, taskType.toString());\r\n    \r\n    if (!response.success) {\r\n      console.error('GPU 작업 실패:', response.error);\r\n      return null;\r\n    }\r\n    \r\n    return response.result as T;\r\n  } catch (error) {\r\n    console.error('GPU 작업 실행 오류:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 가속화 활성화\r\n * @returns 성공 여부\r\n */\r\nexport async function enableGpuAcceleration(): Promise<boolean> {\r\n  return toggleGpuAcceleration(true);\r\n}\r\n\r\n/**\r\n * GPU 가속화 비활성화\r\n * @returns 성공 여부\r\n */\r\nexport async function disableGpuAcceleration(): Promise<boolean> {\r\n  return toggleGpuAcceleration(false);\r\n}\r\n\r\n// 간단한 전역 API 설정\r\nif (typeof window !== 'undefined') {\r\n  window.__gpuAccelerator = {\r\n    isGpuAccelerationEnabled,\r\n    getGpuInformation,\r\n    toggleGpuAcceleration,\r\n    enableGpuAcceleration,\r\n    disableGpuAcceleration,\r\n    evaluateGpuPerformance,\r\n    executeGpuTask\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\gpu-detection.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'UNKNOWN' is defined but never used.","line":26,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":10},{"ruleId":"no-unused-vars","severity":2,"message":"'NVIDIA' is defined but never used.","line":27,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'AMD' is defined but never used.","line":28,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":28,"endColumn":6},{"ruleId":"no-unused-vars","severity":2,"message":"'INTEL' is defined but never used.","line":29,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":29,"endColumn":8},{"ruleId":"no-unused-vars","severity":2,"message":"'APPLE' is defined but never used.","line":30,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":8},{"ruleId":"no-unused-vars","severity":2,"message":"'MICROSOFT' is defined but never used.","line":31,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":31,"endColumn":12},{"ruleId":"no-unused-vars","severity":2,"message":"'QUALCOMM' is defined but never used.","line":32,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":11},{"ruleId":"no-unused-vars","severity":2,"message":"'ARM' is defined but never used.","line":33,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":33,"endColumn":6},{"ruleId":"no-unused-vars","severity":2,"message":"'IMAGINATION' is defined but never used.","line":34,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":34,"endColumn":14},{"ruleId":"no-unused-vars","severity":2,"message":"'SOFTPIPE' is defined but never used.","line":35,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":11},{"ruleId":"no-unused-vars","severity":2,"message":"'SWIFTSHADER' is defined but never used.","line":36,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":14},{"ruleId":"no-unused-vars","severity":2,"message":"'UNKNOWN' is defined but never used.","line":41,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":41,"endColumn":10},{"ruleId":"no-unused-vars","severity":2,"message":"'INTEGRATED' is defined but never used.","line":42,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":42,"endColumn":13},{"ruleId":"no-unused-vars","severity":2,"message":"'DISCRETE' is defined but never used.","line":43,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":43,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":85,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":85,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'WebGLRenderingContext' is not defined.","line":88,"column":87,"nodeType":"Identifier","messageId":"undef","endLine":88,"endColumn":108},{"ruleId":"no-undef","severity":2,"message":"'WebGL2RenderingContext' is not defined.","line":119,"column":46,"nodeType":"Identifier","messageId":"undef","endLine":119,"endColumn":68},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":123,"column":45,"nodeType":"Identifier","messageId":"undef","endLine":123,"endColumn":54},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":136,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":136,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'WebGLRenderingContext' is not defined.","line":283,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":283,"endColumn":53},{"ruleId":"no-undef","severity":2,"message":"'HTMLCanvasElement' is not defined.","line":318,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":318,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'WebGLContextAttributes' is not defined.","line":320,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":320,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'WebGLRenderingContext' is not defined.","line":321,"column":4,"nodeType":"Identifier","messageId":"undef","endLine":321,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'WebGL2RenderingContext' is not defined.","line":321,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":321,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'WebGLContextAttributes' is not defined.","line":323,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":323,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'WebGL2RenderingContext' is not defined.","line":340,"column":62,"nodeType":"Identifier","messageId":"undef","endLine":340,"endColumn":84},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":343,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":343,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'WebGLRenderingContext' is not defined.","line":350,"column":67,"nodeType":"Identifier","messageId":"undef","endLine":350,"endColumn":88},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":352,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":352,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":373,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":373,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":382,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":382,"endColumn":11}],"suppressedMessages":[],"errorCount":31,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GPU 감지 및 호환성 유틸리티\r\n * \r\n * 이 모듈은 클라이언트의 GPU 하드웨어를 감지하고 사용 가능한 기능을 확인합니다.\r\n * 다양한 브라우저와 운영체제 환경에서 최적의 GPU 가속 방법을 제공합니다.\r\n */\r\n\r\nimport { isGpuAccelerationEnabled } from './gpu-acceleration';\r\n\r\n// GPU 기능 호환성 인터페이스\r\nexport interface GpuCapabilities {\r\n  webGLSupported: boolean;\r\n  webGL2Supported: boolean;\r\n  webGPUSupported: boolean;\r\n  hardwareAccelerated: boolean;\r\n  vendor: string;\r\n  renderer: string;\r\n  isDiscrete: boolean;  // 독립형 GPU인지 여부\r\n  memorySizeMB?: number; // GPU 메모리 크기 (MB)\r\n  driverVersion?: string;\r\n  gpuTier: number; // 1-저사양, 2-중간, 3-고사양\r\n}\r\n\r\n// GPU 벤더 enum\r\nexport enum GpuVendor {\r\n  UNKNOWN = 'unknown',\r\n  NVIDIA = 'nvidia',\r\n  AMD = 'amd',\r\n  INTEL = 'intel',\r\n  APPLE = 'apple',\r\n  MICROSOFT = 'microsoft',\r\n  QUALCOMM = 'qualcomm',\r\n  ARM = 'arm',\r\n  IMAGINATION = 'imagination',\r\n  SOFTPIPE = 'software',\r\n  SWIFTSHADER = 'swiftshader'\r\n}\r\n\r\n// 아키텍처에 따른 GPU 분류 (독립 GPU vs 통합 GPU)\r\nexport enum GpuArchitecture {\r\n  UNKNOWN = 'unknown',\r\n  INTEGRATED = 'integrated',\r\n  DISCRETE = 'discrete'\r\n}\r\n\r\n// GPU 메모리 캐시 (반복 감지 방지)\r\nconst gpuCache = {\r\n  capabilities: null as GpuCapabilities | null,\r\n  lastCheck: 0,\r\n  vendor: GpuVendor.UNKNOWN,\r\n  architecture: GpuArchitecture.UNKNOWN\r\n};\r\n\r\n/**\r\n * GPU 기능 감지\r\n * \r\n * 클라이언트의 GPU 기능을 감지하고 호환성 정보를 반환합니다.\r\n */\r\nexport async function detectGpuCapabilities(): Promise<GpuCapabilities> {\r\n  // 캐시된 정보가 있으면 재사용 (30초 이내)\r\n  const now = Date.now();\r\n  if (gpuCache.capabilities && now - gpuCache.lastCheck < 30000) {\r\n    return gpuCache.capabilities;\r\n  }\r\n  \r\n  // 기본 기능 설정\r\n  const capabilities: GpuCapabilities = {\r\n    webGLSupported: false,\r\n    webGL2Supported: false,\r\n    webGPUSupported: false,\r\n    hardwareAccelerated: false,\r\n    vendor: 'unknown',\r\n    renderer: 'unknown',\r\n    isDiscrete: false,\r\n    gpuTier: 0\r\n  };\r\n  \r\n  try {\r\n    // 서버 사이드 렌더링 환경에서는 빈 객체 반환\r\n    if (typeof window === 'undefined' || typeof document === 'undefined') {\r\n      return capabilities;\r\n    }\r\n    \r\n    // WebGL 지원 확인\r\n    const canvas = document.createElement('canvas');\r\n    \r\n    // WebGL 1.0 확인\r\n    let gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl') as WebGLRenderingContext | null;\r\n    capabilities.webGLSupported = !!gl;\r\n    \r\n    if (gl) {\r\n      // GPU 정보 가져오기\r\n      const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');\r\n      if (debugInfo) {\r\n        capabilities.vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || 'unknown';\r\n        capabilities.renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || 'unknown';\r\n      }\r\n      \r\n      // 하드웨어 가속 여부 확인\r\n      capabilities.hardwareAccelerated = isHardwareAccelerated(capabilities.renderer);\r\n      \r\n      // 벤더 식별\r\n      gpuCache.vendor = identifyVendor(capabilities.vendor, capabilities.renderer);\r\n      \r\n      // 아키텍처 식별\r\n      gpuCache.architecture = identifyArchitecture(capabilities.renderer, gpuCache.vendor);\r\n      capabilities.isDiscrete = gpuCache.architecture === GpuArchitecture.DISCRETE;\r\n      \r\n      // GPU 티어 결정\r\n      capabilities.gpuTier = determineGpuTier(\r\n        gpuCache.vendor, \r\n        capabilities.renderer, \r\n        gpuCache.architecture, \r\n        capabilities.hardwareAccelerated\r\n      );\r\n    }\r\n    \r\n    // WebGL 2.0 확인\r\n    let gl2 = canvas.getContext('webgl2') as WebGL2RenderingContext | null;\r\n    capabilities.webGL2Supported = !!gl2;\r\n    \r\n    // WebGPU 확인 (아직 모든 브라우저에서 지원되지 않음)\r\n    capabilities.webGPUSupported = 'gpu' in navigator;\r\n    \r\n    // GPU 메모리 크기 추정 (가능한 경우)\r\n    if (gl && gpuCache.vendor !== GpuVendor.UNKNOWN) {\r\n      capabilities.memorySizeMB = estimateGpuMemory(gl, gpuCache.vendor, capabilities.gpuTier);\r\n    }\r\n    \r\n    // 캐시에 저장\r\n    gpuCache.capabilities = capabilities;\r\n    gpuCache.lastCheck = now;\r\n    \r\n    return capabilities;\r\n  } catch (error) {\r\n    console.error('GPU 기능 감지 중 오류:', error);\r\n    return capabilities;\r\n  }\r\n}\r\n\r\n/**\r\n * 하드웨어 가속 여부 확인\r\n */\r\nfunction isHardwareAccelerated(renderer: string): boolean {\r\n  const softwareRenderers = [\r\n    'swiftshader', 'llvmpipe', 'software', 'mesa offscreen', \r\n    'microsoft basic render', 'gdi generic', 'virgl', \r\n    'virtual box', 'basic render'\r\n  ];\r\n  \r\n  renderer = renderer.toLowerCase();\r\n  return !softwareRenderers.some(sr => renderer.includes(sr));\r\n}\r\n\r\n/**\r\n * GPU 벤더 식별\r\n */\r\nfunction identifyVendor(vendor: string, renderer: string): GpuVendor {\r\n  const vendorLower = vendor.toLowerCase();\r\n  const rendererLower = renderer.toLowerCase();\r\n  \r\n  if (vendorLower.includes('nvidia') || rendererLower.includes('nvidia')) {\r\n    return GpuVendor.NVIDIA;\r\n  } else if (vendorLower.includes('amd') || rendererLower.includes('amd') || \r\n             vendorLower.includes('ati') || rendererLower.includes('radeon')) {\r\n    return GpuVendor.AMD;\r\n  } else if (vendorLower.includes('intel') || rendererLower.includes('intel')) {\r\n    return GpuVendor.INTEL;\r\n  } else if (vendorLower.includes('apple') || rendererLower.includes('apple')) {\r\n    return GpuVendor.APPLE;\r\n  } else if (vendorLower.includes('microsoft') || rendererLower.includes('microsoft')) {\r\n    return GpuVendor.MICROSOFT;\r\n  } else if (vendorLower.includes('qualcomm') || rendererLower.includes('adreno')) {\r\n    return GpuVendor.QUALCOMM;\r\n  } else if (vendorLower.includes('arm') || rendererLower.includes('mali')) {\r\n    return GpuVendor.ARM;\r\n  } else if (vendorLower.includes('imagination') || rendererLower.includes('powervr')) {\r\n    return GpuVendor.IMAGINATION;\r\n  } else if (rendererLower.includes('swiftshader')) {\r\n    return GpuVendor.SWIFTSHADER;\r\n  } else if (rendererLower.includes('llvmpipe') || rendererLower.includes('softpipe')) {\r\n    return GpuVendor.SOFTPIPE;\r\n  }\r\n  \r\n  return GpuVendor.UNKNOWN;\r\n}\r\n\r\n/**\r\n * GPU 아키텍처 식별 (통합 vs 독립)\r\n */\r\nfunction identifyArchitecture(renderer: string, vendor: GpuVendor): GpuArchitecture {\r\n  const rendererLower = renderer.toLowerCase();\r\n  \r\n  // 명확한 독립 GPU 식별자\r\n  if (rendererLower.includes('rtx') || \r\n      rendererLower.includes('geforce') || \r\n      rendererLower.includes('quadro') ||\r\n      rendererLower.includes('radeon') ||\r\n      rendererLower.includes('firepro') ||\r\n      rendererLower.includes('rx') && rendererLower.match(/\\brx\\s+\\d{3,4}\\b/i)) {\r\n    return GpuArchitecture.DISCRETE;\r\n  }\r\n  \r\n  // 통합 GPU 식별자\r\n  if (rendererLower.includes('uhd') || \r\n      rendererLower.includes('iris') ||\r\n      rendererLower.includes('hd graphics') ||\r\n      vendor === GpuVendor.INTEL ||\r\n      rendererLower.includes('apple m') ||\r\n      vendor === GpuVendor.ARM ||\r\n      vendor === GpuVendor.QUALCOMM) {\r\n    return GpuArchitecture.INTEGRATED;\r\n  }\r\n  \r\n  // 불확실한 경우\r\n  return GpuArchitecture.UNKNOWN;\r\n}\r\n\r\n/**\r\n * GPU 티어 결정 (1-저사양, 2-중간, 3-고사양)\r\n */\r\nfunction determineGpuTier(\r\n  vendor: GpuVendor, \r\n  renderer: string, \r\n  architecture: GpuArchitecture, \r\n  hardwareAccelerated: boolean\r\n): number {\r\n  if (!hardwareAccelerated) {\r\n    return 0; // 하드웨어 가속 불가능\r\n  }\r\n  \r\n  const rendererLower = renderer.toLowerCase();\r\n  \r\n  // 소프트웨어 렌더러는 항상 티어 0\r\n  if (vendor === GpuVendor.SOFTPIPE || vendor === GpuVendor.SWIFTSHADER) {\r\n    return 0;\r\n  }\r\n  \r\n  // 독립 GPU는 일반적으로 고성능\r\n  if (architecture === GpuArchitecture.DISCRETE) {\r\n    // 고사양 GPU\r\n    if (rendererLower.includes('rtx') || \r\n        rendererLower.includes('geforce 30') || \r\n        rendererLower.includes('geforce 40') ||\r\n        rendererLower.includes('radeon rx 6') || \r\n        rendererLower.includes('radeon rx 7')) {\r\n      return 3;\r\n    }\r\n    \r\n    // 중간 사양 GPU\r\n    if (rendererLower.includes('geforce 20') || \r\n        rendererLower.includes('geforce 16') ||\r\n        rendererLower.includes('radeon rx 5') || \r\n        rendererLower.includes('radeon vega')) {\r\n      return 2;\r\n    }\r\n    \r\n    // 기본적으로 독립 GPU는 최소 티어 2\r\n    return 2;\r\n  }\r\n  \r\n  // 통합 GPU\r\n  if (architecture === GpuArchitecture.INTEGRATED) {\r\n    // 고성능 통합 GPU\r\n    if (rendererLower.includes('apple m2') || \r\n        rendererLower.includes('apple m3') ||\r\n        rendererLower.includes('iris xe') || \r\n        rendererLower.includes('intel arc')) {\r\n      return 2;\r\n    }\r\n    \r\n    // 일반 통합 GPU\r\n    return 1;\r\n  }\r\n  \r\n  // 기본값: 알 수 없는 경우 안전하게 티어 1 반환\r\n  return 1;\r\n}\r\n\r\n/**\r\n * GPU 메모리 크기 추정\r\n */\r\nfunction estimateGpuMemory(gl: WebGLRenderingContext, vendor: GpuVendor, tier: number): number {\r\n  // WebGL 확장에서 메모리 크기 추정 시도\r\n  const extension = gl.getExtension('WEBGL_debug_renderer_info');\r\n  if (extension) {\r\n    // 일부 브라우저는 GPU 메모리 정보를 제공하지만, 표준화되지 않음\r\n    // 간접적으로 추정\r\n    \r\n    // GPU 티어에 따른 추정\r\n    switch (tier) {\r\n      case 3: return 8 * 1024; // 8GB\r\n      case 2: return 4 * 1024; // 4GB\r\n      case 1: return 2 * 1024; // 2GB\r\n      default: return 1 * 1024; // 1GB\r\n    }\r\n  }\r\n  \r\n  // 기본값: 벤더와 티어에 따른 보수적 추정\r\n  switch (vendor) {\r\n    case GpuVendor.NVIDIA:\r\n      return tier === 3 ? 8 * 1024 : tier === 2 ? 4 * 1024 : 2 * 1024;\r\n    case GpuVendor.AMD:\r\n      return tier === 3 ? 8 * 1024 : tier === 2 ? 4 * 1024 : 2 * 1024;\r\n    case GpuVendor.INTEL:\r\n      return tier === 2 ? 2 * 1024 : 1 * 1024;\r\n    case GpuVendor.APPLE:\r\n      return tier === 2 ? 4 * 1024 : 2 * 1024;\r\n    default:\r\n      return 1 * 1024; // 알 수 없는 경우 1GB 가정\r\n  }\r\n}\r\n\r\n/**\r\n * WebGL 컨텍스트 생성 도우미\r\n */\r\nexport function createWebGLContext(\r\n  canvas: HTMLCanvasElement, \r\n  preferWebGL2: boolean = true, \r\n  contextAttributes: WebGLContextAttributes = {}\r\n): WebGLRenderingContext | WebGL2RenderingContext | null {\r\n  // 기본 컨텍스트 속성\r\n  const defaultAttributes: WebGLContextAttributes = {\r\n    alpha: false,              // 알파 채널 불필요하면 비활성화\r\n    antialias: false,          // 필요시 활성화\r\n    depth: true,               // 3D 필요하면 활성화\r\n    failIfMajorPerformanceCaveat: false,\r\n    powerPreference: 'high-performance',\r\n    premultipliedAlpha: false,\r\n    preserveDrawingBuffer: false,\r\n    stencil: false,\r\n    desynchronized: true       // 지연 감소\r\n  };\r\n  \r\n  const attributes = { ...defaultAttributes, ...contextAttributes };\r\n  \r\n  // WebGL 2.0 우선 시도\r\n  if (preferWebGL2) {\r\n    try {\r\n      const gl2 = canvas.getContext('webgl2', attributes) as WebGL2RenderingContext;\r\n      if (gl2) return gl2;\r\n    } catch (e) {\r\n      console.warn('WebGL 2 초기화 실패, WebGL 1로 폴백', e);\r\n    }\r\n  }\r\n  \r\n  // WebGL 1.0 폴백\r\n  try {\r\n    return canvas.getContext('webgl', attributes) || \r\n           canvas.getContext('experimental-webgl', attributes) as WebGLRenderingContext;\r\n  } catch (e) {\r\n    console.error('WebGL 초기화 실패', e);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * 웹 환경에서 GPU 가속화가 지원되는지 확인\r\n */\r\nexport async function isGpuSupported(): Promise<boolean> {\r\n  try {\r\n    // 네이티브 모듈 우선 확인\r\n    const nativeSupported = await isGpuAccelerationEnabled();\r\n    if (nativeSupported) {\r\n      return true;\r\n    }\r\n    \r\n    // 클라이언트 측 감지\r\n    const capabilities = await detectGpuCapabilities();\r\n    return capabilities.hardwareAccelerated && \r\n           (capabilities.webGLSupported || capabilities.webGPUSupported);\r\n  } catch (error) {\r\n    console.error('GPU 지원 확인 중 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// 전역 GPU 정보 캐싱 & 공유\r\nif (typeof window !== 'undefined') {\r\n  // 자동 감지\r\n  detectGpuCapabilities().then(info => {\r\n    window.__gpuInfo = {\r\n      isAccelerated: () => info.hardwareAccelerated,\r\n      renderer: info.renderer,\r\n      vendor: info.vendor,\r\n      getGPUTier: () => ({ tier: info.gpuTier, type: getTierDescription(info.gpuTier) }),\r\n      isHardwareAccelerated: () => info.hardwareAccelerated\r\n    };\r\n  });\r\n}\r\n\r\n/**\r\n * GPU 티어 설명 반환\r\n */\r\nfunction getTierDescription(tier: number): string {\r\n  switch (tier) {\r\n    case 0: return 'software';\r\n    case 1: return 'entry-level';\r\n    case 2: return 'mid-range';\r\n    case 3: return 'high-end';\r\n    default: return 'unknown';\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\gpu-settings-bridge.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":35,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":35,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":61,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":61,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":84,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":84,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":97,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":97,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":154,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":154,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":164,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":164,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":192,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":192,"endColumn":12}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GPU 설정 브릿지\r\n * \r\n * 이 모듈은 네이티브 GPU 설정과 애플리케이션 간의 인터페이스를 제공합니다.\r\n */\r\n\r\n// GPU 설정 인터페이스\r\nexport interface GpuSettings {\r\n  hardware_acceleration_enabled: boolean;\r\n  shader_cache_enabled: boolean;\r\n  compute_mode: string;\r\n  power_preference: string;\r\n  max_resource_size: number;\r\n  debug_mode: boolean;\r\n  profile_name: string;\r\n}\r\n\r\n// 애플리케이션 GPU 설정 인터페이스 (JS 친화적인 필드명)\r\nexport interface AppGpuSettings {\r\n  hardwareAccelerationEnabled: boolean;\r\n  shaderCacheEnabled: boolean;\r\n  computeMode: string;\r\n  powerPreference: string;\r\n  maxResourceSize: number;\r\n  debugMode: boolean;\r\n  profileName: string;\r\n}\r\n\r\n/**\r\n * GPU 설정 가져오기\r\n * @returns Promise<AppGpuSettings>\r\n */\r\nexport async function getGpuSettings(): Promise<AppGpuSettings | null> {\r\n  try {\r\n    const response = await fetch('/api/native/gpu/settings', {\r\n      method: 'GET',\r\n      cache: 'no-cache'\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`GPU 설정 요청 실패: ${response.status}`);\r\n    }\r\n    \r\n    const data = await response.json();\r\n    \r\n    if (!data.success || !data.settings) {\r\n      throw new Error(data.error || 'GPU 설정을 가져올 수 없습니다');\r\n    }\r\n    \r\n    // Rust 스타일 필드명을 JS 스타일로 변환\r\n    return {\r\n      hardwareAccelerationEnabled: data.settings.hardware_acceleration_enabled,\r\n      shaderCacheEnabled: data.settings.shader_cache_enabled,\r\n      computeMode: data.settings.compute_mode,\r\n      powerPreference: data.settings.power_preference,\r\n      maxResourceSize: data.settings.max_resource_size,\r\n      debugMode: data.settings.debug_mode,\r\n      profileName: data.settings.profile_name\r\n    };\r\n  } catch (error) {\r\n    console.error('GPU 설정 가져오기 오류:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 설정 업데이트\r\n * @param settings GPU 설정\r\n * @returns Promise<boolean>\r\n */\r\nexport async function updateGpuSettings(settings: AppGpuSettings): Promise<boolean> {\r\n  try {\r\n    // JS 스타일 필드명을 Rust 스타일로 변환\r\n    const nativeSettings: GpuSettings = {\r\n      hardware_acceleration_enabled: settings.hardwareAccelerationEnabled,\r\n      shader_cache_enabled: settings.shaderCacheEnabled,\r\n      compute_mode: settings.computeMode,\r\n      power_preference: settings.powerPreference,\r\n      max_resource_size: settings.maxResourceSize,\r\n      debug_mode: settings.debugMode,\r\n      profile_name: settings.profileName\r\n    };\r\n    \r\n    const response = await fetch('/api/native/gpu/settings', {\r\n      method: 'PUT',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify(nativeSettings)\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`GPU 설정 업데이트 실패: ${response.status}`);\r\n    }\r\n    \r\n    const data = await response.json();\r\n    return data.success === true;\r\n  } catch (error) {\r\n    console.error('GPU 설정 업데이트 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 성능 프로필 적용\r\n * @param profileName 프로필 이름 ('high-performance', 'balanced', 'power-save')\r\n * @returns Promise<boolean>\r\n */\r\nexport async function applyGpuPerformanceProfile(profileName: string): Promise<boolean> {\r\n  try {\r\n    // 현재 설정 가져오기\r\n    const currentSettings = await getGpuSettings();\r\n    \r\n    if (!currentSettings) {\r\n      return false;\r\n    }\r\n    \r\n    // 프로필에 맞게 설정 업데이트\r\n    let updatedSettings: AppGpuSettings;\r\n    \r\n    switch (profileName) {\r\n      case 'high-performance':\r\n        updatedSettings = {\r\n          ...currentSettings,\r\n          hardwareAccelerationEnabled: true,\r\n          shaderCacheEnabled: true,\r\n          computeMode: 'performance',\r\n          powerPreference: 'high-performance',\r\n          profileName: 'high-performance'\r\n        };\r\n        break;\r\n        \r\n      case 'balanced':\r\n        updatedSettings = {\r\n          ...currentSettings,\r\n          hardwareAccelerationEnabled: true,\r\n          shaderCacheEnabled: true,\r\n          computeMode: 'auto',\r\n          powerPreference: 'default',\r\n          profileName: 'balanced'\r\n        };\r\n        break;\r\n        \r\n      case 'power-save':\r\n        updatedSettings = {\r\n          ...currentSettings,\r\n          hardwareAccelerationEnabled: false,\r\n          shaderCacheEnabled: true,\r\n          computeMode: 'power-save',\r\n          powerPreference: 'low-power',\r\n          profileName: 'power-save'\r\n        };\r\n        break;\r\n        \r\n      default:\r\n        console.warn(`알 수 없는 프로필: ${profileName}, 기본 설정 사용`);\r\n        updatedSettings = {\r\n          ...currentSettings,\r\n          profileName\r\n        };\r\n    }\r\n    \r\n    // 업데이트된 설정 적용\r\n    return await updateGpuSettings(updatedSettings);\r\n  } catch (error) {\r\n    console.error('GPU 성능 프로필 적용 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 가속화 설정\r\n * @param enabled 활성화 여부\r\n * @returns Promise<boolean>\r\n */\r\nexport async function setGpuAcceleration(enabled: boolean): Promise<boolean> {\r\n  try {\r\n    // 현재 설정 가져오기\r\n    const currentSettings = await getGpuSettings();\r\n    \r\n    if (!currentSettings) {\r\n      return false;\r\n    }\r\n    \r\n    // GPU 가속화 설정 변경\r\n    const updatedSettings = {\r\n      ...currentSettings,\r\n      hardwareAccelerationEnabled: enabled\r\n    };\r\n    \r\n    // 업데이트된 설정 적용\r\n    return await updateGpuSettings(updatedSettings);\r\n  } catch (error) {\r\n    console.error('GPU 가속화 설정 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\gpu-settings-manager.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":91,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":91,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":102,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":102,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":103,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":103,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'Navigator' is not defined.","line":103,"column":43,"nodeType":"Identifier","messageId":"undef","endLine":103,"endColumn":52},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":108,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":108,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":119,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":119,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":120,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":120,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Navigator' is not defined.","line":120,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":120,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":124,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":124,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":163,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":163,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":184,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":184,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":184,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":184,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4660,4696],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":187,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":187,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":187,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":187,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":188,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":188,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":197,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":197,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":220,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":220,"endColumn":12},{"ruleId":"no-unused-vars","severity":2,"message":"'settings' is defined but never used.","line":235,"column":55,"nodeType":"Identifier","messageId":"unusedVar","endLine":235,"endColumn":76},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'settings' is defined but never used. Allowed unused args must match /^_/u.","line":235,"column":55,"nodeType":null,"messageId":"unusedVar","endLine":235,"endColumn":63}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GPU 설정 관리 유틸리티\r\n * \r\n * 다양한、GPU 유형(내장, 모바일, 디스크리트 GPU)에 대한 설정을 관리합니다.\r\n */\r\n\r\nimport { isGPUAccelerationEnabled, getGPUInfo } from './memory/gpu-accelerator';\r\n\r\n// GPU 설정 유형 정의\r\nexport interface GPUSettings {\r\n  useHardwareAcceleration: boolean;  // 하드웨어 가속 사용 여부\r\n  processingMode: string;            // 처리 모드\r\n  optimizeForBattery: boolean;       // 배터리 최적화 모드\r\n  memoryOptimization: 'low' | 'medium' | 'high'; // 메모리 최적화 레벨\r\n  threadCount: number;               // 사용할 스레드 수\r\n}\r\n\r\n// 디바이스 유형 기반 최적화 설정\r\nconst GPU_PROFILES = {\r\n  // 디스크리트 GPU (고성능)\r\n  'DiscreteGpu': {\r\n    useHardwareAcceleration: true,\r\n    processingMode: 'gpu-intensive',\r\n    optimizeForBattery: false,\r\n    memoryOptimization: 'low' as const,\r\n    threadCount: 16\r\n  },\r\n  \r\n  // 내장 GPU (중간 성능)\r\n  'IntegratedGpu': {\r\n    useHardwareAcceleration: true,\r\n    processingMode: 'normal',\r\n    optimizeForBattery: true,\r\n    memoryOptimization: 'medium' as const,\r\n    threadCount: 8\r\n  },\r\n  \r\n  // 저전력 GPU (모바일/시스템)\r\n  'LowPower': {\r\n    useHardwareAcceleration: false,\r\n    processingMode: 'cpu-intensive',\r\n    optimizeForBattery: true,\r\n    memoryOptimization: 'high' as const,\r\n    threadCount: 4\r\n  }\r\n};\r\n\r\n/**\r\n * 현재 GPU 타입 감지\r\n * @returns GPU 타입 문자열\r\n */\r\nexport async function detectGPUType(): Promise<string> {\r\n  try {\r\n    // GPU 가속 사용 가능 여부 확인\r\n    const isAccelerated = await isGPUAccelerationEnabled();\r\n    if (!isAccelerated) {\r\n      return 'LowPower';\r\n    }\r\n    \r\n    // GPU 정보 가져오기\r\n    const gpuInfo = getGPUInfo();\r\n    const { renderer } = gpuInfo;\r\n    \r\n    // 고성능 GPU 확인\r\n    if (renderer.includes('NVIDIA') || \r\n        renderer.includes('AMD') || \r\n        renderer.includes('Radeon') ||\r\n        renderer.includes('GeForce')) {\r\n      return 'DiscreteGpu';\r\n    }\r\n    \r\n    // 내장 GPU 확인\r\n    if (renderer.includes('Intel') ||\r\n        renderer.includes('UHD') ||\r\n        renderer.includes('Iris')) {\r\n      return 'IntegratedGpu';\r\n    }\r\n    \r\n    // 모바일 또는 저전력 GPU 확인\r\n    if (renderer.includes('Apple') || \r\n        renderer.includes('Mali') || \r\n        renderer.includes('PowerVR') ||\r\n        renderer.includes('Adreno')) {\r\n      // 대부분의 최신 모바일 GPU는 내장 GPU와 비슷한 성능 제공\r\n      return 'IntegratedGpu';\r\n    }\r\n    \r\n    // 기타 또는 미확인 GPU - 기본적으로 내장 GPU로 취급\r\n    return 'IntegratedGpu';\r\n  } catch (error) {\r\n    console.error('GPU 타입 감지 실패:', error);\r\n    return 'LowPower'; // 오류 시 저전력 모드로 폴백\r\n  }\r\n}\r\n\r\n/**\r\n * 배터리 상태 확인 (저전력 조건 판단용)\r\n */\r\nasync function checkBatteryStatus(): Promise<boolean> {\r\n  try {\r\n    // 배터리 API 지원 확인\r\n    if ('getBattery' in navigator) {\r\n      const battery = await (navigator as Navigator & {getBattery(): Promise<any>}).getBattery();\r\n      return !battery.charging && battery.level < 0.3; // 충전 중이 아니고 30% 미만일 때 저전력 모드\r\n    }\r\n    return false;\r\n  } catch (error) {\r\n    console.warn('배터리 상태 확인 실패:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 시스템 메모리 확인\r\n */\r\nfunction checkSystemMemory(): number {\r\n  try {\r\n    // 메모리 API 지원 확인\r\n    if ('deviceMemory' in navigator) {\r\n      return (navigator as Navigator & {deviceMemory: number}).deviceMemory;\r\n    }\r\n    return 0; // 알 수 없음\r\n  } catch (error) {\r\n    console.warn('시스템 메모리 확인 실패:', error);\r\n    return 0;\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 타입에 최적화된 설정 가져오기\r\n * @returns GPU 설정 객체\r\n */\r\nexport async function getOptimalGPUSettings(): Promise<GPUSettings> {\r\n  try {\r\n    const gpuType = await detectGPUType();\r\n    \r\n    // 배터리 상태 확인 (가능한 경우)\r\n    let isOnBattery = await checkBatteryStatus();\r\n    \r\n    // 기본 설정 가져오기\r\n    const settings = { ...GPU_PROFILES[gpuType as keyof typeof GPU_PROFILES] };\r\n    \r\n    // 배터리 상태에 따른 설정 조정 \r\n    if (isOnBattery && gpuType === 'DiscreteGpu') {\r\n      settings.processingMode = 'normal';\r\n      settings.threadCount = 8;\r\n    }\r\n    \r\n    // 디바이스 메모리에 따른 설정 조정\r\n    const deviceMemory = checkSystemMemory();\r\n    \r\n    if (deviceMemory <= 2) {\r\n      // 낮은 메모리 기기\r\n      settings.memoryOptimization = 'high';\r\n      settings.threadCount = Math.min(settings.threadCount, 4);\r\n    } else if (deviceMemory <= 4) {\r\n      // 중간 메모리 기기\r\n      settings.memoryOptimization = 'medium';\r\n    }\r\n    \r\n    return settings;\r\n  } catch (error) {\r\n    console.error('최적 GPU 설정 계산 실패:', error);\r\n    \r\n    // 오류 발생 시 안전한 기본값 반환\r\n    return {\r\n      useHardwareAcceleration: false,\r\n      processingMode: 'normal',\r\n      optimizeForBattery: true,\r\n      memoryOptimization: 'medium',\r\n      threadCount: 4\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * 현재 설정에 따라 GPU 사용 최적화\r\n * @param settings GPU 설정 객체\r\n */\r\nexport async function applyGPUSettings(settings: GPUSettings): Promise<boolean> {\r\n  try {\r\n    // 하드웨어 가속 설정\r\n    // 실제 구현에서는 여기에 설정 적용 로직 추가\r\n    console.log('GPU 설정 적용:', settings);\r\n    \r\n    // Electron IPC를 통해 메인 프로세스에 설정 전달 (지원되는 경우)\r\n    if (window.electronAPI && window.electronAPI.saveSettings) {\r\n      await window.electronAPI.saveSettings({\r\n        // 다른 설정과 함께 GPU 설정 전달\r\n        useHardwareAcceleration: settings.useHardwareAcceleration,\r\n        processingMode: settings.processingMode\r\n      });\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('GPU 설정 적용 중 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 기능 확인 및 권장 설정 가져오기\r\n * @returns 권장 설정 및 GPU 정보\r\n */\r\nexport async function getGPURecommendations() {\r\n  try {\r\n    const gpuType = await detectGPUType();\r\n    const recommendedSettings = await getOptimalGPUSettings();\r\n    const gpuInfo = getGPUInfo();\r\n    \r\n    return {\r\n      gpuType,\r\n      gpuInfo,\r\n      recommendedSettings,\r\n      isAccelerationAvailable: await isGPUAccelerationEnabled(),\r\n      recommendation: getGPURecommendationMessage(gpuType, recommendedSettings)\r\n    };\r\n  } catch (error) {\r\n    console.error('GPU 권장 설정 가져오기 실패:', error);\r\n    \r\n    return {\r\n      gpuType: 'Unknown',\r\n      gpuInfo: { renderer: 'Unknown', vendor: 'Unknown', isAccelerated: false },\r\n      recommendedSettings: GPU_PROFILES.LowPower,\r\n      isAccelerationAvailable: false,\r\n      recommendation: 'GPU 정보를 가져올 수 없어 기본 CPU 처리 모드를 권장합니다.'\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 타입과 설정에 따른 권장 메시지 생성\r\n */\r\nfunction getGPURecommendationMessage(gpuType: string, settings: GPUSettings): string {\r\n  switch (gpuType) {\r\n    case 'DiscreteGpu':\r\n      return '고성능 디스크리트 GPU가 감지되었습니다. GPU 가속화를 활성화하면 최상의 성능을 얻을 수 있습니다.';\r\n    case 'IntegratedGpu':\r\n      return '내장 GPU가 감지되었습니다. 균형 잡힌 성능과 전력 효율성을 위해 표준 설정을 권장합니다.';\r\n    case 'LowPower':\r\n      return '저전력 GPU가 감지되었습니다. 메모리와 배터리 사용을 최적화하기 위해 CPU 중심 처리를 권장합니다.';\r\n    default:\r\n      return '시스템에 맞는 기본 설정이 적용되었습니다.';\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\gpu-settings.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":52,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":52,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":66,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":89,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":89,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":116,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":116,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":134,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":134,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":134,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":134,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3167,3207],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":136,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":136,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":146,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":146,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":147,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":147,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":150,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":150,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":162,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":162,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":216,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":216,"endColumn":12}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GPU 설정 관리 유틸리티\r\n * \r\n * 이 모듈은 애플리케이션의 GPU 가속화 설정을 관리하고\r\n * 네이티브 모듈과 JavaScript 간의 설정 동기화를 처리합니다.\r\n */\r\n\r\nimport { getLocalStorage as getStorageItem, setLocalStorage as setStorageItem } from './storage-utils';\r\nimport { setGpuAcceleration, getGpuInfo } from './nativeModuleClient';\r\n\r\n// GPU 설정 인터페이스\r\nexport interface GpuSettings {\r\n  useHardwareAcceleration: boolean;\r\n  processingMode: 'auto' | 'normal' | 'cpu-intensive' | 'gpu-intensive';\r\n  gpuVendor: 'auto' | 'nvidia' | 'amd' | 'intel' | 'apple' | 'software';\r\n  highPerformance: boolean;\r\n  preferredBackend?: 'vulkan' | 'directx' | 'metal' | 'opengl' | 'auto';\r\n  enableAdvancedFeatures: boolean;\r\n  memoryLimit?: number;\r\n}\r\n\r\n// 기본 GPU 설정\r\nconst defaultGpuSettings: GpuSettings = {\r\n  useHardwareAcceleration: true,\r\n  processingMode: 'auto',\r\n  gpuVendor: 'auto',\r\n  highPerformance: false,\r\n  preferredBackend: 'auto',\r\n  enableAdvancedFeatures: false,\r\n  memoryLimit: undefined,\r\n};\r\n\r\n// 스토리지 키\r\nconst STORAGE_KEY = 'gpu-settings';\r\n\r\n/**\r\n * GPU 설정 불러오기\r\n * @returns Promise<GpuSettings> 현재 설정\r\n */\r\nexport async function loadGpuSettings(): Promise<GpuSettings> {\r\n  try {\r\n    const settings = await getStorageItem<GpuSettings>(STORAGE_KEY);\r\n    if (!settings) {\r\n      return defaultGpuSettings;\r\n    }\r\n    \r\n    return {\r\n      ...defaultGpuSettings,\r\n      ...settings\r\n    };\r\n  } catch (error) {\r\n    console.error('GPU 설정 로드 오류:', error);\r\n    return defaultGpuSettings;\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 설정 저장\r\n * @param settings 저장할 설정\r\n */\r\nexport async function saveGpuSettings(settings: GpuSettings): Promise<boolean> {\r\n  try {\r\n    await setStorageItem(STORAGE_KEY, settings);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('GPU 설정 저장 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 가속화 설정\r\n * @param enabled 가속화 활성화 여부\r\n * @returns 설정 적용 성공 여부\r\n */\r\nexport async function setGpuAccelerationState(enabled: boolean): Promise<boolean> {\r\n  try {\r\n    const success = await setGpuAcceleration(enabled);\r\n    \r\n    if (success) {\r\n      // 설정 업데이트\r\n      const settings = await loadGpuSettings();\r\n      settings.useHardwareAcceleration = enabled;\r\n      await saveGpuSettings(settings);\r\n    }\r\n    \r\n    return success;\r\n  } catch (error) {\r\n    console.error('GPU 가속화 설정 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// 전역 설정 저장소 타입에 맞게 선언\r\n// 타입 선언은 types-declarations.d.ts에 정의된 것과 일치시킴\r\ndeclare global {\r\n  interface Window {\r\n    __gpuAccelerator?: any;\r\n  }\r\n}\r\n\r\n/**\r\n * 현재 GPU 정보 가져오기\r\n * @returns GPU 정보 객체\r\n */\r\nexport async function getGpuInformation(): Promise<any | null> {\r\n  try {\r\n    const response = await getGpuInfo();\r\n    \r\n    if (response.success && response.gpuInfo) {\r\n      return response.gpuInfo;\r\n    }\r\n    \r\n    return null;\r\n  } catch (error) {\r\n    console.error('GPU 정보 가져오기 오류:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 설정 초기화\r\n */\r\nexport async function initializeGpuSettings(): Promise<void> {\r\n  try {\r\n    const settings = await loadGpuSettings();\r\n    \r\n    // 하드웨어 가속화 설정 적용\r\n    await setGpuAccelerationState(settings.useHardwareAcceleration);\r\n    \r\n    // 전역 설정 객체 업데이트\r\n    updateGlobalGpuSettings(settings);\r\n    \r\n    console.log('GPU 설정 초기화 완료:', settings);\r\n  } catch (error) {\r\n    console.error('GPU 설정 초기화 중 오류 발생:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 전역 GPU 설정 객체 업데이트\r\n */\r\nfunction updateGlobalGpuSettings(settings: GpuSettings): void {\r\n  // 윈도우 객체가 정의된 경우에만 실행\r\n  if (typeof window !== 'undefined') {\r\n    if (!window.__gpuAccelerator) {\r\n      window.__gpuAccelerator = {};\r\n    }\r\n    \r\n    window.__gpuAccelerator.settings = settings;\r\n  }\r\n}\r\n\r\n/**\r\n * 기본 설정으로 재설정\r\n * @returns 재설정 성공 여부\r\n */\r\nexport async function resetGpuSettings(): Promise<boolean> {\r\n  try {\r\n    return await saveGpuSettings(defaultGpuSettings);\r\n  } catch (error) {\r\n    console.error('GPU 설정 재설정 중 오류 발생:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 시스템에 적합한 GPU 설정 추천\r\n * @returns 추천 설정\r\n */\r\nexport async function getRecommendedGpuSettings(): Promise<Partial<GpuSettings>> {\r\n  try {\r\n    // GPU 정보 가져오기\r\n    const gpuInfo = await getGpuInformation();\r\n    \r\n    if (!gpuInfo) {\r\n      // GPU 정보를 가져올 수 없는 경우 기본 설정 반환\r\n      return {\r\n        useHardwareAcceleration: false,\r\n        processingMode: 'cpu-intensive',\r\n        highPerformance: false\r\n      };\r\n    }\r\n    \r\n    // GPU 유형에 따른 설정 추천\r\n    const deviceType = gpuInfo.device_type || '';\r\n    const isIntegrated = deviceType.includes('Integrated');\r\n    const isDiscrete = deviceType.includes('Discrete');\r\n    \r\n    if (isDiscrete) {\r\n      // 디스크리트 GPU - 고성능 설정\r\n      return {\r\n        useHardwareAcceleration: true,\r\n        processingMode: 'gpu-intensive',\r\n        highPerformance: true,\r\n        memoryLimit: 512  // 512MB\r\n      };\r\n    } else if (isIntegrated) {\r\n      // 통합 GPU - 균형 잡힌 설정\r\n      return {\r\n        useHardwareAcceleration: true,\r\n        processingMode: 'auto',\r\n        highPerformance: false,\r\n        memoryLimit: 256  // 256MB\r\n      };\r\n    } else {\r\n      // 기타 또는 알 수 없음 - 안전한 설정\r\n      return {\r\n        useHardwareAcceleration: true,\r\n        processingMode: 'normal',\r\n        highPerformance: false,\r\n        memoryLimit: 128  // 128MB\r\n      };\r\n    }\r\n  } catch (error) {\r\n    console.error('GPU 설정 추천 중 오류 발생:', error);\r\n    return {\r\n      useHardwareAcceleration: false,\r\n      processingMode: 'cpu-intensive'\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\gpu\\functions.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":27,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":27,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":48,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":48,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":69,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":69,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":94,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":94,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":122,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":122,"endColumn":12}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GPU 작업 함수 모듈\r\n * Rust 네이티브 모듈과 통신하는 함수들을 제공합니다.\r\n */\r\n\r\nimport { GpuTaskType } from '@/types/native-module';\r\nimport { performGpuComputation } from '../nativeModuleClient';\r\n\r\n/**\r\n * 행렬 곱셈 계산\r\n */\r\nexport async function performMatrixMultiplication(\r\n  matrixA: number[][],\r\n  matrixB: number[][],\r\n  options: { size?: string } = {}\r\n) {\r\n  try {\r\n    const data = {\r\n      matrix_a: matrixA,\r\n      matrix_b: matrixB,\r\n      size: options.size || 'medium'\r\n    };\r\n    \r\n    const result = await performGpuComputation(data, GpuTaskType.MatrixMultiplication);\r\n    return result.result;\r\n  } catch (error) {\r\n    console.error('행렬 곱셈 오류:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * 텍스트 분석 수행\r\n */\r\nexport async function performTextAnalysis(\r\n  text: string,\r\n  options: { size?: string } = {}\r\n) {\r\n  try {\r\n    const data = {\r\n      text,\r\n      size: options.size || 'medium'\r\n    };\r\n    \r\n    const result = await performGpuComputation(data, GpuTaskType.TextAnalysis);\r\n    return result.result;\r\n  } catch (error) {\r\n    console.error('텍스트 분석 오류:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * 타이핑 패턴 감지\r\n */\r\nexport async function performPatternDetection(\r\n  keyPresses: string[],\r\n  timestamps: number[]\r\n) {\r\n  try {\r\n    const data = {\r\n      keyPresses,\r\n      timestamps\r\n    };\r\n    \r\n    const result = await performGpuComputation(data, GpuTaskType.PatternDetection);\r\n    return result.result;\r\n  } catch (error) {\r\n    console.error('패턴 감지 오류:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * 타이핑 통계 계산\r\n */\r\nexport async function calculateTypingStatistics(\r\n  keyCount: number,\r\n  typingTime: number,\r\n  errors: number,\r\n  content: string\r\n) {\r\n  try {\r\n    const data = {\r\n      keyCount,\r\n      typingTime,\r\n      errors,\r\n      content\r\n    };\r\n    \r\n    const result = await performGpuComputation(data, GpuTaskType.TypingStatistics);\r\n    return result.result;\r\n  } catch (error) {\r\n    console.error('타이핑 통계 계산 오류:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 가용성 체크\r\n */\r\nexport async function checkGpuCapabilities() {\r\n  try {\r\n    // 간단한 행렬 계산으로 GPU 가용성 테스트\r\n    const testMatrix = [\r\n      [1, 2],\r\n      [3, 4]\r\n    ];\r\n    \r\n    const result = await performMatrixMultiplication(\r\n      testMatrix,\r\n      testMatrix,\r\n      { size: 'small' }\r\n    );\r\n    \r\n    return {\r\n      available: true,\r\n      computationTime: result.computation_time_ms,\r\n      gpuInfo: result.gpu_info\r\n    };\r\n  } catch (error) {\r\n    console.warn('GPU 기능 테스트 실패:', error);\r\n    return {\r\n      available: false,\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류'\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\index.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'MemoryOptimizer' is defined but never used.","line":34,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":34,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MemoryOptimizer' is defined but never used.","line":34,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":34,"endColumn":26},{"ruleId":"no-unused-vars","severity":2,"message":"'emergency' is defined but never used.","line":36,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":34},{"ruleId":"no-unused-vars","severity":2,"message":"'aggressive' is defined but never used.","line":43,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":43,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":62,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":62,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":63,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":63,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":70,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":70,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":71,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":71,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":91,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":91,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":101,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":101,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":102,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":102,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":109,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":109,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":121,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":121,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":122,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":122,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":129,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":129,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":137,"column":67,"nodeType":"Identifier","messageId":"undef","endLine":137,"endColumn":73},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":138,"column":8,"nodeType":"Identifier","messageId":"undef","endLine":138,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":140,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":140,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":150,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":150,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":151,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":151,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":153,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":153,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":158,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":158,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":163,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":163,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":172,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":172,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":173,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":173,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":178,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":178,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":187,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":187,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":187,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":187,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":188,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":188,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":200,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":200,"endColumn":12}],"suppressedMessages":[],"errorCount":30,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 유틸리티 통합 내보내기\r\n */\r\n\r\n// 선택적 명시적 내보내기로 모호함 해결\r\nexport { formatDate } from './date-utils';\r\nexport { truncate as truncateText, stripHtml as sanitizeHtml } from './string-utils'; // 'sanitizeText' 대신 실제 함수인 'stripHtml' 사용\r\n\r\n// 명시적 이름 지정으로 중복 방지\r\nexport { formatBytes as formatBytesSize } from './common-utils';\r\n\r\n// 메모리 관련 유틸리티 \r\n// 'cleanupDom', 'cleanupCache', 'optimizeResources' 함수는 'memory/index.ts'에서 가져옵니다\r\n// 이렇게 하면 'memory/optimization-utils'의 문제를 피할 수 있습니다\r\nexport { \r\n  cleanupDom, \r\n  cleanupCache, \r\n  optimizeResources \r\n} from './memory';\r\n\r\n// 중복되는 내보내기를 별칭으로 지정\r\nexport { \r\n  convertNativeMemoryInfo as convertMemoryInfo \r\n} from './memory';\r\n\r\n// window-utils 대체 구현\r\nexport const setupFullscreenListeners = () => {};\r\nexport const exitFullscreen = () => {};\r\n\r\n// 타입 정의 영역 추가\r\nimport { MemoryInfo } from '@/types';\r\n\r\n// 메모리 옵티마이저 인터페이스 정의\r\ninterface MemoryOptimizer {\r\n  suggestGarbageCollection: () => void;\r\n  requestGC: (emergency?: boolean) => Promise<any>;\r\n  clearBrowserCaches: () => Promise<boolean>;\r\n  clearStorageCaches: () => boolean;\r\n  checkMemoryUsage: () => Record<string, any> | null;\r\n  forceGC: () => boolean;\r\n  getMemoryUsagePercentage: () => Promise<number>;\r\n  getMemoryInfo: () => Promise<Partial<MemoryInfo>>;\r\n  optimizeMemory: (aggressive?: boolean) => Promise<any>;\r\n}\r\n\r\n/**\r\n * 메모리 옵티마이저 초기화\r\n */\r\nexport function setupMemoryOptimizer() {\r\n  if (typeof window === 'undefined') return;\r\n  \r\n  // 추가 구현 필요 시 여기에 코드 추가\r\n}\r\n\r\n// 메모리 정보 얻기 함수\r\nexport async function getMemoryInfo() {\r\n  if (typeof window === 'undefined') {\r\n    return null;\r\n  }\r\n  \r\n  try {\r\n    if (window.__memoryOptimizer?.getMemoryInfo) {\r\n      return await window.__memoryOptimizer.getMemoryInfo();\r\n    }\r\n    \r\n    // 브라우저 기본 메모리 정보 가져오기\r\n    const memoryInfo = {} as Partial<MemoryInfo>;\r\n    \r\n    // performance.memory가 있는 경우 (Chrome)\r\n    if (performance && (performance as any).memory) {\r\n      const memoryUsage = (performance as any).memory as Record<string, number>;\r\n      \r\n      // 안전한 타입 변환을 위해 unknown을 거쳐서 변환\r\n      memoryInfo.heapUsed = (memoryUsage as unknown as Record<string, number>).usedJSHeapSize;\r\n      memoryInfo.heapTotal = (memoryUsage as unknown as Record<string, number>).totalJSHeapSize;\r\n      memoryInfo.heapLimit = (memoryUsage as unknown as Record<string, number>).jsHeapSizeLimit;\r\n    }\r\n    \r\n    // MB 단위 계산\r\n    if (memoryInfo.heapUsed !== undefined) {\r\n      memoryInfo.heapUsedMB = memoryInfo.heapUsed / (1024 * 1024);\r\n    }\r\n    \r\n    // 사용 비율 계산\r\n    if (memoryInfo.heapUsed !== undefined && memoryInfo.heapTotal !== undefined) {\r\n      memoryInfo.percentUsed = (memoryInfo.heapUsed / memoryInfo.heapTotal) * 100;\r\n    }\r\n    \r\n    return memoryInfo;\r\n  } catch (error) {\r\n    console.error('메모리 정보 얻기 실패:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// 메모리 사용량 백분율 가져오기\r\nexport async function getMemoryUsagePercentage(): Promise<number> {\r\n  if (typeof window === 'undefined') return 0;\r\n  \r\n  try {\r\n    if (window.__memoryOptimizer?.getMemoryUsagePercentage) {\r\n      const result = await window.__memoryOptimizer.getMemoryUsagePercentage();\r\n      return result || 0; // undefined일 경우 0 반환\r\n    }\r\n    \r\n    const memInfo = await getMemoryInfo();\r\n    return memInfo && memInfo.percentUsed !== undefined ? memInfo.percentUsed : 0;\r\n  } catch (error) {\r\n    console.error('메모리 사용량 백분율 가져오기 실패:', error);\r\n    return 0;\r\n  }\r\n}\r\n\r\n// 메모리 최적화 수행\r\nexport async function optimizeMemory(aggressive = false) {\r\n  if (typeof window === 'undefined') {\r\n    return { success: false, error: 'Window is not defined' };\r\n  }\r\n  \r\n  try {\r\n    if (window.__memoryOptimizer?.optimizeMemory) {\r\n      return await window.__memoryOptimizer.optimizeMemory(aggressive);\r\n    }\r\n    \r\n    // 기본 최적화 수행\r\n    await requestIdleCallback();\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('메모리 최적화 실패:', error);\r\n    return { success: false, error: String(error) };\r\n  }\r\n}\r\n\r\n// requestIdleCallback polyfill\r\nfunction requestIdleCallback(timeout = 1000): Promise<void> {\r\n  return new Promise(resolve => {\r\n    if (typeof window !== 'undefined' && 'requestIdleCallback' in window) {\r\n      (window as any).requestIdleCallback(() => resolve(), { timeout });\r\n    } else {\r\n      setTimeout(resolve, 100);\r\n    }\r\n  });\r\n}\r\n\r\n// 캐시 정리 도우미 함수들\r\nexport function clearObjectUrlCache() {\r\n  if (typeof window === 'undefined') return false;\r\n  \r\n  try {\r\n    if (window.__objectUrls) {\r\n      window.__objectUrls.forEach(url => {\r\n        try {\r\n          URL.revokeObjectURL(url);\r\n        } catch (e) {\r\n          // 무시\r\n        }\r\n      });\r\n      window.__objectUrls.clear();\r\n      return true;\r\n    }\r\n    return false;\r\n  } catch (err) {\r\n    console.error('Object URL 캐시 정리 실패:', err);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport function clearImageCache() {\r\n  if (typeof window === 'undefined') return false;\r\n  \r\n  try {\r\n    if (window.__imageResizeCache) {\r\n      window.__imageResizeCache = new Map();\r\n      return true;\r\n    }\r\n    return false;\r\n  } catch (err) {\r\n    console.error('이미지 캐시 정리 실패:', err);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport function getMemoryUsage(): Record<string, number> | null {\r\n  if (typeof window === 'undefined') return null;\r\n  \r\n  try {\r\n    if (performance && (performance as any).memory) {\r\n      const memUsage = (performance as any).memory;\r\n      \r\n      if (memUsage) {\r\n        return {\r\n          totalJSHeapSize: memUsage.totalJSHeapSize,\r\n          usedJSHeapSize: memUsage.usedJSHeapSize,\r\n          jsHeapSizeLimit: memUsage.jsHeapSizeLimit,\r\n        };\r\n      }\r\n    }\r\n    return null;\r\n  } catch (e) {\r\n    console.error('메모리 사용량 가져오기 실패:', e);\r\n    return null;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\interfaces\\memory-types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\localStorage.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":12,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":16,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":28,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":28,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":31,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":31,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":43,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":43,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":46,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":46,"endColumn":12}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 로컬 스토리지 유틸리티 함수\r\n */\r\n\r\n/**\r\n * 로컬 스토리지에서 값 가져오기\r\n */\r\nexport async function getLocalStorage<T>(key: string): Promise<T | null> {\r\n  if (typeof window === 'undefined') return null;\r\n\r\n  try {\r\n    const value = localStorage.getItem(key);\r\n    if (!value) return null;\r\n    return JSON.parse(value) as T;\r\n  } catch (error) {\r\n    console.error(`로컬 스토리지에서 ${key} 가져오기 오류:`, error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * 로컬 스토리지에 값 저장하기\r\n */\r\nexport async function setLocalStorage<T>(key: string, value: T): Promise<boolean> {\r\n  if (typeof window === 'undefined') return false;\r\n\r\n  try {\r\n    localStorage.setItem(key, JSON.stringify(value));\r\n    return true;\r\n  } catch (error) {\r\n    console.error(`로컬 스토리지에 ${key} 저장 오류:`, error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 로컬 스토리지에서 값 삭제하기\r\n */\r\nexport async function removeLocalStorage(key: string): Promise<boolean> {\r\n  if (typeof window === 'undefined') return false;\r\n\r\n  try {\r\n    localStorage.removeItem(key);\r\n    return true;\r\n  } catch (error) {\r\n    console.error(`로컬 스토리지에서 ${key} 삭제 오류:`, error);\r\n    return false;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\log-learning.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'LogEntry' is defined but never used.","line":7,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'LogEntry' is defined but never used.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":18},{"ruleId":"no-unused-vars","severity":2,"message":"'MEMORY_OPTIMIZATION' is defined but never used.","line":14,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":22},{"ruleId":"no-unused-vars","severity":2,"message":"'ERROR_PREDICTION' is defined but never used.","line":15,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'PERFORMANCE_OPTIMIZATION' is defined but never used.","line":16,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":27},{"ruleId":"no-unused-vars","severity":2,"message":"'USER_BEHAVIOR' is defined but never used.","line":17,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":16},{"ruleId":"no-unused-vars","severity":2,"message":"'timestamps' is assigned a value but never used.","line":586,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":586,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'timestamps' is assigned a value but never used.","line":586,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":586,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'memoryValues' is assigned a value but never used.","line":587,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":587,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'memoryValues' is assigned a value but never used.","line":587,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":587,"endColumn":21},{"ruleId":"no-unused-vars","severity":2,"message":"'i' is defined but never used.","line":591,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":591,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'i' is defined but never used. Allowed unused args must match /^_/u.","line":591,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":591,"endColumn":15}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 로그 학습 및 최적화 유틸리티\r\n * \r\n * 로그 데이터를 분석하여 학습하고 애플리케이션을 최적화하는 기능 제공\r\n */\r\n\r\nimport { LogEntry, LogType, searchLogs } from './log-utils';\r\nimport { logger } from './memory/logger';\r\n\r\n/**\r\n * 학습 모델 타입 정의\r\n */\r\nexport enum LearningModelType {\r\n  MEMORY_OPTIMIZATION = 'memory_optimization',\r\n  ERROR_PREDICTION = 'error_prediction',\r\n  PERFORMANCE_OPTIMIZATION = 'performance_optimization',\r\n  USER_BEHAVIOR = 'user_behavior'\r\n}\r\n\r\n/**\r\n * 학습 결과 인터페이스\r\n */\r\nexport interface LearningResult {\r\n  modelType: LearningModelType;\r\n  timestamp: number;\r\n  insights: any[];\r\n  recommendations: string[];\r\n  metrics: { [key: string]: number };\r\n}\r\n\r\n/**\r\n * 메모리 최적화 학습 옵션\r\n */\r\nexport interface MemoryOptimizationOptions {\r\n  timeRange?: {\r\n    startTime?: number;\r\n    endTime?: number;\r\n  };\r\n  minSampleSize?: number;\r\n  sessionLimit?: number;\r\n}\r\n\r\n/**\r\n * 로그 데이터로부터 메모리 사용 패턴을 학습합니다.\r\n * \r\n * @param options - 메모리 최적화 학습 옵션\r\n * @returns 학습 결과\r\n */\r\nexport async function learnMemoryUsagePatterns(\r\n  options: MemoryOptimizationOptions = {}\r\n): Promise<LearningResult> {\r\n  try {\r\n    logger.info('메모리 사용 패턴 학습 시작');\r\n    \r\n    // 기본값 설정\r\n    const minSampleSize = options.minSampleSize || 50;\r\n    const now = Date.now();\r\n    const startTime = options.timeRange?.startTime || now - 7 * 24 * 60 * 60 * 1000; // 기본 1주일\r\n    const endTime = options.timeRange?.endTime || now;\r\n    \r\n    // 메모리 관련 로그 검색\r\n    const memoryLogs = await searchLogs({\r\n      type: LogType.MEMORY,\r\n      startTime,\r\n      endTime,\r\n      limit: 1000 // 최대 1000개까지만 가져옴\r\n    });\r\n    \r\n    if (memoryLogs.length < minSampleSize) {\r\n      logger.warn(`충분한 메모리 로그 샘플이 없습니다. 필요: ${minSampleSize}, 현재: ${memoryLogs.length}`);\r\n    }\r\n    \r\n    // 메모리 사용량 분석\r\n    const memoryUsages = memoryLogs.map(log => {\r\n      const metadata = log.metadata || {};\r\n      return {\r\n        timestamp: log.timestamp,\r\n        heapUsed: metadata.heapUsed || 0,\r\n        heapTotal: metadata.heapTotal || 0,\r\n        percentUsed: metadata.percentUsed || 0\r\n      };\r\n    });\r\n    \r\n    // 시간대별 메모리 사용량 집계\r\n    const hourlyUsage: { [hour: number]: number[] } = {};\r\n    memoryUsages.forEach(usage => {\r\n      const date = new Date(usage.timestamp);\r\n      const hour = date.getHours();\r\n      \r\n      if (!hourlyUsage[hour]) hourlyUsage[hour] = [];\r\n      hourlyUsage[hour].push(usage.percentUsed);\r\n    });\r\n    \r\n    // 평균 시간대별 사용량 계산\r\n    const hourlyAverages = Object.entries(hourlyUsage).map(([hour, values]) => ({\r\n      hour: parseInt(hour),\r\n      avgUsage: values.reduce((sum, val) => sum + val, 0) / values.length,\r\n      count: values.length\r\n    }));\r\n    \r\n    // 최대 메모리 사용 시간대 식별\r\n    hourlyAverages.sort((a, b) => b.avgUsage - a.avgUsage);\r\n    const peakHours = hourlyAverages.slice(0, 3);\r\n    \r\n    // 메모리 누수 가능성이 있는 세션 식별\r\n    const sessionData: { [sessionId: string]: number[] } = {};\r\n    memoryLogs.forEach(log => {\r\n      if (!log.sessionId) return;\r\n      \r\n      const metadata = log.metadata || {};\r\n      if (!sessionData[log.sessionId]) sessionData[log.sessionId] = [];\r\n      sessionData[log.sessionId].push(metadata.percentUsed || 0);\r\n    });\r\n    \r\n    // 세션별로 메모리 증가 추세 분석\r\n    const sessionTrends = Object.entries(sessionData).map(([sessionId, usages]) => {\r\n      if (usages.length < 5) return null; // 너무 짧은 세션은 제외\r\n      \r\n      const firstHalf = usages.slice(0, Math.floor(usages.length / 2));\r\n      const secondHalf = usages.slice(Math.floor(usages.length / 2));\r\n      \r\n      const firstAvg = firstHalf.reduce((sum, val) => sum + val, 0) / firstHalf.length;\r\n      const secondAvg = secondHalf.reduce((sum, val) => sum + val, 0) / secondHalf.length;\r\n      \r\n      const increaseTrend = secondAvg - firstAvg;\r\n      \r\n      return {\r\n        sessionId,\r\n        samplesCount: usages.length,\r\n        increaseTrend,\r\n        percentIncrease: (increaseTrend / firstAvg) * 100\r\n      };\r\n    }).filter(Boolean);\r\n    \r\n    // 메모리 증가 추세가 높은 세션 정렬\r\n    sessionTrends.sort((a, b) => b.increaseTrend - a.increaseTrend);\r\n    const problematicSessions = sessionTrends.filter(session => session.percentIncrease > 15);\r\n    \r\n    // 최적화 추천사항 생성\r\n    const recommendations = [];\r\n    \r\n    if (peakHours.length > 0) {\r\n      const formattedHours = peakHours.map(h => `${h.hour}시`).join(', ');\r\n      recommendations.push(`메모리 사용량이 높은 시간대(${formattedHours})에 자동 메모리 최적화를 예약하세요.`);\r\n    }\r\n    \r\n    if (problematicSessions.length > 0) {\r\n      recommendations.push(`메모리 누수 가능성이 있는 ${problematicSessions.length}개의 패턴이 발견되었습니다.`);\r\n      \r\n      if (problematicSessions.length > 2) {\r\n        recommendations.push('장기간 사용 시 주기적인 앱 재시작 일정을 설정하세요.');\r\n      }\r\n    }\r\n    \r\n    // 메모리 GC 최적 주기 추천\r\n    const gcSuggestion = calculateOptimalGCInterval(memoryUsages);\r\n    if (gcSuggestion) {\r\n      recommendations.push(`최적의 가비지 컬렉션 주기: ${gcSuggestion}ms`);\r\n    }\r\n    \r\n    // 학습 결과 반환\r\n    const result: LearningResult = {\r\n      modelType: LearningModelType.MEMORY_OPTIMIZATION,\r\n      timestamp: Date.now(),\r\n      insights: [\r\n        { type: 'peakHours', data: peakHours },\r\n        { type: 'problematicSessions', data: problematicSessions.slice(0, 5) },\r\n        { type: 'hourlyUsage', data: hourlyAverages },\r\n      ],\r\n      recommendations,\r\n      metrics: {\r\n        sampleSize: memoryLogs.length,\r\n        avgMemoryUsage: memoryUsages.reduce((sum, u) => sum + u.percentUsed, 0) / memoryUsages.length,\r\n        peakMemoryUsage: Math.max(...memoryUsages.map(u => u.percentUsed)),\r\n        problematicSessionsCount: problematicSessions.length\r\n      }\r\n    };\r\n    \r\n    logger.info('메모리 사용 패턴 학습 완료', { \r\n      sampleSize: memoryLogs.length, \r\n      recommendations: recommendations.length \r\n    });\r\n    \r\n    return result;\r\n  } catch (error) {\r\n    logger.error('메모리 사용 패턴 학습 중 오류:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * 사용자 행동 패턴 학습 옵션\r\n */\r\nexport interface UserBehaviorOptions {\r\n  timeRange?: {\r\n    startTime?: number;\r\n    endTime?: number;\r\n  };\r\n  minSampleSize?: number;\r\n}\r\n\r\n/**\r\n * 로그 데이터로부터 사용자 행동 패턴을 학습합니다.\r\n * \r\n * @param options - 사용자 행동 학습 옵션\r\n * @returns 학습 결과\r\n */\r\nexport async function learnUserBehaviorPatterns(\r\n  options: UserBehaviorOptions = {}\r\n): Promise<LearningResult> {\r\n  try {\r\n    logger.info('사용자 행동 패턴 학습 시작');\r\n    \r\n    // 기본값 설정\r\n    const minSampleSize = options.minSampleSize || 20;\r\n    const now = Date.now();\r\n    const startTime = options.timeRange?.startTime || now - 30 * 24 * 60 * 60 * 1000; // 기본 30일\r\n    const endTime = options.timeRange?.endTime || now;\r\n    \r\n    // 대화 로그 검색\r\n    const conversationLogs = await searchLogs({\r\n      type: LogType.CONVERSATION,\r\n      startTime,\r\n      endTime,\r\n      limit: 1000 // 최대 1000개까지만 가져옴\r\n    });\r\n    \r\n    if (conversationLogs.length < minSampleSize) {\r\n      logger.warn(`충분한 대화 로그 샘플이 없습니다. 필요: ${minSampleSize}, 현재: ${conversationLogs.length}`);\r\n    }\r\n    \r\n    // 대화 데이터 추출\r\n    const conversations = conversationLogs.map(log => {\r\n      try {\r\n        return {\r\n          ...log,\r\n          parsedContent: JSON.parse(log.content)\r\n        };\r\n      } catch (e) {\r\n        return {\r\n          ...log,\r\n          parsedContent: {\r\n            userMessage: '',\r\n            aiResponse: '',\r\n            timestamp: log.timestamp\r\n          }\r\n        };\r\n      }\r\n    });\r\n    \r\n    // 자주 사용되는 단어/구문 분석\r\n    const wordFrequency = {};\r\n    conversations.forEach(conv => {\r\n      const userMessage = conv.parsedContent?.userMessage || '';\r\n      if (!userMessage) return;\r\n      \r\n      const words = userMessage\r\n        .toLowerCase()\r\n        .replace(/[^\\w\\s가-힣]/g, ' ')\r\n        .split(/\\s+/)\r\n        .filter(word => word.length > 1);\r\n      \r\n      words.forEach(word => {\r\n        wordFrequency[word] = (wordFrequency[word] || 0) + 1;\r\n      });\r\n    });\r\n    \r\n    // 가장 많이 사용된 단어 추출\r\n    const topWords = Object.entries(wordFrequency)\r\n      .sort((a, b) => b[1] - a[1])\r\n      .slice(0, 20)\r\n      .map(([word, count]) => ({ word, count }));\r\n    \r\n    // 시간대별 활동 패턴 분석\r\n    const hourlyActivity = {};\r\n    conversations.forEach(conv => {\r\n      const timestamp = conv.timestamp || conv.parsedContent?.timestamp;\r\n      if (!timestamp) return;\r\n      \r\n      const date = new Date(timestamp);\r\n      const hour = date.getHours();\r\n      \r\n      hourlyActivity[hour] = (hourlyActivity[hour] || 0) + 1;\r\n    });\r\n    \r\n    // 메시지 길이 분석\r\n    const messageLengths = conversations.map(conv => {\r\n      const userMessage = conv.parsedContent?.userMessage || '';\r\n      return userMessage.length;\r\n    });\r\n    \r\n    const avgMessageLength = messageLengths.reduce((sum, len) => sum + len, 0) / messageLengths.length;\r\n    \r\n    // 세션별 대화 수 분석\r\n    const sessionConversations = {};\r\n    conversations.forEach(conv => {\r\n      if (!conv.sessionId) return;\r\n      sessionConversations[conv.sessionId] = (sessionConversations[conv.sessionId] || 0) + 1;\r\n    });\r\n    \r\n    const sessionsArray = Object.entries(sessionConversations).map(([id, count]) => ({ id, count }));\r\n    const avgConversationsPerSession = sessionsArray.reduce((sum, session) => sum + session.count, 0) / sessionsArray.length;\r\n    \r\n    // 활동이 가장 많은 시간대 식별\r\n    const activeHours = Object.entries(hourlyActivity)\r\n      .sort((a, b) => b[1] - a[1])\r\n      .slice(0, 3)\r\n      .map(([hour, count]) => ({ hour: parseInt(hour), count }));\r\n    \r\n    // 추천사항 생성\r\n    const recommendations = [];\r\n    \r\n    if (activeHours.length > 0) {\r\n      const formattedHours = activeHours.map(h => `${h.hour}시`).join(', ');\r\n      recommendations.push(`사용자는 ${formattedHours}에 가장 활발하게 활동합니다. 이 시간대에 성능을 최적화하세요.`);\r\n    }\r\n    \r\n    if (avgMessageLength > 100) {\r\n      recommendations.push(`사용자는 평균 ${Math.round(avgMessageLength)}자의 긴 메시지를 보냅니다. 대용량 텍스트 처리를 최적화하세요.`);\r\n    } else {\r\n      recommendations.push(`사용자는 평균 ${Math.round(avgMessageLength)}자의 짧은 메시지를 보냅니다. 빠른 응답에 집중하세요.`);\r\n    }\r\n    \r\n    if (avgConversationsPerSession > 10) {\r\n      recommendations.push(`사용자는 세션당 평균 ${Math.round(avgConversationsPerSession)}개의 대화를 나눕니다. 장기 세션 메모리 관리를 최적화하세요.`);\r\n    }\r\n    \r\n    if (topWords.length > 0) {\r\n      const topThreeWords = topWords.slice(0, 3).map(w => w.word).join(', ');\r\n      recommendations.push(`가장 자주 사용된 키워드는 \"${topThreeWords}\"입니다. 이와 관련된 응답을 최적화하세요.`);\r\n    }\r\n    \r\n    // 학습 결과 반환\r\n    const result: LearningResult = {\r\n      modelType: LearningModelType.USER_BEHAVIOR,\r\n      timestamp: Date.now(),\r\n      insights: [\r\n        { type: 'topWords', data: topWords },\r\n        { type: 'activeHours', data: activeHours },\r\n        { type: 'messageLengths', data: { average: avgMessageLength, max: Math.max(...messageLengths) } },\r\n        { type: 'sessionsActivity', data: { average: avgConversationsPerSession, maxCount: Math.max(...Object.values(sessionConversations)) } },\r\n      ],\r\n      recommendations,\r\n      metrics: {\r\n        sampleSize: conversations.length,\r\n        uniqueWords: Object.keys(wordFrequency).length,\r\n        avgMessageLength,\r\n        avgConversationsPerSession\r\n      }\r\n    };\r\n    \r\n    logger.info('사용자 행동 패턴 학습 완료', { \r\n      sampleSize: conversations.length, \r\n      recommendations: recommendations.length \r\n    });\r\n    \r\n    return result;\r\n  } catch (error) {\r\n    logger.error('사용자 행동 패턴 학습 중 오류:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * 오류 예측 학습 옵션\r\n */\r\nexport interface ErrorPredictionOptions {\r\n  timeRange?: {\r\n    startTime?: number;\r\n    endTime?: number;\r\n  };\r\n  minSampleSize?: number;\r\n}\r\n\r\n/**\r\n * 로그 데이터로부터 오류 패턴을 학습하여 예측 모델을 생성합니다.\r\n * \r\n * @param options - 오류 예측 학습 옵션\r\n * @returns 학습 결과\r\n */\r\nexport async function learnErrorPatterns(\r\n  options: ErrorPredictionOptions = {}\r\n): Promise<LearningResult> {\r\n  try {\r\n    logger.info('오류 패턴 학습 시작');\r\n    \r\n    // 기본값 설정\r\n    const minSampleSize = options.minSampleSize || 10;\r\n    const now = Date.now();\r\n    const startTime = options.timeRange?.startTime || now - 30 * 24 * 60 * 60 * 1000; // 기본 30일\r\n    const endTime = options.timeRange?.endTime || now;\r\n    \r\n    // 오류 로그 검색\r\n    const errorLogs = await searchLogs({\r\n      type: LogType.ERROR,\r\n      startTime,\r\n      endTime,\r\n      limit: 1000\r\n    });\r\n    \r\n    if (errorLogs.length < minSampleSize) {\r\n      logger.warn(`충분한 오류 로그 샘플이 없습니다. 필요: ${minSampleSize}, 현재: ${errorLogs.length}`);\r\n    }\r\n    \r\n    // 오류 메시지 분류\r\n    const errorGroups = {};\r\n    errorLogs.forEach(log => {\r\n      // 오류 메시지에서 핵심 부분만 추출\r\n      const errorMessage = log.content || '';\r\n      const errorType = getErrorType(errorMessage);\r\n      \r\n      if (!errorGroups[errorType]) {\r\n        errorGroups[errorType] = {\r\n          count: 0,\r\n          examples: [],\r\n          sessionIds: new Set()\r\n        };\r\n      }\r\n      \r\n      errorGroups[errorType].count++;\r\n      \r\n      // 최대 5개까지만 예시 저장\r\n      if (errorGroups[errorType].examples.length < 5) {\r\n        errorGroups[errorType].examples.push({\r\n          message: errorMessage,\r\n          timestamp: log.timestamp\r\n        });\r\n      }\r\n      \r\n      // 세션 ID가 있는 경우 추가\r\n      if (log.sessionId) {\r\n        errorGroups[errorType].sessionIds.add(log.sessionId);\r\n      }\r\n    });\r\n    \r\n    // 가장 빈번한 오류 추출\r\n    const topErrors = Object.entries(errorGroups)\r\n      .map(([type, data]) => ({\r\n        type,\r\n        count: data.count,\r\n        examples: data.examples,\r\n        uniqueSessions: data.sessionIds.size\r\n      }))\r\n      .sort((a, b) => b.count - a.count);\r\n    \r\n    // 시간대별 오류 발생 패턴\r\n    const hourlyErrors = {};\r\n    errorLogs.forEach(log => {\r\n      const date = new Date(log.timestamp);\r\n      const hour = date.getHours();\r\n      \r\n      hourlyErrors[hour] = (hourlyErrors[hour] || 0) + 1;\r\n    });\r\n    \r\n    // 가장 오류가 많은 시간대\r\n    const errorPeakHours = Object.entries(hourlyErrors)\r\n      .sort((a, b) => b[1] - a[1])\r\n      .slice(0, 3)\r\n      .map(([hour, count]) => ({ hour: parseInt(hour), count }));\r\n    \r\n    // 추천사항 생성\r\n    const recommendations = [];\r\n    \r\n    if (topErrors.length > 0) {\r\n      const topError = topErrors[0];\r\n      recommendations.push(`가장 빈번한 오류 \"${topError.type}\"에 대한 예외 처리를 강화하세요. (${topError.count}회 발생)`);\r\n      \r\n      if (topError.uniqueSessions > 3) {\r\n        recommendations.push(`\"${topError.type}\" 오류가 ${topError.uniqueSessions}개의 다른 세션에서 발생했습니다. 시스템적 문제일 가능성이 있습니다.`);\r\n      }\r\n    }\r\n    \r\n    if (errorPeakHours.length > 0) {\r\n      const formattedHours = errorPeakHours.map(h => `${h.hour}시`).join(', ');\r\n      recommendations.push(`${formattedHours}에 오류 발생률이 높습니다. 이 시간대에 추가 모니터링을 설정하세요.`);\r\n    }\r\n    \r\n    if (errorLogs.length > 50) {\r\n      const errorRate = (errorLogs.length / ((endTime - startTime) / (24 * 60 * 60 * 1000))).toFixed(2);\r\n      recommendations.push(`일평균 ${errorRate}개의 오류가 발생합니다. 오류 처리 로직을 검토하세요.`);\r\n    }\r\n    \r\n    // 학습 결과 반환\r\n    const result: LearningResult = {\r\n      modelType: LearningModelType.ERROR_PREDICTION,\r\n      timestamp: Date.now(),\r\n      insights: [\r\n        { type: 'topErrors', data: topErrors.slice(0, 5) },\r\n        { type: 'errorPeakHours', data: errorPeakHours },\r\n        { type: 'errorDistribution', data: Object.fromEntries(topErrors.slice(0, 10).map(e => [e.type, e.count])) }\r\n      ],\r\n      recommendations,\r\n      metrics: {\r\n        sampleSize: errorLogs.length,\r\n        uniqueErrorTypes: Object.keys(errorGroups).length,\r\n        mostFrequentErrorCount: topErrors.length > 0 ? topErrors[0].count : 0,\r\n        errorVarietyIndex: Object.keys(errorGroups).length / errorLogs.length\r\n      }\r\n    };\r\n    \r\n    logger.info('오류 패턴 학습 완료', { \r\n      sampleSize: errorLogs.length, \r\n      errorTypes: Object.keys(errorGroups).length \r\n    });\r\n    \r\n    return result;\r\n  } catch (error) {\r\n    logger.error('오류 패턴 학습 중 오류:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * 여러 학습 결과를 통합하여 종합적인 최적화 추천을 생성합니다.\r\n * \r\n * @param results - 학습 결과 배열\r\n * @returns 통합된 추천사항 배열\r\n */\r\nexport function combineRecommendations(results: LearningResult[]): string[] {\r\n  // 모든 추천사항 수집\r\n  const allRecommendations = results.flatMap(result => result.recommendations);\r\n  \r\n  // 중복 제거 (유사한 추천사항 병합)\r\n  const uniqueRecommendations = [];\r\n  const addedKeywords = new Set();\r\n  \r\n  for (const rec of allRecommendations) {\r\n    // 문장에서 핵심 키워드 추출 (간단한 구현)\r\n    const keywords = rec.toLowerCase().replace(/[^\\w\\s가-힣]/g, ' ').split(/\\s+/).filter(w => w.length > 4);\r\n    \r\n    // 이미 유사한 키워드가 있는지 확인\r\n    let isDuplicate = false;\r\n    for (const keyword of keywords) {\r\n      if (addedKeywords.has(keyword)) {\r\n        isDuplicate = true;\r\n        break;\r\n      }\r\n    }\r\n    \r\n    if (!isDuplicate) {\r\n      uniqueRecommendations.push(rec);\r\n      keywords.forEach(keyword => addedKeywords.add(keyword));\r\n    }\r\n  }\r\n  \r\n  return uniqueRecommendations;\r\n}\r\n\r\n/**\r\n * 에러 메시지에서 에러 타입을 추출합니다.\r\n * \r\n * @param errorMessage - 에러 메시지\r\n * @returns 추출된 에러 타입\r\n */\r\nfunction getErrorType(errorMessage: string): string {\r\n  // 일반적인 JavaScript 오류 패턴 확인\r\n  if (errorMessage.includes('TypeError:')) return 'TypeError';\r\n  if (errorMessage.includes('ReferenceError:')) return 'ReferenceError';\r\n  if (errorMessage.includes('SyntaxError:')) return 'SyntaxError';\r\n  if (errorMessage.includes('RangeError:')) return 'RangeError';\r\n  if (errorMessage.includes('NetworkError:') || errorMessage.includes('네트워크')) return 'NetworkError';\r\n  if (errorMessage.includes('API 요청 실패') || errorMessage.includes('API request failed')) return 'APIError';\r\n  if (errorMessage.includes('Permission denied') || errorMessage.includes('권한')) return 'PermissionError';\r\n  if (errorMessage.includes('not found') || errorMessage.includes('찾을 수 없음')) return 'NotFoundError';\r\n  if (errorMessage.includes('메모리') || errorMessage.includes('memory')) return 'MemoryError';\r\n  \r\n  // 특정 키워드로 분류\r\n  if (errorMessage.includes('undefined') || errorMessage.includes('null')) return 'NullError';\r\n  if (errorMessage.includes('promise') || errorMessage.includes('async')) return 'AsyncError';\r\n  if (errorMessage.includes('초과') || errorMessage.includes('limit') || errorMessage.includes('threshold')) return 'LimitExceededError';\r\n  \r\n  // 기본값 반환\r\n  return 'UnknownError';\r\n}\r\n\r\n/**\r\n * 최적의 가비지 컬렉션 간격을 계산합니다.\r\n * \r\n * @param memoryUsages - 메모리 사용량 데이터\r\n * @returns 최적의 GC 간격(ms) 또는 null\r\n */\r\nfunction calculateOptimalGCInterval(memoryUsages: any[]): number | null {\r\n  if (memoryUsages.length < 10) return null;\r\n  \r\n  // 메모리 사용량 증가 패턴 분석\r\n  const timestamps = memoryUsages.map(u => u.timestamp);\r\n  const memoryValues = memoryUsages.map(u => u.percentUsed);\r\n  \r\n  // 정렬\r\n  const sortedData = memoryUsages\r\n    .map((u, i) => ({ timestamp: u.timestamp, value: u.percentUsed }))\r\n    .sort((a, b) => a.timestamp - b.timestamp);\r\n  \r\n  // 증가율 계산\r\n  const increases = [];\r\n  for (let i = 1; i < sortedData.length; i++) {\r\n    const timeDiff = sortedData[i].timestamp - sortedData[i-1].timestamp;\r\n    const valueDiff = sortedData[i].value - sortedData[i-1].value;\r\n    \r\n    if (valueDiff > 0 && timeDiff > 0) {\r\n      increases.push({\r\n        rate: valueDiff / timeDiff * 1000, // ms당 증가율을 초당 증가율로 변환\r\n        timeDiff\r\n      });\r\n    }\r\n  }\r\n  \r\n  if (increases.length < 5) return null;\r\n  \r\n  // 중앙값 계산\r\n  increases.sort((a, b) => a.rate - b.rate);\r\n  const medianRate = increases[Math.floor(increases.length / 2)].rate;\r\n  \r\n  // 메모리 사용량이 5% 증가하는데 걸리는 평균 시간 (밀리초)\r\n  const timeToIncrease5Percent = 5 / medianRate * 1000;\r\n  \r\n  // 적절한 GC 간격 = 메모리가 5% 증가하는 시간의 80%\r\n  // 이 값은 경험적으로 결정된 것이며, 상황에 따라 조정 가능\r\n  const suggestedInterval = Math.round(timeToIncrease5Percent * 0.8);\r\n  \r\n  // 합리적인 범위 내에 있는지 검증 (최소 10초, 최대 5분)\r\n  const minInterval = 10 * 1000;\r\n  const maxInterval = 5 * 60 * 1000;\r\n  \r\n  if (suggestedInterval < minInterval) return minInterval;\r\n  if (suggestedInterval > maxInterval) return maxInterval;\r\n  \r\n  return suggestedInterval;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\log-utils.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'CONVERSATION' is defined but never used.","line":14,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":15},{"ruleId":"no-unused-vars","severity":2,"message":"'ERROR' is defined but never used.","line":15,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":8},{"ruleId":"no-unused-vars","severity":2,"message":"'PERFORMANCE' is defined but never used.","line":16,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":14},{"ruleId":"no-unused-vars","severity":2,"message":"'MEMORY' is defined but never used.","line":17,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'SYSTEM' is defined but never used.","line":18,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":9},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":66,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":88,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":88,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'URLSearchParams' is not defined.","line":105,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":105,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":128,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":128,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":158,"column":43,"nodeType":"Identifier","messageId":"undef","endLine":158,"endColumn":55},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":161,"column":8,"nodeType":"Identifier","messageId":"undef","endLine":161,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":162,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":162,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'Blob' is not defined.","line":176,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":176,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'Blob' is not defined.","line":177,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":177,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'Blob' is not defined.","line":180,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":180,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'Blob' is not defined.","line":181,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":181,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":213,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":213,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":214,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":214,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":215,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":215,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":219,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":219,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":242,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":242,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":274,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":274,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":298,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":298,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":299,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":299,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":300,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":300,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":304,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":304,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":316,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":316,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":328,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":328,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":335,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":335,"endColumn":21}],"suppressedMessages":[],"errorCount":29,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 로그 저장 및 관리 유틸리티\r\n * \r\n * 애플리케이션 내의 대화 로그와 에러 로그를 저장하고 관리하는 기능 제공\r\n */\r\n\r\nimport { formatBytes, getCurrentTimestamp } from './common-utils';\r\nimport { logger } from './memory/logger';\r\n\r\n/**\r\n * 로그 타입 정의\r\n */\r\nexport enum LogType {\r\n  CONVERSATION = 'conversation', // 사용자와 AI 간 대화 로그\r\n  ERROR = 'error',               // 에러 로그\r\n  PERFORMANCE = 'performance',   // 성능 관련 로그\r\n  MEMORY = 'memory',             // 메모리 관련 로그\r\n  SYSTEM = 'system'              // 시스템 관련 로그\r\n}\r\n\r\n/**\r\n * 로그 데이터 인터페이스\r\n */\r\nexport interface LogEntry {\r\n  id?: string;           // 로그 고유 ID (저장 시 자동 생성)\r\n  type: LogType;         // 로그 타입\r\n  timestamp: number;     // 로그 생성 시간 (밀리초 타임스탬프)\r\n  content: string;       // 로그 내용\r\n  metadata?: any;        // 추가 메타데이터 (JSON 직렬화 가능한 객체)\r\n  tags?: string[];       // 로그 태그 (검색 및 필터링용)\r\n  sessionId?: string;    // 세션 ID\r\n}\r\n\r\n/**\r\n * 로그 검색 옵션 인터페이스\r\n */\r\nexport interface LogSearchOptions {\r\n  type?: LogType | LogType[];    // 검색할 로그 타입\r\n  startTime?: number;            // 검색 시작 시간\r\n  endTime?: number;              // 검색 종료 시간\r\n  tags?: string[];               // 검색할 태그\r\n  query?: string;                // 검색 쿼리 (로그 내용에서 검색)\r\n  limit?: number;                // 검색 결과 제한\r\n  offset?: number;               // 검색 결과 오프셋\r\n  sessionId?: string;            // 세션 ID로 검색\r\n}\r\n\r\n/**\r\n * 로그를 저장합니다.\r\n * \r\n * @param logEntry - 저장할 로그 데이터\r\n * @returns 저장된 로그 엔트리 (ID 포함)\r\n */\r\nexport async function saveLog(logEntry: Omit<LogEntry, 'id'>): Promise<LogEntry> {\r\n  try {\r\n    // 로그 ID 생성 (타임스탬프 + 랜덤 문자열)\r\n    const id = `${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;\r\n    \r\n    const log: LogEntry = {\r\n      ...logEntry,\r\n      id,\r\n      timestamp: logEntry.timestamp || getCurrentTimestamp()\r\n    };\r\n    \r\n    // 로그 API 엔드포인트로 저장 요청\r\n    const response = await fetch('/api/logs/save', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify(log),\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`로그 저장 실패: ${response.status} ${response.statusText}`);\r\n    }\r\n    \r\n    const result = await response.json();\r\n    \r\n    logger.debug(`로그 저장 완료 (ID: ${id}, 타입: ${logEntry.type})`);\r\n    return result.data;\r\n  } catch (error) {\r\n    logger.error('로그 저장 중 오류 발생:', error);\r\n    \r\n    // API 호출 실패시 로컬 스토리지에 임시 저장\r\n    try {\r\n      const storageKey = `log_${Date.now()}`;\r\n      localStorage.setItem(storageKey, JSON.stringify(logEntry));\r\n    } catch (storageError) {\r\n      logger.error('로그의 로컬 스토리지 백업 저장 실패:', storageError);\r\n    }\r\n    \r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * 로그를 검색합니다.\r\n * \r\n * @param options - 검색 옵션\r\n * @returns 검색된 로그 엔트리 배열\r\n */\r\nexport async function searchLogs(options: LogSearchOptions = {}): Promise<LogEntry[]> {\r\n  try {\r\n    const queryParams = new URLSearchParams();\r\n    \r\n    // 검색 옵션을 쿼리 파라미터로 변환\r\n    if (options.type) {\r\n      if (Array.isArray(options.type)) {\r\n        options.type.forEach(t => queryParams.append('type', t));\r\n      } else {\r\n        queryParams.set('type', options.type);\r\n      }\r\n    }\r\n    \r\n    if (options.startTime) queryParams.set('startTime', options.startTime.toString());\r\n    if (options.endTime) queryParams.set('endTime', options.endTime.toString());\r\n    if (options.query) queryParams.set('query', options.query);\r\n    if (options.limit) queryParams.set('limit', options.limit.toString());\r\n    if (options.offset) queryParams.set('offset', options.offset.toString());\r\n    if (options.sessionId) queryParams.set('sessionId', options.sessionId);\r\n    \r\n    if (options.tags && options.tags.length > 0) {\r\n      options.tags.forEach(tag => queryParams.append('tag', tag));\r\n    }\r\n    \r\n    // 로그 검색 API 호출\r\n    const response = await fetch(`/api/logs/search?${queryParams.toString()}`);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`로그 검색 실패: ${response.status} ${response.statusText}`);\r\n    }\r\n    \r\n    const result = await response.json();\r\n    \r\n    logger.debug(`로그 검색 완료 (결과 수: ${result.data.length})`);\r\n    return result.data;\r\n  } catch (error) {\r\n    logger.error('로그 검색 중 오류 발생:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * 대화 로그를 저장합니다.\r\n * \r\n * @param userMessage - 사용자 메시지\r\n * @param aiResponse - AI 응답\r\n * @param metadata - 추가 메타데이터\r\n * @returns 저장된 로그 엔트리\r\n */\r\nexport async function saveConversationLog(\r\n  userMessage: string,\r\n  aiResponse: string,\r\n  metadata: any = {}\r\n): Promise<LogEntry> {\r\n  const now = getCurrentTimestamp();\r\n  const sessionId = metadata.sessionId || localStorage.getItem('sessionId') || `session_${now}`;\r\n  \r\n  // 세션 ID가 없으면 새로 생성하고 저장\r\n  if (!localStorage.getItem('sessionId')) {\r\n    localStorage.setItem('sessionId', sessionId);\r\n  }\r\n  \r\n  const logEntry: Omit<LogEntry, 'id'> = {\r\n    type: LogType.CONVERSATION,\r\n    timestamp: now,\r\n    content: JSON.stringify({\r\n      userMessage,\r\n      aiResponse,\r\n      timestamp: now\r\n    }),\r\n    metadata: {\r\n      ...metadata,\r\n      messageSize: {\r\n        user: new Blob([userMessage]).size,\r\n        ai: new Blob([aiResponse]).size\r\n      },\r\n      messageSizeFormatted: {\r\n        user: formatBytes(new Blob([userMessage]).size),\r\n        ai: formatBytes(new Blob([aiResponse]).size)\r\n      }\r\n    },\r\n    tags: ['conversation', 'ai', ...(metadata.tags || [])],\r\n    sessionId\r\n  };\r\n  \r\n  return saveLog(logEntry);\r\n}\r\n\r\n/**\r\n * 에러 로그를 저장합니다.\r\n * \r\n * @param error - 에러 객체 또는 에러 메시지\r\n * @param metadata - 추가 메타데이터\r\n * @returns 저장된 로그 엔트리\r\n */\r\nexport async function saveErrorLog(\r\n  error: Error | string,\r\n  metadata: any = {}\r\n): Promise<LogEntry> {\r\n  const errorMessage = error instanceof Error ? error.message : error;\r\n  const errorStack = error instanceof Error ? error.stack : undefined;\r\n  \r\n  const logEntry: Omit<LogEntry, 'id'> = {\r\n    type: LogType.ERROR,\r\n    timestamp: getCurrentTimestamp(),\r\n    content: errorMessage,\r\n    metadata: {\r\n      ...metadata,\r\n      stack: errorStack,\r\n      browserInfo: typeof navigator !== 'undefined' ? {\r\n        userAgent: navigator.userAgent,\r\n        platform: navigator.platform,\r\n        language: navigator.language\r\n      } : undefined\r\n    },\r\n    tags: ['error', ...(metadata.tags || [])],\r\n    sessionId: metadata.sessionId || localStorage.getItem('sessionId')\r\n  };\r\n  \r\n  return saveLog(logEntry);\r\n}\r\n\r\n/**\r\n * 메모리 로그를 저장합니다.\r\n * \r\n * @param memoryInfo - 메모리 정보\r\n * @returns 저장된 로그 엔트리\r\n */\r\nexport async function saveMemoryLog(memoryInfo: any): Promise<LogEntry> {\r\n  const logEntry: Omit<LogEntry, 'id'> = {\r\n    type: LogType.MEMORY,\r\n    timestamp: getCurrentTimestamp(),\r\n    content: JSON.stringify(memoryInfo),\r\n    metadata: {\r\n      heapUsed: memoryInfo.heapUsed,\r\n      heapTotal: memoryInfo.heapTotal,\r\n      percentUsed: memoryInfo.percentUsed\r\n    },\r\n    tags: ['memory', 'performance'],\r\n    sessionId: localStorage.getItem('sessionId')\r\n  };\r\n  \r\n  return saveLog(logEntry);\r\n}\r\n\r\n/**\r\n * 성능 로그를 저장합니다.\r\n * \r\n * @param metric - 성능 메트릭 이름\r\n * @param value - 성능 값\r\n * @param unit - 값의 단위 (ms, MB 등)\r\n * @param metadata - 추가 메타데이터\r\n * @returns 저장된 로그 엔트리\r\n */\r\nexport async function savePerformanceLog(\r\n  metric: string,\r\n  value: number,\r\n  unit: string = 'ms',\r\n  metadata: any = {}\r\n): Promise<LogEntry> {\r\n  const logEntry: Omit<LogEntry, 'id'> = {\r\n    type: LogType.PERFORMANCE,\r\n    timestamp: getCurrentTimestamp(),\r\n    content: `${metric}: ${value}${unit}`,\r\n    metadata: {\r\n      ...metadata,\r\n      metric,\r\n      value,\r\n      unit\r\n    },\r\n    tags: ['performance', metric, ...(metadata.tags || [])],\r\n    sessionId: localStorage.getItem('sessionId')\r\n  };\r\n  \r\n  return saveLog(logEntry);\r\n}\r\n\r\n/**\r\n * 시스템 로그를 저장합니다.\r\n * \r\n * @param message - 시스템 메시지\r\n * @param metadata - 추가 메타데이터\r\n * @returns 저장된 로그 엔트리\r\n */\r\nexport async function saveSystemLog(\r\n  message: string,\r\n  metadata: any = {}\r\n): Promise<LogEntry> {\r\n  const logEntry: Omit<LogEntry, 'id'> = {\r\n    type: LogType.SYSTEM,\r\n    timestamp: getCurrentTimestamp(),\r\n    content: message,\r\n    metadata: {\r\n      ...metadata,\r\n      systemInfo: typeof navigator !== 'undefined' ? {\r\n        userAgent: navigator.userAgent,\r\n        language: navigator.language,\r\n        platform: navigator.platform\r\n      } : undefined\r\n    },\r\n    tags: ['system', ...(metadata.tags || [])],\r\n    sessionId: metadata.sessionId || localStorage.getItem('sessionId')\r\n  };\r\n  \r\n  return saveLog(logEntry);\r\n}\r\n\r\n/**\r\n * 로컬 저장소의 로그를 모두 서버로 동기화합니다.\r\n */\r\nexport async function syncLocalLogs(): Promise<void> {\r\n  try {\r\n    // 로컬 스토리지에서 로그로 시작하는 키 모두 가져오기\r\n    const logKeys = Object.keys(localStorage).filter(key => key.startsWith('log_'));\r\n    \r\n    if (logKeys.length === 0) {\r\n      logger.debug('동기화할 로컬 로그가 없습니다.');\r\n      return;\r\n    }\r\n    \r\n    logger.info(`${logKeys.length}개의 로컬 로그 동기화 시작`);\r\n    \r\n    // 각 로그 동기화\r\n    for (const key of logKeys) {\r\n      try {\r\n        const logJson = localStorage.getItem(key);\r\n        if (!logJson) continue;\r\n        \r\n        const log = JSON.parse(logJson);\r\n        await saveLog(log);\r\n        \r\n        // 성공적으로 동기화된 로그는 로컬 스토리지에서 제거\r\n        localStorage.removeItem(key);\r\n      } catch (error) {\r\n        logger.error(`로그 동기화 중 오류 (${key}):`, error);\r\n      }\r\n    }\r\n    \r\n    logger.info('로컬 로그 동기화 완료');\r\n  } catch (error) {\r\n    logger.error('로그 동기화 중 오류 발생:', error);\r\n    throw error;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\math-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\media-utils.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":9,"column":49,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":65},{"ruleId":"no-undef","severity":2,"message":"'Image' is not defined.","line":11,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":25,"column":8,"nodeType":"Identifier","messageId":"undef","endLine":25,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":57,"column":8,"nodeType":"Identifier","messageId":"undef","endLine":57,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":63,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":63,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":108,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":108,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":114,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":114,"endColumn":45}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 미디어 관련 유틸리티 함수들\r\n */\r\n\r\n/**\r\n * 이미지 로드 프로미스\r\n * @param src 이미지 URL\r\n */\r\nexport function loadImage(src: string): Promise<HTMLImageElement> {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    img.onload = () => resolve(img);\r\n    img.onerror = () => reject(new Error(`이미지 로드 실패: ${src}`));\r\n    img.src = src;\r\n  });\r\n}\r\n\r\n/**\r\n * 이미지 크기 조정 함수\r\n * @param img 이미지 요소\r\n * @param maxWidth 최대 너비\r\n * @param maxHeight 최대 높이\r\n */\r\nexport function resizeImage(\r\n  img: HTMLImageElement,\r\n  maxWidth: number,\r\n  maxHeight: number\r\n): { width: number; height: number } {\r\n  let width = img.width;\r\n  let height = img.height;\r\n  \r\n  // 비율 계산\r\n  if (width > maxWidth) {\r\n    const ratio = maxWidth / width;\r\n    width = maxWidth;\r\n    height = Math.round(height * ratio);\r\n  }\r\n  \r\n  if (height > maxHeight) {\r\n    const ratio = maxHeight / height;\r\n    height = maxHeight;\r\n    width = Math.round(width * ratio);\r\n  }\r\n  \r\n  return { width, height };\r\n}\r\n\r\n/**\r\n * 이미지를 캔버스에 그리고 데이터 URL로 반환\r\n * @param img 이미지 요소\r\n * @param width 너비\r\n * @param height 높이\r\n * @param format 포맷(image/jpeg, image/png)\r\n * @param quality JPEG 품질(0-1)\r\n */\r\nexport function imageToDataURL(\r\n  img: HTMLImageElement,\r\n  width: number,\r\n  height: number,\r\n  format: 'image/jpeg' | 'image/png' = 'image/jpeg',\r\n  quality: number = 0.8\r\n): string {\r\n  const canvas = document.createElement('canvas');\r\n  canvas.width = width;\r\n  canvas.height = height;\r\n  \r\n  const ctx = canvas.getContext('2d');\r\n  if (!ctx) {\r\n    throw new Error('캔버스 컨텍스트를 생성할 수 없습니다.');\r\n  }\r\n  \r\n  ctx.drawImage(img, 0, 0, width, height);\r\n  return canvas.toDataURL(format, quality);\r\n}\r\n\r\n/**\r\n * 동영상 길이 포맷 함수\r\n * @param seconds 초 단위 길이\r\n */\r\nexport function formatVideoDuration(seconds: number): string {\r\n  const hours = Math.floor(seconds / 3600);\r\n  const minutes = Math.floor((seconds % 3600) / 60);\r\n  const secs = Math.floor(seconds % 60);\r\n  \r\n  if (hours > 0) {\r\n    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\r\n  }\r\n  \r\n  return `${minutes}:${secs.toString().padStart(2, '0')}`;\r\n}\r\n\r\n/**\r\n * 미디어 마임 타입 확인\r\n * @param mimeType 마임 타입\r\n */\r\nexport function isMediaMimeType(mimeType: string): boolean {\r\n  return (\r\n    mimeType.startsWith('image/') ||\r\n    mimeType.startsWith('video/') ||\r\n    mimeType.startsWith('audio/')\r\n  );\r\n}\r\n\r\n/**\r\n * 이미지 캐시 유틸리티\r\n */\r\nexport const imageCache = {\r\n  cache: new Map<string, HTMLImageElement>(),\r\n  \r\n  /**\r\n   * 이미지 가져오기 (캐싱 적용)\r\n   * @param src 이미지 URL\r\n   */\r\n  get(src: string): Promise<HTMLImageElement> {\r\n    if (this.cache.has(src)) {\r\n      return Promise.resolve(this.cache.get(src)!);\r\n    }\r\n    \r\n    return loadImage(src).then(img => {\r\n      this.cache.set(src, img);\r\n      return img;\r\n    });\r\n  },\r\n  \r\n  /**\r\n   * 캐시 비우기\r\n   */\r\n  clear(): void {\r\n    this.cache.clear();\r\n  }\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory-management.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":19,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":19,"endColumn":12},{"ruleId":"no-unused-vars","severity":2,"message":"'_emergency' is assigned a value but never used.","line":28,"column":48,"nodeType":"Identifier","messageId":"unusedVar","endLine":28,"endColumn":67},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":32,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":32,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":49,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":49,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":49,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":49,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1326,1369],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":51,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":51,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":51,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":51,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1381,1440],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":68,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":68,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":95,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":95,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":95,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":95,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2409,2483],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":101,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":101,"endColumn":47},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":113,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":113,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":116,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":116,"endColumn":14}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 메모리 관리 유틸리티\r\n * \r\n * 애플리케이션 메모리 관리 기능들을 통합하여 제공합니다.\r\n */\r\n\r\nimport { MemoryInfo, GCResult, OptimizationResult, OptimizationLevel } from '@/types';\r\nimport { requestNativeMemoryInfo, requestNativeGarbageCollection, requestNativeMemoryOptimization } from './native-memory-bridge';\r\nimport { cleanAllCaches, suggestGarbageCollection } from './memory/gc-utils';\r\nimport { formatBytes } from './memory/format-utils';\r\n\r\n/**\r\n * 메모리 정보 가져오기\r\n */\r\nexport async function getMemoryInfo(): Promise<MemoryInfo | null> {\r\n  try {\r\n    return await requestNativeMemoryInfo();\r\n  } catch (error) {\r\n    console.error('메모리 정보 가져오기 오류:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * 가비지 컬렉션 수행\r\n * @param _emergency 긴급 모드 여부\r\n */\r\nexport async function performGarbageCollection(_emergency: boolean = false): Promise<GCResult | null> {\r\n  try {\r\n    return await requestNativeGarbageCollection();\r\n  } catch (error) {\r\n    console.error('가비지 컬렉션 오류:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 최적화 수행\r\n * @param level 최적화 레벨\r\n * @param emergency 긴급 모드 여부\r\n */\r\nexport async function optimizeMemory(\r\n  level: OptimizationLevel = OptimizationLevel.MEDIUM,\r\n  emergency: boolean = false\r\n): Promise<OptimizationResult | null> {\r\n  try {\r\n    // 현재 메모리 상태 기록 - 사용 추가\r\n    const memoryBefore = await requestNativeMemoryInfo();\r\n    console.log('최적화 전 메모리 상태:', memoryBefore);\r\n    \r\n    console.log(`메모리 최적화 시작 (레벨: ${level}, 긴급: ${emergency})`);\r\n    \r\n    // 네이티브 모듈 호출\r\n    const result = await requestNativeMemoryOptimization(level, emergency);\r\n    \r\n    if (result) {\r\n      // 속성 이름 호환성 처리 - freed_mb 사용 (인터페이스와 일치)\r\n      const freedMB = result.freed_mb || 0;\r\n      recordOptimization(level, result.success, 'native', freedMB);\r\n    }\r\n    \r\n    // JS 측 추가 정리\r\n    cleanAllCaches();\r\n    suggestGarbageCollection();\r\n    \r\n    return result;\r\n  } catch (error) {\r\n    console.error('메모리 최적화 오류:', error);\r\n    recordOptimization(level, false, 'native', 0);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * 최적화 기록\r\n * @param level 최적화 레벨\r\n * @param success 성공 여부\r\n * @param implementation 구현 ('native' 또는 'js')\r\n * @param freedMemory 해제된 메모리 (MB)\r\n */\r\nfunction recordOptimization(\r\n  level: OptimizationLevel, \r\n  success: boolean,\r\n  implementation: string,\r\n  freedMemory: number\r\n): void {\r\n  const record = {\r\n    timestamp: Date.now(),\r\n    level,\r\n    success,\r\n    implementation,\r\n    freedMemory\r\n  };\r\n  \r\n  console.log(`메모리 최적화 완료: ${success ? '성공' : '실패'}, ${freedMemory}MB 해제됨`);\r\n  \r\n  // 브라우저 환경에서는 로컬 스토리지에 기록 저장 가능\r\n  if (typeof localStorage !== 'undefined') {\r\n    try {\r\n      // 기존 기록 가져오기\r\n      const existingRecordsJson = localStorage.getItem('memoryOptimizationRecords');\r\n      const records = existingRecordsJson \r\n        ? JSON.parse(existingRecordsJson) \r\n        : [];\r\n      \r\n      // 최대 20개까지만 저장\r\n      records.push(record);\r\n      if (records.length > 20) {\r\n        records.shift();\r\n      }\r\n      \r\n      // 저장\r\n      localStorage.setItem('memoryOptimizationRecords', JSON.stringify(records));\r\n    } catch (error) {\r\n      // 저장 오류 무시\r\n      console.warn('최적화 기록 저장 오류:', error);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 사용량 문자열 포맷\r\n * @param info 메모리 정보\r\n */\r\nexport function formatMemoryInfo(info: MemoryInfo): Record<string, string> {\r\n  return {\r\n    heapUsed: formatBytes(info.heapUsed),\r\n    heapTotal: formatBytes(info.heapTotal),\r\n    rss: formatBytes(info.rss),\r\n    percentUsed: `${info.percentUsed.toFixed(1)}%`\r\n  };\r\n}\r\n\r\n/**\r\n * 메모리 상태 평가\r\n * @param info 메모리 정보\r\n */\r\nexport function assessMemoryState(info: MemoryInfo): {\r\n  status: 'normal' | 'warning' | 'critical';\r\n  color: string;\r\n  message: string;\r\n} {\r\n  const percent = info.percentUsed;\r\n  \r\n  if (percent >= 90) {\r\n    return {\r\n      status: 'critical',\r\n      color: '#ff4d4f',\r\n      message: '메모리 사용량이 매우 높습니다. 최적화가 필요합니다.'\r\n    };\r\n  } else if (percent >= 75) {\r\n    return {\r\n      status: 'warning',\r\n      color: '#faad14',\r\n      message: '메모리 사용량이 높아지고 있습니다.'\r\n    };\r\n  } else {\r\n    return {\r\n      status: 'normal',\r\n      color: '#52c41a',\r\n      message: '메모리 사용량이 정상 범위입니다.'\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * 네이티브 메모리 정보를 표준 형식으로 변환\r\n * @param nativeInfo 네이티브 메모리 정보\r\n */\r\nexport function convertNativeMemoryInfo(nativeInfo: Record<string, unknown>): MemoryInfo {\r\n  // any 타입 사용이 불가피한 경우 (네이티브 모듈 응답 형식이 다양할 수 있음)\r\n  return {\r\n    heapUsed: nativeInfo.heap_used || nativeInfo.heapUsed || 0,\r\n    heapTotal: nativeInfo.heap_total || nativeInfo.heapTotal || 0,\r\n    rss: nativeInfo.rss || 0,\r\n    heapUsedMB: nativeInfo.heap_used_mb || nativeInfo.heapUsedMB || 0,\r\n    rssMB: nativeInfo.rss_mb || nativeInfo.rssMB || 0,\r\n    percentUsed: nativeInfo.percent_used || nativeInfo.percentUsed || 0,\r\n    timestamp: nativeInfo.timestamp || Date.now(),\r\n    \r\n    // 하위 호환성을 위한 snake_case 필드\r\n    heap_used: nativeInfo.heap_used || nativeInfo.heapUsed || 0,\r\n    heap_total: nativeInfo.heap_total || nativeInfo.heapTotal || 0,\r\n    heap_used_mb: nativeInfo.heap_used_mb || nativeInfo.heapUsedMB || 0,\r\n    rss_mb: nativeInfo.rss_mb || nativeInfo.rssMB || 0,\r\n    percent_used: nativeInfo.percent_used || nativeInfo.percentUsed || 0,\r\n    heap_limit: nativeInfo.heap_limit\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory-optimizer.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'result' is assigned a value but never used.","line":32,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is assigned a value but never used.","line":32,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 메모리 최적화 조정자 (Orchestrator)\r\n * \r\n * 이 모듈은 메모리 최적화의 상위 레벨 인터페이스를 제공하고,\r\n * 실제 최적화 작업은 memory/optimization-utils.ts와 gc/ 하위 모듈에 위임합니다.\r\n */\r\n\r\nimport { OptimizationLevel, OptimizationResult } from '../../types';\r\nimport * as memoryInfo from './memory/memory-info';\r\nimport * as optimizationUtils from './memory/optimization-utils';\r\nimport { performGarbageCollection } from './memory/gc/garbage-collector';\r\nimport { logger } from './memory/logger';\r\n\r\n/**\r\n * 메모리 최적화를 실행합니다.\r\n * \r\n * @param level - 최적화 레벨 (기본값: 'medium')\r\n * @param emergency - 긴급 상황 여부\r\n * @returns 최적화 결과\r\n */\r\nexport async function optimizeMemory(\r\n  level: OptimizationLevel = OptimizationLevel.MEDIUM,\r\n  emergency: boolean = false\r\n): Promise<OptimizationResult> {\r\n  try {\r\n    logger.info(`[Memory Optimizer] Starting memory optimization at level: ${level}, emergency: ${emergency}`);\r\n    \r\n    // 현재 메모리 사용량 확인\r\n    const beforeMemory = await memoryInfo.getMemoryUsage();\r\n    \r\n    // 최적화 실행\r\n    const result = await optimizationUtils.runOptimization(level, emergency);\r\n    \r\n    // 가비지 컬렉션 실행\r\n    await performGarbageCollection(emergency);\r\n    \r\n    // 최적화 후 메모리 사용량 확인\r\n    const afterMemory = await memoryInfo.getMemoryUsage();\r\n    \r\n    // 해제된 메모리 계산\r\n    const memoryFreed = beforeMemory.heapUsed - afterMemory.heapUsed;\r\n    \r\n    logger.info(`[Memory Optimizer] Memory optimization completed. Freed: ${memoryFreed} bytes`);\r\n    \r\n    return {\r\n      level,\r\n      memoryFreed,\r\n      timestamp: Date.now(),\r\n      success: true\r\n    };\r\n  } catch (error) {\r\n    logger.error('[Memory Optimizer] Error during memory optimization:', error);\r\n    return {\r\n      level,\r\n      memoryFreed: 0,\r\n      timestamp: Date.now(),\r\n      success: false,\r\n      error: error instanceof Error ? error.message : String(error)\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * 자동 메모리 최적화 설정을 구성합니다.\r\n * \r\n * @param options - 자동 최적화 설정\r\n */\r\nexport function configureAutoOptimization(options: {\r\n  enabled: boolean;\r\n  interval?: number;\r\n  threshold?: number;\r\n}): void {\r\n  optimizationUtils.configureAutoOptimization(options);\r\n}\r\n\r\n/**\r\n * 현재 메모리 상태를 확인하고 필요 시 최적화를 수행합니다.\r\n */\r\nexport async function checkAndOptimizeMemory(): Promise<void> {\r\n  try {\r\n    const memoryUsage = await memoryInfo.getMemoryUsage();\r\n    await optimizationUtils.checkAndOptimize(memoryUsage);\r\n  } catch (error) {\r\n    logger.error('[Memory Optimizer] Error during memory check and optimize:', error);\r\n  }\r\n}\r\n\r\n// 추가 메모리 최적화 관련 기능들...\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory-settings-bridge.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":32,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":32,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":72,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":72,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":89,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":89,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":113,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":113,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":127,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":127,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":142,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":142,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":156,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":156,"endColumn":12}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 메모리 설정 브릿지\r\n * \r\n * 네이티브 모듈과 메모리 설정 관련 통신을 담당합니다.\r\n */\r\n\r\n// 요청 상태 추적 및 중복 요청 방지\r\nconst requestStatus = {\r\n  pendingRequests: new Map<string, Promise<any>>(),\r\n  lastRequestTime: new Map<string, number>(),\r\n  minRequestInterval: 500 // ms\r\n};\r\n\r\n/**\r\n * 중복 요청 방지 및 병합 래퍼\r\n */\r\nasync function debouncedRequest<T>(\r\n  key: string, \r\n  requestFn: () => Promise<T>\r\n): Promise<T> {\r\n  const now = Date.now();\r\n  const lastTime = requestStatus.lastRequestTime.get(key) || 0;\r\n  \r\n  // 진행 중인 동일 요청이 있으면 재사용\r\n  if (requestStatus.pendingRequests.has(key)) {\r\n    return requestStatus.pendingRequests.get(key) as Promise<T>;\r\n  }\r\n  \r\n  // 마지막 요청 후 최소 간격이 지나지 않았으면 대기\r\n  if (now - lastTime < requestStatus.minRequestInterval) {\r\n    await new Promise(resolve => \r\n      setTimeout(resolve, requestStatus.minRequestInterval - (now - lastTime))\r\n    );\r\n  }\r\n  \r\n  // 새 요청 생성 및 상태 업데이트\r\n  const requestPromise = requestFn();\r\n  requestStatus.pendingRequests.set(key, requestPromise);\r\n  requestStatus.lastRequestTime.set(key, Date.now());\r\n  \r\n  try {\r\n    return await requestPromise;\r\n  } finally {\r\n    // 완료 후 pendingRequests에서 제거\r\n    requestStatus.pendingRequests.delete(key);\r\n  }\r\n}\r\n\r\n/**\r\n * 네이티브 메모리 설정 초기화\r\n */\r\nexport async function initializeNativeMemorySettings(settings: any): Promise<any> {\r\n  return debouncedRequest('initSettings', async () => {\r\n    try {\r\n      // 유효성 검사\r\n      if (!settings || typeof settings !== 'object') {\r\n        throw new Error('유효하지 않은 설정 객체');\r\n      }\r\n      \r\n      // 필수 필드 확인\r\n      const requiredFields = ['enableAutomaticOptimization', 'optimizationThreshold'];\r\n      for (const field of requiredFields) {\r\n        if (!(field in settings)) {\r\n          throw new Error(`필수 설정 필드 누락: ${field}`);\r\n        }\r\n      }\r\n      \r\n      // 형식 변환\r\n      const settingsForNative = convertToNativeSettings(settings);\r\n      \r\n      // API 요청\r\n      const response = await fetch('/api/native/memory/settings', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json'\r\n        },\r\n        body: JSON.stringify({ \r\n          action: 'initialize',\r\n          settings: settingsForNative \r\n        })\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      \r\n      return await response.json();\r\n    } catch (error) {\r\n      console.error('네이티브 메모리 설정 초기화 오류:', error);\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : '알 수 없는 오류'\r\n      };\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * 네이티브 메모리 설정 업데이트\r\n */\r\nexport async function updateNativeMemorySettings(settings: any): Promise<any> {\r\n  return debouncedRequest('updateSettings', async () => {\r\n    try {\r\n      // 유효성 검사\r\n      if (!settings || typeof settings !== 'object') {\r\n        throw new Error('유효하지 않은 설정 객체');\r\n      }\r\n      \r\n      // 형식 변환\r\n      const settingsForNative = convertToNativeSettings(settings);\r\n      \r\n      // API 요청\r\n      const response = await fetch('/api/native/memory/settings', {\r\n        method: 'PUT',\r\n        headers: {\r\n          'Content-Type': 'application/json'\r\n        },\r\n        body: JSON.stringify(settingsForNative)\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      \r\n      return await response.json();\r\n    } catch (error) {\r\n      console.error('네이티브 메모리 설정 업데이트 오류:', error);\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : '알 수 없는 오류'\r\n      };\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * 네이티브 메모리 설정 가져오기\r\n * @returns 설정 객체\r\n */\r\nexport async function getNativeMemorySettings(): Promise<any> {\r\n  try {\r\n    const response = await fetch('/api/native/memory/settings');\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`HTTP error! status: ${response.status}`);\r\n    }\r\n    \r\n    const result = await response.json();\r\n    \r\n    if (result.success && result.settings) {\r\n      return convertFromNativeSettings(result.settings);\r\n    }\r\n    \r\n    return null;\r\n  } catch (error) {\r\n    console.error('네이티브 메모리 설정 가져오기 오류:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * 설정 객체를 네이티브 모듈 형식으로 변환\r\n * \r\n * @param settings 앱 설정 객체\r\n * @returns 네이티브 형식 설정 객체\r\n */\r\nexport function convertToNativeSettings(settings: any): any {\r\n  return {\r\n    enable_automatic_optimization: settings.enableAutomaticOptimization,\r\n    optimization_threshold: settings.optimizationThreshold,\r\n    optimization_interval: settings.optimizationInterval,\r\n    aggressive_gc: settings.aggressiveGC,\r\n    enable_logging: settings.enableLogging,\r\n    enable_performance_metrics: settings.enablePerformanceMetrics,\r\n    use_hardware_acceleration: settings.useHardwareAcceleration,\r\n    processing_mode: settings.processingMode,\r\n    use_memory_pool: settings.useMemoryPool,\r\n    pool_cleanup_interval: settings.poolCleanupInterval,\r\n  };\r\n}\r\n\r\n/**\r\n * 네이티브 형식 설정을 앱 설정 객체로 변환\r\n * \r\n * @param nativeSettings 네이티브 형식 설정\r\n * @returns 앱 설정 객체\r\n */\r\nexport function convertFromNativeSettings(nativeSettings: any): any {\r\n  return {\r\n    enableAutomaticOptimization: nativeSettings.enable_automatic_optimization,\r\n    optimizationThreshold: nativeSettings.optimization_threshold,\r\n    optimizationInterval: nativeSettings.optimization_interval,\r\n    aggressiveGC: nativeSettings.aggressive_gc,\r\n    enableLogging: nativeSettings.enable_logging,\r\n    enablePerformanceMetrics: nativeSettings.enable_performance_metrics,\r\n    useHardwareAcceleration: nativeSettings.use_hardware_acceleration,\r\n    processingMode: nativeSettings.processing_mode,\r\n    useMemoryPool: nativeSettings.use_memory_pool,\r\n    poolCleanupInterval: nativeSettings.pool_cleanup_interval,\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory-settings-manager.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":81,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":81,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":91,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":91,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":134,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":134,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":138,"column":42,"nodeType":"Identifier","messageId":"undef","endLine":138,"endColumn":48},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":139,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":139,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":140,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":140,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":142,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":142,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":148,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":148,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":169,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":169,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":169,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":169,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5167,5207],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":171,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":171,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":189,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":189,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":190,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":190,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":193,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":193,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":196,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":196,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":196,"column":39,"nodeType":"Identifier","messageId":"undef","endLine":196,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":197,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":197,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":198,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":198,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":202,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":202,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":205,"column":44,"nodeType":"Identifier","messageId":"undef","endLine":205,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":206,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":206,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":207,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":207,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":209,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":209,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":213,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":213,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":216,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":216,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":230,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":230,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":230,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":230,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7123,7202],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":232,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":232,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":236,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":236,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":239,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":239,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":251,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":251,"endColumn":12}],"suppressedMessages":[],"errorCount":29,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 메모리 설정 관리 유틸리티\r\n * \r\n * 이 모듈은 애플리케이션의 메모리 최적화 설정을 관리하고 \r\n * native 모듈과 JavaScript 간의 설정 동기화를 처리합니다.\r\n */\r\n\r\nimport { updateNativeMemorySettings, getNativeMemorySettings } from './native-memory-bridge';\r\nimport { getLocalStorage as getStorageItem, setLocalStorage as setStorageItem } from './storage-utils';\r\n\r\n// 메모리 설정 인터페이스\r\nexport interface MemorySettings {\r\n  // 기본 설정\r\n  enableAutomaticOptimization: boolean;\r\n  optimizationThreshold: number;  // MB 단위\r\n  optimizationInterval: number;   // 밀리초 단위\r\n  \r\n  // 고급 설정\r\n  aggressiveGC: boolean;\r\n  enableLogging: boolean;\r\n  enablePerformanceMetrics: boolean;\r\n  \r\n  // GPU 관련 설정\r\n  useHardwareAcceleration: boolean;\r\n  processingMode: 'auto' | 'normal' | 'cpu-intensive' | 'gpu-intensive';\r\n  \r\n  // 메모리 풀 설정\r\n  useMemoryPool: boolean;\r\n  poolCleanupInterval: number;    // 밀리초 단위\r\n}\r\n\r\n// 기본 설정 값\r\nconst DEFAULT_SETTINGS: MemorySettings = {\r\n  enableAutomaticOptimization: true,\r\n  optimizationThreshold: 100,    // 100MB\r\n  optimizationInterval: 60000,   // 1분\r\n  \r\n  aggressiveGC: false,\r\n  enableLogging: true,\r\n  enablePerformanceMetrics: true,\r\n  \r\n  useHardwareAcceleration: false,\r\n  processingMode: 'auto',\r\n  \r\n  useMemoryPool: true,\r\n  poolCleanupInterval: 300000,   // 5분\r\n};\r\n\r\n// 로컬 스토리지 키\r\nconst MEMORY_SETTINGS_KEY = 'typing-stats-memory-settings';\r\n\r\n/**\r\n * 현재 메모리 설정 가져오기 (로컬 스토리지 + 기본값 병합)\r\n * @returns 현재 메모리 설정\r\n */\r\nexport async function getMemorySettings(): Promise<MemorySettings> {\r\n  try {\r\n    // 로컬 스토리지에서 설정 가져오기\r\n    const storedSettings = await getStorageItem<Partial<MemorySettings>>(MEMORY_SETTINGS_KEY) || {};\r\n    \r\n    // 네이티브 모듈에서 설정 가져오기 시도\r\n    let nativeSettings: Partial<MemorySettings> = {};\r\n    try {\r\n      const settings = await getNativeMemorySettings();\r\n      if (settings) {\r\n        // 네이티브 설정 키 이름 변환\r\n        nativeSettings = {\r\n          enableAutomaticOptimization: settings.enable_automatic_optimization,\r\n          optimizationThreshold: settings.optimization_threshold,\r\n          optimizationInterval: settings.optimization_interval,\r\n          aggressiveGC: settings.aggressive_gc,\r\n          enableLogging: settings.enable_logging,\r\n          enablePerformanceMetrics: settings.enable_performance_metrics,\r\n          useHardwareAcceleration: settings.use_hardware_acceleration,\r\n          processingMode: settings.processing_mode as any,\r\n          useMemoryPool: settings.use_memory_pool,\r\n          poolCleanupInterval: settings.pool_cleanup_interval,\r\n        };\r\n      }\r\n    } catch (error) {\r\n      console.warn('네이티브 설정을 가져오는 중 오류 발생:', error);\r\n    }\r\n    \r\n    // 기본값, 네이티브 설정, 로컬 스토리지 설정 병합 (우선순위 순)\r\n    return {\r\n      ...DEFAULT_SETTINGS,\r\n      ...nativeSettings,\r\n      ...storedSettings,\r\n    };\r\n  } catch (error) {\r\n    console.error('메모리 설정을 가져오는 중 오류 발생:', error);\r\n    return DEFAULT_SETTINGS;\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 설정 저장 및 적용\r\n * @param settings 저장할 설정\r\n * @returns 저장 성공 여부\r\n */\r\nexport async function saveMemorySettings(settings: Partial<MemorySettings>): Promise<boolean> {\r\n  try {\r\n    // 현재 설정 가져오기\r\n    const currentSettings = await getMemorySettings();\r\n    \r\n    // 새 설정으로 업데이트\r\n    const updatedSettings: MemorySettings = {\r\n      ...currentSettings,\r\n      ...settings,\r\n    };\r\n    \r\n    // 로컬 스토리지에 저장\r\n    await setStorageItem(MEMORY_SETTINGS_KEY, updatedSettings);\r\n    \r\n    // 네이티브 모듈에 설정 적용 시도\r\n    try {\r\n      // 네이티브 설정 형식으로 변환\r\n      const nativeSettings = {\r\n        enable_automatic_optimization: updatedSettings.enableAutomaticOptimization,\r\n        optimization_threshold: updatedSettings.optimizationThreshold,\r\n        optimization_interval: updatedSettings.optimizationInterval,\r\n        aggressive_gc: updatedSettings.aggressiveGC,\r\n        enable_logging: updatedSettings.enableLogging,\r\n        enable_performance_metrics: updatedSettings.enablePerformanceMetrics,\r\n        use_hardware_acceleration: updatedSettings.useHardwareAcceleration,\r\n        processing_mode: updatedSettings.processingMode,\r\n        use_memory_pool: updatedSettings.useMemoryPool,\r\n        pool_cleanup_interval: updatedSettings.poolCleanupInterval,\r\n      };\r\n      \r\n      // 네이티브 모듈에 설정 업데이트\r\n      await updateNativeMemorySettings(nativeSettings);\r\n    } catch (error) {\r\n      console.warn('네이티브 설정 적용 중 오류 발생 (로컬 설정은 저장됨):', error);\r\n    }\r\n    \r\n    // 전역 메모리 최적화 유틸리티 업데이트 (존재하는 경우)\r\n    if (typeof window !== 'undefined' && window.__memoryOptimizer) {\r\n      if (!window.__memoryOptimizer.settings) {\r\n        window.__memoryOptimizer.settings = updatedSettings;\r\n      } else {\r\n        Object.assign(window.__memoryOptimizer.settings, updatedSettings);\r\n      }\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('메모리 설정 저장 중 오류 발생:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 설정에 따라 메모리 최적화 기능 초기화\r\n */\r\nexport async function initializeMemorySettings(): Promise<void> {\r\n  try {\r\n    // 설정 가져오기\r\n    const settings = await getMemorySettings();\r\n    \r\n    // 주기적 메모리 최적화 설정 (활성화된 경우)\r\n    if (settings.enableAutomaticOptimization) {\r\n      setupPeriodicMemoryOptimization(settings);\r\n    }\r\n    \r\n    // 하드웨어 가속화 설정 적용\r\n    applyHardwareAccelerationSettings(settings);\r\n    \r\n    console.log('메모리 설정 초기화 완료:', settings);\r\n  } catch (error) {\r\n    console.error('메모리 설정 초기화 중 오류 발생:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 주기적 메모리 최적화 설정\r\n */\r\nfunction setupPeriodicMemoryOptimization(settings: MemorySettings): void {\r\n  try {\r\n    // 기존의 최적화 유틸리티 사용\r\n    import('./native-memory-bridge').then(({ setupPeriodicMemoryOptimization }) => {\r\n      const cleanup = setupPeriodicMemoryOptimization(\r\n        settings.optimizationInterval,\r\n        settings.optimizationThreshold\r\n      );\r\n      \r\n      // 정리 함수 저장 (필요시 호출 가능)\r\n      if (typeof window !== 'undefined') {\r\n        if (!window.__memoryOptimizer) {\r\n          window.__memoryOptimizer = {};\r\n        }\r\n        \r\n        window.__memoryOptimizer.cleanupPeriodicOptimization = cleanup;\r\n      }\r\n      \r\n      if (window.__memoryOptimizer && window.__memoryOptimizer.setupPeriodicOptimization) {\r\n        if (window.__memoryOptimizer.cleanupPeriodicOptimization) {\r\n          window.__memoryOptimizer.cleanupPeriodicOptimization();\r\n        }\r\n        \r\n        // 새 주기적 최적화 설정\r\n        window.__memoryOptimizer.setupPeriodicOptimization = cleanup;\r\n      }\r\n      \r\n      if (typeof window !== 'undefined' && window.__memoryOptimizer) {\r\n        if (!window.__memoryOptimizer.settings) {\r\n          window.__memoryOptimizer.settings = settings;\r\n        } else {\r\n          Object.assign(window.__memoryOptimizer.settings, settings);\r\n        }\r\n      }\r\n    }).catch(error => {\r\n      console.error('주기적 최적화 설정 중 오류 발생:', error);\r\n    });\r\n  } catch (error) {\r\n    console.error('주기적 메모리 최적화 설정 중 오류 발생:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 하드웨어 가속화 설정 적용\r\n */\r\nfunction applyHardwareAccelerationSettings(settings: MemorySettings): void {\r\n  try {\r\n    // GPU 가속화 관련 설정 적용\r\n    import('./gpu-acceleration').then(({ toggleGpuAcceleration }) => {\r\n      // 설정에 따라 GPU 가속화 활성화/비활성화\r\n      toggleGpuAcceleration(settings.useHardwareAcceleration).then(success => {\r\n        if (success) {\r\n          console.log(`GPU 가속화 ${settings.useHardwareAcceleration ? '활성화' : '비활성화'} 성공`);\r\n        } else {\r\n          console.warn(`GPU 가속화 ${settings.useHardwareAcceleration ? '활성화' : '비활성화'} 실패`);\r\n        }\r\n      });\r\n    }).catch(error => {\r\n      console.error('GPU 가속화 설정 적용 중 오류 발생:', error);\r\n    });\r\n  } catch (error) {\r\n    console.error('하드웨어 가속화 설정 적용 중 오류 발생:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 설정을 기본값으로 재설정\r\n * @returns 재설정 성공 여부\r\n */\r\nexport async function resetMemorySettings(): Promise<boolean> {\r\n  try {\r\n    return await saveMemorySettings(DEFAULT_SETTINGS);\r\n  } catch (error) {\r\n    console.error('메모리 설정 재설정 중 오류 발생:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// 윈도우 타입 선언 확장\r\ndeclare global {\r\n  interface Window {\r\n    __memoryOptimizer?: any;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\cache-utils.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":150,"column":8,"nodeType":"Identifier","messageId":"undef","endLine":150,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":151,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":151,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'Blob' is not defined.","line":161,"column":45,"nodeType":"Identifier","messageId":"undef","endLine":161,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":167,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":167,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":173,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":173,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":174,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":174,"endColumn":9},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":184,"column":41,"nodeType":"Identifier","messageId":"undef","endLine":184,"endColumn":47},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":187,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":187,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":188,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":188,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":190,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":190,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":192,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":192,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":197,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":197,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":199,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":199,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":200,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":200,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":211,"column":41,"nodeType":"Identifier","messageId":"undef","endLine":211,"endColumn":47},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":214,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":214,"endColumn":9},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":215,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":215,"endColumn":8},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":219,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":219,"endColumn":9},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":233,"column":48,"nodeType":"Identifier","messageId":"undef","endLine":233,"endColumn":64},{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":253,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":253,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":370,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":370,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":380,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":380,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":441,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":441,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":444,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":444,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":459,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":459,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":467,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":467,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":473,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":473,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":487,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":487,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":503,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":503,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":504,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":504,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":511,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":511,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":516,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":516,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":532,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":532,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":533,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":533,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":543,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":543,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":549,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":549,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":559,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":559,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":592,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":592,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":598,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":598,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":613,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":613,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":620,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":620,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":634,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":634,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":650,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":650,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":651,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":651,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":658,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":658,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":663,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":663,"endColumn":14}],"suppressedMessages":[],"errorCount":46,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 캐시 관리 유틸리티\r\n * \r\n * 메모리 사용량 관리를 위한 캐시 관련 기능을 제공합니다.\r\n */\r\n\r\nimport { isBrowser } from './gc-utils';\r\n\r\n// 기본 캐시 TTL 추가 (초 단위)\r\nexport const DEFAULT_CACHE_TTL = 300; // 5분\r\n\r\n/**\r\n * 메모리 캐시 유틸리티\r\n */\r\n\r\n// 메모리 효율적인 LRU 캐시 구현\r\nclass LRUCache<K, V> {\r\n  private capacity: number;\r\n  private cache: Map<K, V>;\r\n  private keyTimestamps: Map<K, number>;\r\n  \r\n  constructor(capacity: number) {\r\n    this.capacity = capacity;\r\n    this.cache = new Map();\r\n    this.keyTimestamps = new Map();\r\n  }\r\n  \r\n  /**\r\n   * 캐시에서 값을 가져옴\r\n   * @param key 캐시 키\r\n   * @returns 캐시된 값 또는 undefined\r\n   */\r\n  get(key: K): V | undefined {\r\n    const value = this.cache.get(key);\r\n    if (value !== undefined) {\r\n      // 접근 시간 업데이트\r\n      this.keyTimestamps.set(key, Date.now());\r\n    }\r\n    return value;\r\n  }\r\n  \r\n  /**\r\n   * 캐시에 값을 저장\r\n   * @param key 캐시 키\r\n   * @param value 캐시할 값\r\n   */\r\n  set(key: K, value: V): void {\r\n    // 용량 초과 시 가장 오래된 항목 제거\r\n    if (this.cache.size >= this.capacity) {\r\n      this.evictLeastRecentlyUsed();\r\n    }\r\n    \r\n    this.cache.set(key, value);\r\n    this.keyTimestamps.set(key, Date.now());\r\n  }\r\n  \r\n  /**\r\n   * 캐시 항목 삭제\r\n   * @param key 삭제할 항목 키\r\n   * @returns 성공 여부\r\n   */\r\n  delete(key: K): boolean {\r\n    const deleted = this.cache.delete(key);\r\n    if (deleted) {\r\n      this.keyTimestamps.delete(key);\r\n    }\r\n    return deleted;\r\n  }\r\n  \r\n  /**\r\n   * 캐시 항목 유효성 검사 및 정리\r\n   * @param maxAge 최대 수명 (ms)\r\n   * @returns 정리된 항목 수\r\n   */\r\n  prune(maxAge: number): number {\r\n    const now = Date.now();\r\n    let prunedCount = 0;\r\n    \r\n    for (const [key, timestamp] of this.keyTimestamps.entries()) {\r\n      if (now - timestamp > maxAge) {\r\n        this.cache.delete(key);\r\n        this.keyTimestamps.delete(key);\r\n        prunedCount++;\r\n      }\r\n    }\r\n    \r\n    return prunedCount;\r\n  }\r\n  \r\n  /**\r\n   * 가장 오래된 항목 제거\r\n   * @returns 제거된 키\r\n   */\r\n  private evictLeastRecentlyUsed(): K | undefined {\r\n    let oldestKey: K | undefined;\r\n    let oldestTime = Infinity;\r\n    \r\n    for (const [key, timestamp] of this.keyTimestamps.entries()) {\r\n      if (timestamp < oldestTime) {\r\n        oldestKey = key;\r\n        oldestTime = timestamp;\r\n      }\r\n    }\r\n    \r\n    if (oldestKey !== undefined) {\r\n      this.cache.delete(oldestKey);\r\n      this.keyTimestamps.delete(oldestKey);\r\n    }\r\n    \r\n    return oldestKey;\r\n  }\r\n  \r\n  /**\r\n   * 캐시 크기\r\n   */\r\n  get size(): number {\r\n    return this.cache.size;\r\n  }\r\n  \r\n  /**\r\n   * 캐시 용량\r\n   */\r\n  get maxSize(): number {\r\n    return this.capacity;\r\n  }\r\n  \r\n  /**\r\n   * 모든 캐시 항목 지우기\r\n   */\r\n  clear(): void {\r\n    this.cache.clear();\r\n    this.keyTimestamps.clear();\r\n  }\r\n  \r\n  /**\r\n   * 모든 캐시 키 가져오기\r\n   */\r\n  keys(): IterableIterator<K> {\r\n    return this.cache.keys();\r\n  }\r\n}\r\n\r\n/**\r\n * 글로벌 객체 URL 캐시\r\n */\r\nexport function setupObjectURLCache(): void {\r\n  if (typeof window === 'undefined') return;\r\n  \r\n  // 객체 URL 캐시 초기화\r\n  if (!window.__objectUrls) {\r\n    window.__objectUrls = new Map<string, string>();\r\n  }\r\n}\r\n\r\n/**\r\n * 캐시된 객체 URL 생성\r\n * @param blob 블롭 객체\r\n * @param key 캐시 키 (선택적)\r\n * @returns 객체 URL\r\n */\r\nexport function createCachedObjectURL(blob: Blob, key?: string): string {\r\n  if (typeof window === 'undefined') return '';\r\n  \r\n  setupObjectURLCache();\r\n  \r\n  const cacheKey = key || `blob-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\r\n  const existingUrl = window.__objectUrls?.get(cacheKey);\r\n  \r\n  if (existingUrl) {\r\n    return existingUrl;\r\n  }\r\n  \r\n  const url = URL.createObjectURL(blob);\r\n  window.__objectUrls?.set(cacheKey, url);\r\n  \r\n  return url;\r\n}\r\n\r\n/**\r\n * 캐시에서 객체 URL 해제\r\n * @param key 캐시 키 또는 URL\r\n */\r\nexport function revokeCachedObjectURL(keyOrUrl: string): void {\r\n  if (typeof window === 'undefined' || !window.__objectUrls) return;\r\n  \r\n  // 키로 직접 찾기\r\n  if (window.__objectUrls.has(keyOrUrl)) {\r\n    const url = window.__objectUrls.get(keyOrUrl);\r\n    if (url) {\r\n      URL.revokeObjectURL(url);\r\n    }\r\n    window.__objectUrls.delete(keyOrUrl);\r\n    return;\r\n  }\r\n  \r\n  // URL로 찾기\r\n  for (const [key, url] of window.__objectUrls.entries()) {\r\n    if (url === keyOrUrl) {\r\n      URL.revokeObjectURL(url);\r\n      window.__objectUrls.delete(key);\r\n      return;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 모든 캐시된 객체 URL 정리\r\n * @returns 정리된 URL 수\r\n */\r\nexport function clearAllCachedObjectURLs(): number {\r\n  if (typeof window === 'undefined' || !window.__objectUrls) return 0;\r\n  \r\n  let count = 0;\r\n  window.__objectUrls.forEach((url) => {\r\n    URL.revokeObjectURL(url);\r\n    count++;\r\n  });\r\n  \r\n  window.__objectUrls.clear();\r\n  return count;\r\n}\r\n\r\n/**\r\n * 메모리 내 시간 제한 캐시 생성\r\n * @param maxEntries 최대 항목 수\r\n * @returns LRU 캐시 인스턴스\r\n */\r\nexport function createTimeBasedCache<T>(maxEntries = 100): LRUCache<string, { data: T, timestamp: number }> {\r\n  return new LRUCache<string, { data: T, timestamp: number }>(maxEntries);\r\n}\r\n\r\n// 글로벌 LRU 캐시 인스턴스 내보내기\r\nexport const imageCache = new LRUCache<string, HTMLImageElement>(50);\r\nexport const dataCache = new LRUCache<string, any>(100);\r\nexport const computationCache = new LRUCache<string, any>(30);\r\n\r\n/**\r\n * 캐시 항목 인터페이스\r\n */\r\ninterface CacheItem<T> {\r\n  data: T;\r\n  timestamp: number;\r\n  expires: number;\r\n}\r\n\r\n/**\r\n * 메모리 캐시 관리자\r\n */\r\nclass MemoryCacheManager {\r\n  private cache: Map<string, CacheItem<unknown>>;\r\n  private maxItems: number;\r\n  private cleanupInterval: number;\r\n  private intervalId: number | NodeJS.Timeout | null = null;\r\n  \r\n  /**\r\n   * 생성자\r\n   * @param maxItems 최대 캐시 항목 수\r\n   * @param cleanupInterval 자동 정리 간격 (ms)\r\n   */\r\n  constructor(maxItems = 100, cleanupInterval = 60000) {\r\n    this.cache = new Map();\r\n    this.maxItems = maxItems;\r\n    this.cleanupInterval = cleanupInterval;\r\n    \r\n    // 브라우저 환경에서만 자동 정리 시작\r\n    if (isBrowser) {\r\n      this.startPeriodicCleanup();\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 캐시에 항목 추가\r\n   * @param key 캐시 키\r\n   * @param data 캐시할 데이터\r\n   * @param ttl 유효 시간 (ms)\r\n   */\r\n  set<T>(key: string, data: T, ttl = DEFAULT_CACHE_TTL): void {\r\n    // 캐시 용량 초과 시 가장 오래된 항목 제거\r\n    if (this.cache.size >= this.maxItems) {\r\n      this.removeOldestItem();\r\n    }\r\n    \r\n    const now = Date.now();\r\n    this.cache.set(key, {\r\n      data,\r\n      timestamp: now,\r\n      expires: now + ttl\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * 캐시에서 항목 가져오기\r\n   * @param key 캐시 키\r\n   * @returns 캐시된 데이터 또는 null (만료됐거나 없는 경우)\r\n   */\r\n  get<T>(key: string): T | null {\r\n    const item = this.cache.get(key) as CacheItem<T> | undefined;\r\n    \r\n    if (!item) return null;\r\n    \r\n    // 만료 확인\r\n    if (Date.now() > item.expires) {\r\n      this.cache.delete(key);\r\n      return null;\r\n    }\r\n    \r\n    return item.data;\r\n  }\r\n  \r\n  /**\r\n   * 캐시 항목 삭제\r\n   * @param key 캐시 키\r\n   */\r\n  delete(key: string): boolean {\r\n    return this.cache.delete(key);\r\n  }\r\n  \r\n  /**\r\n   * 캐시 전체 비우기\r\n   */\r\n  clear(): void {\r\n    this.cache.clear();\r\n  }\r\n  \r\n  /**\r\n   * 만료된 캐시 항목 정리\r\n   */\r\n  cleanup(): number {\r\n    const now = Date.now();\r\n    let removedCount = 0;\r\n    \r\n    for (const [key, item] of this.cache.entries()) {\r\n      if (now > item.expires) {\r\n        this.cache.delete(key);\r\n        removedCount++;\r\n      }\r\n    }\r\n    \r\n    return removedCount;\r\n  }\r\n  \r\n  /**\r\n   * 가장 오래된 캐시 항목 제거\r\n   */\r\n  private removeOldestItem(): void {\r\n    let oldestKey: string | null = null;\r\n    let oldestTimestamp = Infinity;\r\n    \r\n    for (const [key, item] of this.cache.entries()) {\r\n      if (item.timestamp < oldestTimestamp) {\r\n        oldestTimestamp = item.timestamp;\r\n        oldestKey = key;\r\n      }\r\n    }\r\n    \r\n    if (oldestKey) {\r\n      this.cache.delete(oldestKey);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 주기적 캐시 정리 시작\r\n   */\r\n  startPeriodicCleanup(): void {\r\n    // 이미 실행 중이면 중지\r\n    if (this.intervalId) {\r\n      this.stopPeriodicCleanup();\r\n    }\r\n    \r\n    this.intervalId = setInterval(() => {\r\n      this.cleanup();\r\n    }, this.cleanupInterval);\r\n  }\r\n  \r\n  /**\r\n   * 주기적 캐시 정리 중지\r\n   */\r\n  stopPeriodicCleanup(): void {\r\n    if (this.intervalId) {\r\n      clearInterval(this.intervalId as number);\r\n      this.intervalId = null;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 캐시 통계 가져오기\r\n   */\r\n  getStats(): Record<string, number> {\r\n    const now = Date.now();\r\n    let expiredCount = 0;\r\n    \r\n    for (const item of this.cache.values()) {\r\n      if (now > item.expires) {\r\n        expiredCount++;\r\n      }\r\n    }\r\n    \r\n    return {\r\n      totalItems: this.cache.size,\r\n      expiredItems: expiredCount,\r\n      activeItems: this.cache.size - expiredCount\r\n    };\r\n  }\r\n}\r\n\r\n// 전역 메모리 캐시 인스턴스\r\nexport const memoryCache = new MemoryCacheManager();\r\n\r\n/**\r\n * 로컬 스토리지 캐시 관리\r\n */\r\nexport class LocalStorageCache {\r\n  private prefix: string;\r\n  \r\n  /**\r\n   * 생성자\r\n   * @param prefix 캐시 키 접두어\r\n   */\r\n  constructor(prefix = 'app_cache_') {\r\n    this.prefix = prefix;\r\n  }\r\n  \r\n  /**\r\n   * 항목 저장\r\n   * @param key 캐시 키\r\n   * @param data 데이터\r\n   * @param ttl 유효 시간 (ms)\r\n   */\r\n  set<T>(key: string, data: T, ttl = DEFAULT_CACHE_TTL): boolean {\r\n    if (!isBrowser) return false;\r\n    \r\n    try {\r\n      const fullKey = this.prefix + key;\r\n      const now = Date.now();\r\n      const item: CacheItem<T> = {\r\n        data,\r\n        timestamp: now,\r\n        expires: now + ttl\r\n      };\r\n      \r\n      localStorage.setItem(fullKey, JSON.stringify(item));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('캐시 저장 오류:', error);\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 항목 가져오기\r\n   * @param key 캐시 키\r\n   * @returns 캐시된 데이터 또는 null\r\n   */\r\n  get<T>(key: string): T | null {\r\n    if (!isBrowser) return null;\r\n    \r\n    try {\r\n      const fullKey = this.prefix + key;\r\n      const itemJson = localStorage.getItem(fullKey);\r\n      \r\n      if (!itemJson) return null;\r\n      \r\n      const item = JSON.parse(itemJson) as CacheItem<T>;\r\n      \r\n      // 만료 확인\r\n      if (Date.now() > item.expires) {\r\n        localStorage.removeItem(fullKey);\r\n        return null;\r\n      }\r\n      \r\n      return item.data;\r\n    } catch (error) {\r\n      console.error('캐시 조회 오류:', error);\r\n      return null;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 항목 삭제\r\n   * @param key 캐시 키\r\n   */\r\n  delete(key: string): boolean {\r\n    if (!isBrowser) return false;\r\n    \r\n    try {\r\n      const fullKey = this.prefix + key;\r\n      localStorage.removeItem(fullKey);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 모든 캐시 항목 정리\r\n   */\r\n  clear(): boolean {\r\n    if (!isBrowser) return false;\r\n    \r\n    try {\r\n      const keysToRemove: string[] = [];\r\n      \r\n      for (let i = 0; i < localStorage.length; i++) {\r\n        const key = localStorage.key(i);\r\n        if (key && key.startsWith(this.prefix)) {\r\n          keysToRemove.push(key);\r\n        }\r\n      }\r\n      \r\n      keysToRemove.forEach(key => {\r\n        localStorage.removeItem(key);\r\n      });\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('캐시 정리 오류:', error);\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 만료된 캐시 항목 정리\r\n   */\r\n  cleanup(): number {\r\n    if (!isBrowser) return 0;\r\n    \r\n    try {\r\n      const now = Date.now();\r\n      const keysToCheck: string[] = [];\r\n      \r\n      // 관련 키 수집\r\n      for (let i = 0; i < localStorage.length; i++) {\r\n        const key = localStorage.key(i);\r\n        if (key && key.startsWith(this.prefix)) {\r\n          keysToCheck.push(key);\r\n        }\r\n      }\r\n      \r\n      // 만료된 항목 삭제\r\n      let removedCount = 0;\r\n      for (const key of keysToCheck) {\r\n        try {\r\n          const itemJson = localStorage.getItem(key);\r\n          if (!itemJson) continue;\r\n          \r\n          const item = JSON.parse(itemJson) as CacheItem<unknown>;\r\n          \r\n          if (now > item.expires) {\r\n            localStorage.removeItem(key);\r\n            removedCount++;\r\n          }\r\n        } catch {\r\n          // 개별 항목 처리 중 오류 무시\r\n        }\r\n      }\r\n      \r\n      return removedCount;\r\n    } catch (error) {\r\n      console.error('캐시 정리 오류:', error);\r\n      return 0;\r\n    }\r\n  }\r\n}\r\n\r\n// 기본 로컬 스토리지 캐시 인스턴스\r\nexport const localStorageCache = new LocalStorageCache();\r\n\r\n/**\r\n * 세션 스토리지 캐시 관리\r\n */\r\nexport class SessionStorageCache {\r\n  private prefix: string;\r\n  \r\n  /**\r\n   * 생성자\r\n   * @param prefix 캐시 키 접두어\r\n   */\r\n  constructor(prefix = 'app_session_') {\r\n    this.prefix = prefix;\r\n  }\r\n  \r\n  /**\r\n   * 항목 저장\r\n   * @param key 캐시 키\r\n   * @param data 데이터\r\n   */\r\n  set<T>(key: string, data: T): boolean {\r\n    if (!isBrowser) return false;\r\n    \r\n    try {\r\n      const fullKey = this.prefix + key;\r\n      sessionStorage.setItem(fullKey, JSON.stringify({\r\n        data,\r\n        timestamp: Date.now()\r\n      }));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('세션 캐시 저장 오류:', error);\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 항목 가져오기\r\n   * @param key 캐시 키\r\n   * @returns 캐시된 데이터 또는 null\r\n   */\r\n  get<T>(key: string): T | null {\r\n    if (!isBrowser) return null;\r\n    \r\n    try {\r\n      const fullKey = this.prefix + key;\r\n      const itemJson = sessionStorage.getItem(fullKey);\r\n      \r\n      if (!itemJson) return null;\r\n      \r\n      const item = JSON.parse(itemJson);\r\n      return item.data;\r\n    } catch (error) {\r\n      console.error('세션 캐시 조회 오류:', error);\r\n      return null;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 항목 삭제\r\n   * @param key 캐시 키\r\n   */\r\n  delete(key: string): boolean {\r\n    if (!isBrowser) return false;\r\n    \r\n    try {\r\n      const fullKey = this.prefix + key;\r\n      sessionStorage.removeItem(fullKey);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 모든 항목 정리\r\n   */\r\n  clear(): boolean {\r\n    if (!isBrowser) return false;\r\n    \r\n    try {\r\n      const keysToRemove: string[] = [];\r\n      \r\n      for (let i = 0; i < sessionStorage.length; i++) {\r\n        const key = sessionStorage.key(i);\r\n        if (key && key.startsWith(this.prefix)) {\r\n          keysToRemove.push(key);\r\n        }\r\n      }\r\n      \r\n      keysToRemove.forEach(key => {\r\n        sessionStorage.removeItem(key);\r\n      });\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('세션 캐시 정리 오류:', error);\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n// 기본 세션 스토리지 캐시 인스턴스\r\nexport const sessionStorageCache = new SessionStorageCache();\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\constants\\memory-thresholds.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":70,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":72,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":72,"endColumn":21}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 메모리 임계값 상수\r\n * \r\n * 메모리 최적화에 사용되는 다양한 임계값을 정의합니다.\r\n */\r\n\r\n// 기본 임계값 (MB)\r\nexport const DEFAULT_THRESHOLD = 100;\r\n\r\n// 최적화 수준별 임계값 (MB)\r\nexport const LEVEL_THRESHOLDS = {\r\n  // 최적화 수준별 메모리 임계값 (MB)\r\n  NONE: 50,      // 50MB 미만 - 최적화 필요 없음\r\n  LOW: 100,      // 50-100MB - 낮은 수준 최적화\r\n  MEDIUM: 200,   // 100-200MB - 중간 수준 최적화\r\n  HIGH: 300,     // 200-300MB - 높은 수준 최적화\r\n  EXTREME: 400   // 300MB 이상 - 긴급 최적화\r\n};\r\n\r\n// 자동 최적화 수준별 임계값 (%)\r\nexport const PERCENTAGE_THRESHOLDS = {\r\n  NONE: 50,      // 50% 미만 - 최적화 필요 없음\r\n  LOW: 70,       // 50-70% - 낮은 수준 최적화\r\n  MEDIUM: 80,    // 70-80% - 중간 수준 최적화\r\n  HIGH: 90,      // 80-90% - 높은 수준 최적화\r\n  EXTREME: 95    // 90% 이상 - 긴급 최적화\r\n};\r\n\r\n// GC 주기 간격 (밀리초)\r\nexport const GC_INTERVAL = {\r\n  NORMAL: 60000,   // 일반 상황 - 1분\r\n  LOW: 30000,      // 메모리 주의 상황 - 30초\r\n  CRITICAL: 10000  // 메모리 위험 상황 - 10초\r\n};\r\n\r\n// 자동 최적화 간격 (밀리초)\r\nexport const AUTO_OPTIMIZE_INTERVAL = 60000; // 1분\r\n\r\n// 메모리 체크 간격 (밀리초)\r\nexport const MEMORY_CHECK_INTERVAL = 15000; // 15초\r\n\r\n// 이벤트 최적화 임계값 (밀리초)\r\nexport const EVENT_OPTIMIZATION_THRESHOLD = 300000; // 5분\r\n\r\n// 최적화 타임아웃 (밀리초)\r\nexport const OPTIMIZATION_TIMEOUT = 5000; // 5초\r\n\r\n// 기타 임계값\r\nexport const MAX_CACHED_RESULTS = 50; // 최대 캐시 결과 수\r\nexport const MAX_HISTORY_ENTRIES = 100; // 최대 히스토리 항목 수\r\nexport const MIN_GC_INTERVAL = 5000; // 최소 GC 요청 간격 (5초)\r\n\r\n// 환경별 최적화 전략\r\nexport const OPTIMIZATION_STRATEGY = {\r\n  DEVELOPMENT: 'moderate', // 개발 환경\r\n  PRODUCTION: 'aggressive', // 프로덕션 환경\r\n  TEST: 'minimal' // 테스트 환경\r\n};\r\n\r\n// 메모리 사용량 상태 레벨\r\nexport const MEMORY_LEVEL = {\r\n  OK: 'ok',            // 정상\r\n  WARNING: 'warning',  // 경고\r\n  DANGER: 'danger',    // 위험\r\n  CRITICAL: 'critical' // 심각\r\n};\r\n\r\n// 현재 환경에 맞는 최적화 전략 반환\r\nexport function getCurrentOptimizationStrategy(): string {\r\n  if (process.env.NODE_ENV === 'production') {\r\n    return OPTIMIZATION_STRATEGY.PRODUCTION;\r\n  } else if (process.env.NODE_ENV === 'test') {\r\n    return OPTIMIZATION_STRATEGY.TEST;\r\n  }\r\n  return OPTIMIZATION_STRATEGY.DEVELOPMENT;\r\n}\r\n\r\n/**\r\n * 최적화 수준에 따른 설명\r\n */\r\nexport const OPTIMIZATION_LEVEL_DESCRIPTIONS = {\r\n  0: '정상 단계 (최적화 필요 없음)',\r\n  0.5: '관찰 단계 (경량 최적화)',\r\n  1: '주의 단계 (중간 수준 최적화)',\r\n  2: '경고 단계 (고수준 최적화)', \r\n  3: '위험 단계 (최대 수준 최적화)'\r\n};\r\n\r\n/**\r\n * 메모리 임계값 상수\r\n */\r\n\r\nexport const MEMORY_THRESHOLDS = {\r\n  // 최적화 임계값 (MB)\r\n  LOW: 50,      // 가벼운 최적화 시작\r\n  MEDIUM: 100,  // 중간 수준 최적화 시작\r\n  HIGH: 200,    // 높은 수준 최적화 시작\r\n  CRITICAL: 300, // 긴급 최적화 시작\r\n  \r\n  // 사용량 비율 임계값 (%)\r\n  USAGE_LOW: 50,  // 낮은 사용량\r\n  USAGE_MEDIUM: 70, // 중간 사용량\r\n  USAGE_HIGH: 85,   // 높은 사용량\r\n  USAGE_CRITICAL: 95, // 위험 수준 사용량\r\n  \r\n  // 가비지 컬렉션 관련\r\n  MIN_GC_INTERVAL: 30000, // 최소 GC 간격 (ms)\r\n  \r\n  // 메모리 풀 관련\r\n  POOL_LOW_WATER_MARK: 0.3,  // 낮은 수위 마크 (30%)\r\n  POOL_HIGH_WATER_MARK: 0.7, // 높은 수위 마크 (70%)\r\n  \r\n  // 타임아웃 관련\r\n  CLEANUP_TIMEOUT: 5000,    // 정리 작업 타임아웃 (ms)\r\n  RECOVERY_TIMEOUT: 10000,  // 복구 작업 타임아웃 (ms)\r\n  \r\n  // 주기적 최적화 간격\r\n  DEFAULT_OPTIMIZATION_INTERVAL: 60000, // 기본 1분\r\n  IDLE_OPTIMIZATION_INTERVAL: 300000,   // 유휴 상태 5분\r\n  \r\n  // 기타 상수\r\n  DEFAULT_BUFFER_SIZE: 4096, // 기본 버퍼 크기 (바이트)\r\n  MAX_CACHE_SIZE: 50 * 1024 * 1024, // 최대 캐시 크기 (50MB)\r\n  MAX_POOL_SIZE: 100 * 1024 * 1024  // 최대 풀 크기 (100MB)\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\dom-optimizer.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'Element' is not defined.","line":11,"column":41,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":48},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":16,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":16,"column":43,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":51},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":17,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":17,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":17,"column":41,"nodeType":"Identifier","messageId":"undef","endLine":17,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":27,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":27,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":29,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":35,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":35,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":38,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":38,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":48,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":48,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":52,"column":45,"nodeType":"Identifier","messageId":"undef","endLine":52,"endColumn":51},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":53,"column":45,"nodeType":"Identifier","messageId":"undef","endLine":53,"endColumn":51},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":67,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":67,"endColumn":12}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * DOM 최적화 관련 유틸리티\r\n * DOM 요소 정리 및 최적화 기능 제공\r\n */\r\n\r\n/**\r\n * 요소가 뷰포트 내에 있는지 확인\r\n * @param {Element} el 확인할 요소\r\n * @returns {boolean} 뷰포트 내 존재 여부\r\n */\r\nexport function isElementInViewport(el: Element): boolean {\r\n  const rect = el.getBoundingClientRect();\r\n  return (\r\n    rect.top >= 0 &&\r\n    rect.left >= 0 &&\r\n    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\r\n    rect.right <= (window.innerWidth || document.documentElement.clientWidth)\r\n  );\r\n}\r\n\r\n/**\r\n * DOM 요소를 정리합니다.\r\n */\r\nexport function cleanupDOM(): void {\r\n  try {\r\n    // 숨겨진 컨텐츠의 비표시 처리\r\n    const hiddenElements = document.querySelectorAll('.hidden, [hidden], [style*=\"display: none\"]');\r\n    hiddenElements.forEach(el => {\r\n      if (el instanceof HTMLElement) {\r\n        el.innerHTML = '';\r\n      }\r\n    });\r\n    \r\n    // 임시 요소 제거\r\n    const tempElements = document.querySelectorAll('.temp-element, .cached-view');\r\n    tempElements.forEach(el => el.remove());\r\n  } catch (error) {\r\n    console.error('DOM 정리 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 사용하지 않는 이미지 참조를 해제합니다.\r\n */\r\nexport function unloadUnusedImages(): void {\r\n  try {\r\n    // 화면에 보이지 않는 이미지 참조 해제\r\n    const images = document.querySelectorAll('img');\r\n    images.forEach(img => {\r\n      const rect = img.getBoundingClientRect();\r\n      // 뷰포트 밖에 있거나 숨겨진 이미지\r\n      if (rect.top < -1000 || rect.bottom > window.innerHeight + 1000 || \r\n          rect.left < -1000 || rect.right > window.innerWidth + 1000 ||\r\n          img.style.display === 'none' || img.style.visibility === 'hidden') {\r\n        \r\n        // 원본 src 저장 후 비우기\r\n        if (!img.dataset.originalSrc && img.src) {\r\n          img.dataset.originalSrc = img.src;\r\n          img.src = '';\r\n        }\r\n      } else if (img.dataset.originalSrc && !img.src) {\r\n        // 다시 보이는 이미지는 복원\r\n        img.src = img.dataset.originalSrc;\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('이미지 정리 오류:', error);\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\format-utils.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'MemoryUsageInfo' is defined but never used.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MemoryUsageInfo' is defined but never used.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 메모리 포맷팅 유틸리티\r\n */\r\nimport { MemoryUsageInfo } from './types';\r\n\r\n// 고유한 이름으로 변경하여 중복 방지\r\nexport interface MemoryInfoFormat {\r\n  heapUsed: number;\r\n  heapTotal: number;\r\n  heapUsedMB: number;\r\n  rss: number;\r\n  rssMB: number;\r\n  percentUsed: number;\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * 바이트 단위 포맷팅\r\n * @param bytes 바이트 수\r\n * @param decimals 소수점 자릿수\r\n * @returns 포맷팅된 문자열\r\n */\r\nexport function formatBytes(bytes: number, decimals: number = 2): string {\r\n  if (bytes === 0) return '0 Bytes';\r\n  \r\n  const k = 1024;\r\n  const dm = decimals < 0 ? 0 : decimals;\r\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\r\n  \r\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\r\n  \r\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];\r\n}\r\n\r\n/**\r\n * 메모리 정보 포맷팅 (고유한 이름으로 변경)\r\n * @param memoryInfo 메모리 정보 객체\r\n * @returns 포맷팅된 메모리 정보\r\n */\r\nexport function formatMemoryData(memoryInfo: Partial<MemoryInfoFormat>): string {\r\n  if (!memoryInfo) return 'No memory data';\r\n  \r\n  const heapUsedMB = memoryInfo.heapUsedMB ?? \r\n    (memoryInfo.heapUsed ? memoryInfo.heapUsed / (1024 * 1024) : 0);\r\n  \r\n  const heapTotalMB = memoryInfo.heapTotal ? memoryInfo.heapTotal / (1024 * 1024) : 0;\r\n  \r\n  return `Used: ${heapUsedMB.toFixed(2)} MB / Total: ${heapTotalMB.toFixed(2)} MB (${memoryInfo.percentUsed?.toFixed(1) || 0}%)`;\r\n}\r\n\r\n/**\r\n * 네이티브 메모리 정보를 앱 형식으로 변환\r\n * @param nativeInfo 네이티브 메모리 정보\r\n * @returns 변환된 메모리 정보\r\n */\r\nexport function convertNativeMemoryInfo(nativeInfo: any): MemoryInfoFormat {\r\n  if (!nativeInfo) {\r\n    return {\r\n      heapUsed: 0,\r\n      heapTotal: 0,\r\n      heapUsedMB: 0,\r\n      rss: 0,\r\n      rssMB: 0,\r\n      percentUsed: 0,\r\n      timestamp: Date.now()\r\n    };\r\n  }\r\n\r\n  // 네이티브(snake_case)에서 camelCase로 속성 이름 변환\r\n  return {\r\n    heapUsed: nativeInfo.heap_used || 0,\r\n    heapTotal: nativeInfo.heap_total || 0,\r\n    heapUsedMB: nativeInfo.heap_used_mb || 0,\r\n    rss: nativeInfo.rss || 0,\r\n    rssMB: nativeInfo.rss_mb || 0,\r\n    percentUsed: nativeInfo.percent_used || 0,\r\n    timestamp: nativeInfo.timestamp || Date.now()\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\gc-types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\gc-utils.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'_emergency' is assigned a value but never used.","line":24,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":52},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":28,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":28,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":47,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":47,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":48,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":48,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":52,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":52,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":53,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":53,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":57,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":57,"endColumn":15},{"ruleId":"no-unused-vars","severity":2,"message":"'_key' is assigned a value but never used.","line":58,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":58,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_key' is assigned a value but never used.","line":58,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":58,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":58,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":58,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":59,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":59,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":61,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":61,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":66,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":77,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":77,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":82,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":82,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":94,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":94,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":95,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":95,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":112,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":112,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":126,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":126,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":127,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":127,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":129,"column":37,"nodeType":"Identifier","messageId":"undef","endLine":129,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":135,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":135,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":148,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":148,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":149,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":149,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":153,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":153,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":156,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":156,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":157,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":157,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":164,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":164,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":169,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":169,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":185,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":185,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":194,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":194,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":202,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":202,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":215,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":215,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":216,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":216,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":222,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":222,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":225,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":225,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":236,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":236,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":237,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":237,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":241,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":241,"endColumn":15},{"ruleId":"no-unused-vars","severity":2,"message":"'_key' is assigned a value but never used.","line":242,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":242,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_key' is assigned a value but never used.","line":242,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":242,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":242,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":242,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":243,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":243,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":245,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":245,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":250,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":250,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":271,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":271,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":281,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":281,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":282,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":282,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":297,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":297,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":302,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":302,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":306,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":306,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":319,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":319,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":323,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":323,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":324,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":324,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":335,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":335,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":345,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":345,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":352,"column":8,"nodeType":"Identifier","messageId":"undef","endLine":352,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":353,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":353,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":356,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":356,"endColumn":9},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":357,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":357,"endColumn":9},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":358,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":358,"endColumn":9},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":359,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":359,"endColumn":9}],"suppressedMessages":[],"errorCount":60,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 가비지 컬렉션 유틸리티\r\n * \r\n * 메모리 정리 관련 기능을 제공합니다.\r\n */\r\n\r\nimport { GCResult } from '@/types';\r\nimport { requestNativeGarbageCollection } from '../native-memory-bridge';\r\n\r\n// 변수 및 상수 선언 추가\r\nlet lastGCTime = 0;\r\nconst MIN_GC_INTERVAL = 3000; // 3초\r\n\r\n/**\r\n * 브라우저 환경인지 확인하는 함수\r\n */\r\nexport const isBrowser = typeof window !== 'undefined';\r\n\r\n/**\r\n * 가비지 컬렉션 요청\r\n * 네이티브 모듈을 통해 GC를 수행합니다.\r\n * @returns GC 결과\r\n */\r\nexport async function requestGC(_emergency: boolean = false): Promise<GCResult | null> {\r\n  try {\r\n    return await requestNativeGarbageCollection();\r\n  } catch (error) {\r\n    console.error('가비지 컬렉션 요청 오류:', error);\r\n    return {\r\n      success: false,\r\n      timestamp: Date.now(),\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류'\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * 수동 메모리 정리 수행\r\n * JS 환경에서 가능한 메모리 정리 작업을 수행합니다.\r\n */\r\nexport async function cleanupMemory(): Promise<boolean> {\r\n  try {\r\n    // 브라우저 환경에서만 실행\r\n    if (!isBrowser) return false;\r\n    \r\n    // 가능한 경우 global.gc 호출\r\n    if (typeof window.gc === 'function') {\r\n      window.gc();\r\n    }\r\n    \r\n    // 미사용 이미지 캐시 정리\r\n    if (window.__imageResizeCache) {\r\n      window.__imageResizeCache.clear();\r\n    }\r\n    \r\n    // 오브젝트 URL 정리\r\n    if (window.__objectUrls) {\r\n      for (const [_key, url] of window.__objectUrls) {\r\n        URL.revokeObjectURL(url);\r\n      }\r\n      window.__objectUrls.clear();\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('메모리 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 주기적인 메모리 정리 설정\r\n * @param interval 실행 간격(ms)\r\n * @returns 정리 함수\r\n */\r\nexport function setupPeriodicGC(interval: number = 60000): () => void {\r\n  const timerId = setInterval(async () => {\r\n    await requestGC(false);\r\n  }, interval);\r\n  \r\n  return () => {\r\n    clearInterval(timerId);\r\n  };\r\n}\r\n\r\n/**\r\n * 가비지 컬렉션 제안 함수\r\n * \r\n * 브라우저 환경에서 가비지 컬렉션을 제안합니다.\r\n * window.gc가 있는 환경(크롬 --js-flags=\"--expose-gc\")에서만 작동합니다.\r\n */\r\nexport function suggestGarbageCollection(): void {\r\n  if (isBrowser) {\r\n    if (window.gc) {\r\n      window.gc();\r\n    } else {\r\n      // GC를 직접 호출할 수 없는 경우 간접적으로 메모리 압박을 가함\r\n      const now = Date.now();\r\n      \r\n      // 너무 자주 호출되지 않도록 조절\r\n      if (now - lastGCTime < MIN_GC_INTERVAL) {\r\n        return;\r\n      }\r\n      \r\n      lastGCTime = now;\r\n      \r\n      // 메모리 할당 후 해제하여 GC 유도\r\n      try {\r\n        const arr = new Array(10000).fill({});\r\n        arr.length = 0;\r\n      } catch (e) {\r\n        console.warn('GC 간접 호출 중 오류:', e);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 브라우저 캐시 정리\r\n */\r\nexport async function clearBrowserCaches(): Promise<boolean> {\r\n  try {\r\n    if (!isBrowser) return false;\r\n    \r\n    // 사용 가능한 캐시 API가 있으면 정리\r\n    if ('caches' in window) {\r\n      const cacheNames = await window.caches.keys();\r\n      await Promise.all(\r\n        cacheNames.map(cacheName => window.caches.delete(cacheName))\r\n      );\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('브라우저 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 브라우저 스토리지 정리\r\n */\r\nexport function clearStorageCaches(): boolean {\r\n  try {\r\n    if (!isBrowser) return false;\r\n    \r\n    // 세션 스토리지는 완전히 정리\r\n    if (window.sessionStorage) {\r\n      window.sessionStorage.clear();\r\n    }\r\n    \r\n    // 로컬 스토리지는 임시 데이터만 정리\r\n    if (window.localStorage) {\r\n      const keysToDelete: string[] = [];\r\n      \r\n      for (let i = 0; i < window.localStorage.length; i++) {\r\n        const key = window.localStorage.key(i);\r\n        // null 체크 추가\r\n        if (key && (key.startsWith('temp_') || key.startsWith('cache_'))) {\r\n          keysToDelete.push(key);\r\n        }\r\n      }\r\n      \r\n      keysToDelete.forEach(key => window.localStorage.removeItem(key));\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('스토리지 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 캐시 정리 유틸리티\r\n */\r\nexport function cleanCache(cacheType: string): boolean {\r\n  try {\r\n    if (!isBrowser) return false;\r\n\r\n    switch (cacheType) {\r\n      case 'local':\r\n        return cleanLocalStorageCache();\r\n      case 'session':\r\n        sessionStorage.clear();\r\n        return true;\r\n      case 'browser':\r\n        clearBrowserCaches();\r\n        return true;\r\n      case 'memory':\r\n        return cleanMemoryCache();\r\n      case 'all':\r\n        cleanLocalStorageCache();\r\n        sessionStorage.clear();\r\n        clearBrowserCaches();\r\n        cleanMemoryCache();\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  } catch (error) {\r\n    console.error(`캐시 정리 오류 (${cacheType}):`, error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 로컬 스토리지 캐시 정리\r\n */\r\nfunction cleanLocalStorageCache(): boolean {\r\n  try {\r\n    // 임시 데이터만 정리\r\n    const keysToRemove: string[] = [];\r\n    \r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      if (key && (key.startsWith('cache_') || key.startsWith('temp_'))) {\r\n        keysToRemove.push(key);\r\n      }\r\n    }\r\n    \r\n    keysToRemove.forEach(key => localStorage.removeItem(key));\r\n    return true;\r\n  } catch (error) {\r\n    console.error('로컬 스토리지 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 캐시 정리\r\n */\r\nfunction cleanMemoryCache(): boolean {\r\n  try {\r\n    // 이미지 캐시 정리\r\n    if (window.__imageResizeCache) {\r\n      window.__imageResizeCache.clear();\r\n    }\r\n    \r\n    // 오브젝트 URL 정리\r\n    if (window.__objectUrls) {\r\n      for (const [_key, url] of window.__objectUrls) {\r\n        URL.revokeObjectURL(url);\r\n      }\r\n      window.__objectUrls.clear();\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('메모리 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 비활성 캐시 정리\r\n */\r\nexport function cleanInactiveCaches(): boolean {\r\n  try {\r\n    if (!isBrowser) return false;\r\n    \r\n    // 접근 시간 추적을 위한 메타데이터 키\r\n    const CACHE_ACCESS_KEY = 'cache_last_access';\r\n    \r\n    // 현재 시간\r\n    const now = Date.now();\r\n    \r\n    // 마지막 접근 시간 정보 로드\r\n    let accessInfo: Record<string, number> = {};\r\n    try {\r\n      const accessInfoJson = localStorage.getItem(CACHE_ACCESS_KEY);\r\n      if (accessInfoJson) {\r\n        accessInfo = JSON.parse(accessInfoJson);\r\n      }\r\n    } catch {\r\n      // 파싱 오류 무시, 빈 객체 사용\r\n    }\r\n    \r\n    // 캐시 항목 스캔\r\n    const keysToCheck: string[] = [];\r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      if (key && key.startsWith('cache_')) {\r\n        keysToCheck.push(key);\r\n      }\r\n    }\r\n    \r\n    // 일정 시간 접근되지 않은 캐시 정리 (7일 이상)\r\n    const expiryTime = 7 * 24 * 60 * 60 * 1000; // 7일\r\n    const expiredKeys = keysToCheck.filter(key => {\r\n      const lastAccess = accessInfo[key] || 0;\r\n      return now - lastAccess > expiryTime;\r\n    });\r\n    \r\n    // 만료된 키 제거\r\n    expiredKeys.forEach(key => {\r\n      localStorage.removeItem(key);\r\n      delete accessInfo[key];\r\n    });\r\n    \r\n    // 접근 정보 업데이트\r\n    localStorage.setItem(CACHE_ACCESS_KEY, JSON.stringify(accessInfo));\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('비활성 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 모든 캐시 정리\r\n */\r\nexport function cleanAllCaches(): boolean {\r\n  try {\r\n    if (!isBrowser) return false;\r\n    \r\n    // 세션 스토리지 정리\r\n    sessionStorage.clear();\r\n    \r\n    // 로컬 스토리지에서 캐시 키 찾기\r\n    const cacheKeys: string[] = [];\r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      if (key && (\r\n        key.startsWith('cache_') || \r\n        key.startsWith('temp_') || \r\n        key.includes('cache')\r\n      )) {\r\n        cacheKeys.push(key);\r\n      }\r\n    }\r\n    \r\n    // 캐시 키 제거\r\n    cacheKeys.forEach(key => localStorage.removeItem(key));\r\n    \r\n    // 메모리 내 캐시 정리\r\n    cleanMemoryCache();\r\n    \r\n    // 브라우저 캐시 정리\r\n    clearBrowserCaches();\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('모든 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// 전역 API 노출\r\nif (isBrowser) {\r\n  if (!window.__memoryOptimizer) {\r\n    window.__memoryOptimizer = {};\r\n  }\r\n  \r\n  window.__memoryOptimizer.cleanAllCaches = cleanAllCaches;\r\n  window.__memoryOptimizer.suggestGarbageCollection = suggestGarbageCollection;\r\n  window.__memoryOptimizer.clearBrowserCaches = clearBrowserCaches;\r\n  window.__memoryOptimizer.clearStorageCaches = clearStorageCaches;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\gc\\cache-optimizer.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":12,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'caches' is not defined.","line":14,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":14,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'caches' is not defined.","line":17,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":17,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":21,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":21,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":33,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":33,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":34,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":36,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":36,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":42,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":42,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":43,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":43,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":45,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":45,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":50,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":50,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":65,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":65,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":65,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":65,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1444,1471],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":67,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":67,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":77,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":77,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":78,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":78,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":82,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":82,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'caches' is not defined.","line":83,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":83,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'caches' is not defined.","line":87,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":87,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":90,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":90,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":93,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":93,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":117,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":117,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":118,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":118,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":119,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":119,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":121,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":121,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":125,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":125,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":136,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":136,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":137,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":137,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":141,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":141,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":148,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":148,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":153,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":153,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":153,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":153,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":155,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":155,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":158,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":158,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":158,"column":42,"nodeType":"Identifier","messageId":"undef","endLine":158,"endColumn":51},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":160,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":160,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":168,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":168,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":182,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":182,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":184,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":184,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":186,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":186,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":191,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":191,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":205,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":205,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":205,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":205,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":208,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":208,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":217,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":217,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":221,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":221,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":221,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":221,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5323,5351],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":223,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":223,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":253,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":253,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":262,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":262,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":263,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":263,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":265,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":265,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":270,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":270,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":278,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":278,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":279,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":279,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":290,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":290,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":292,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":292,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":294,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":294,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":295,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":295,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":295,"column":61,"nodeType":"Identifier","messageId":"undef","endLine":295,"endColumn":67},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":297,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":297,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":298,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":298,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":302,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":302,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":314,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":314,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":316,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":316,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":317,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":317,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":318,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":318,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":318,"column":67,"nodeType":"Identifier","messageId":"undef","endLine":318,"endColumn":73},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":320,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":320,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":320,"column":53,"nodeType":"Identifier","messageId":"undef","endLine":320,"endColumn":69},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":323,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":323,"endColumn":14},{"ruleId":"no-unused-vars","severity":2,"message":"'clearStyleCache' is defined but never used.","line":331,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":331,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'clearStyleCache' is defined but never used.","line":331,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":331,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":332,"column":8,"nodeType":"Identifier","messageId":"undef","endLine":332,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":338,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":338,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":339,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":339,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":340,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":340,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":342,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":342,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":343,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":343,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":344,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":344,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":351,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":351,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":352,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":352,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":354,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":354,"endColumn":13},{"ruleId":"no-unused-vars","severity":2,"message":"'clearImageResizeCache' is defined but never used.","line":363,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":363,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'clearImageResizeCache' is defined but never used.","line":363,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":363,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":364,"column":8,"nodeType":"Identifier","messageId":"undef","endLine":364,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":370,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":370,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":371,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":371,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":372,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":372,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":378,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":378,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":379,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":379,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":381,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":381,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":381,"column":51,"nodeType":"Identifier","messageId":"undef","endLine":381,"endColumn":67}],"suppressedMessages":[],"errorCount":89,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 캐시 관련 최적화 모듈\r\n */\r\nimport { clearLargeObjectsAndCaches } from '../storage-cleaner';\r\n\r\n/**\r\n * 비활성 캐시 정리\r\n */\r\nexport function clearInactiveCache(): void {\r\n  // 캐시 정리 작업 구현\r\n  // 웹 애플리케이션에서 사용하는 임시 데이터 정리\r\n  if (window.caches) {\r\n    // 오래된 캐시 삭제 (선택적)\r\n    caches.keys().then(cacheNames => {\r\n      cacheNames.forEach(cacheName => {\r\n        if (cacheName.includes('temp') || cacheName.includes('nonessential')) {\r\n          caches.delete(cacheName);\r\n        }\r\n      });\r\n    }).catch(err => {\r\n      console.warn('캐시 정리 중 오류:', err);\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * 모든 낮은 우선순위 캐시 정리\r\n */\r\nexport function clearAllLowPriorityCache(): void {\r\n  // 낮은 우선순위 캐시 정리 작업 구현\r\n  try {\r\n    // 로컬 스토리지의 임시 항목 정리\r\n    if (window.localStorage) {\r\n      Object.keys(localStorage).forEach(key => {\r\n        if (key.startsWith('temp_') || key.startsWith('cache_')) {\r\n          localStorage.removeItem(key);\r\n        }\r\n      });\r\n    }\r\n    \r\n    // 세션 스토리지의 임시 항목 정리\r\n    if (window.sessionStorage) {\r\n      Object.keys(sessionStorage).forEach(key => {\r\n        if (key.startsWith('temp_') || key.includes('cache')) {\r\n          sessionStorage.removeItem(key);\r\n        }\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.warn('우선순위가 낮은 캐시 정리 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 모든 캐시 정리\r\n */\r\nexport function clearAllCache(): void {\r\n  try {\r\n    // 브라우저 캐시 정리\r\n    clearBrowserCache();\r\n    \r\n    // 애플리케이션 캐시 정리\r\n    clearAppCache();\r\n    \r\n    console.log('모든 캐시 정리 완료');\r\n  } catch (error) {\r\n    console.error('캐시 정리 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 브라우저 캐시 정리 (가능한 경우)\r\n */\r\nfunction clearBrowserCache(): void {\r\n  try {\r\n    // sessionStorage 초기화 (이 세션 전용)\r\n    if (window.sessionStorage) {\r\n      sessionStorage.clear();\r\n    }\r\n    \r\n    // Cache API를 사용하는 경우 (Service Worker 캐시 등)\r\n    if ('caches' in window) {\r\n      caches.keys().then(cacheNames => {\r\n        cacheNames.forEach(cacheName => {\r\n          // 앱 전용 캐시만 정리 (다른 웹사이트 캐시는 건드리지 않음)\r\n          if (cacheName.includes('typing-stats-app')) {\r\n            caches.delete(cacheName);\r\n          }\r\n        });\r\n      }).catch(e => console.warn('캐시 API 접근 오류:', e));\r\n    }\r\n  } catch (error) {\r\n    console.warn('브라우저 캐시 정리 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 애플리케이션 캐시 정리\r\n */\r\nfunction clearAppCache(): void {\r\n  try {\r\n    // 앱 정의 캐시 객체 정리\r\n    \r\n    // 1. 이미지 변환 캐시\r\n    cleanupImageResizeCache();\r\n    \r\n    // 2. 객체 URL 캐시\r\n    cleanupObjectUrls();\r\n    \r\n    // 3. 일반 메모리 캐시\r\n    cleanupMemoryCache();\r\n    \r\n    // 4. 스타일 캐시\r\n    cleanupStyleCache();\r\n    \r\n    // 5. 위젯 캐시\r\n    if (window.__widgetCache) {\r\n      if (window.__widgetCache instanceof Map) {\r\n        window.__widgetCache.clear();\r\n      } else {\r\n        window.__widgetCache = new Map<string, any>();\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.warn('앱 캐시 정리 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 모든 캐시 해제 (가장 극단적인 조치)\r\n */\r\nexport function releaseAllCaches(): void {\r\n  // 모든 캐시 해제 작업 구현\r\n  try {\r\n    // IndexedDB 캐시 정리\r\n    if (window.indexedDB) {\r\n      window.indexedDB.databases().then(databases => {\r\n        databases.forEach(db => {\r\n          try {\r\n            if (db.name) { // null 체크 추가\r\n              window.indexedDB.deleteDatabase(db.name);\r\n            }\r\n          } catch (e) {\r\n            // 개별 DB 삭제 실패 처리\r\n          }\r\n        });\r\n      }).catch(err => {\r\n        console.warn('IndexedDB 정리 중 오류:', err);\r\n      });\r\n    }\r\n    \r\n    // Storage API 정리\r\n    if (navigator.storage && navigator.storage.estimate) {\r\n      // 사용량 확인 후 필요시 정리\r\n      navigator.storage.estimate().then(estimate => {\r\n        if (estimate.usage && estimate.usage > 10 * 1024 * 1024) {\r\n          // 10MB 이상 사용 중인 경우 캐시 정리 시도\r\n          if (navigator.serviceWorker && navigator.serviceWorker.controller) {\r\n            // 서비스 워커에 캐시 정리 요청\r\n            navigator.serviceWorker.controller.postMessage({\r\n              type: 'CLEAR_ALL_CACHES'\r\n            });\r\n          }\r\n        }\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.warn('모든 캐시 해제 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 스토리지 캐시 정리\r\n * localStorage, sessionStorage 등의 캐시 정리\r\n */\r\nexport function clearStorageCaches(): void {\r\n  try {\r\n    // 로컬 스토리지와 대형 객체 캐시 정리\r\n    clearLargeObjectsAndCaches();\r\n    \r\n    // 추가 스토리지 캐시 정리 작업\r\n    if (window.sessionStorage) {\r\n      // 세션 스토리지 정리 (temp_ 또는 cache_ 시작하는 항목)\r\n      Object.keys(sessionStorage).forEach(key => {\r\n        if (key.startsWith('temp_') || key.startsWith('cache_')) {\r\n          sessionStorage.removeItem(key);\r\n        }\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.warn('스토리지 캐시 정리 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 오래된 캐시 항목만 정리\r\n */\r\nexport function clearOldCache(): void {\r\n  try {\r\n    // 일정 기간 이상 지난 캐시만 정리\r\n    const now = Date.now();\r\n    const CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24시간\r\n    \r\n    // 메모리 캐시에서 오래된 항목 제거 - WeakMap은 forEach를 지원하지 않음\r\n    if (window.__memoryCache && window.__memoryCache instanceof Map) {\r\n      const keysToDelete: any[] = [];\r\n      \r\n      window.__memoryCache.forEach((value, key) => {\r\n        if (value && typeof value === 'object' && value.timestamp) {\r\n          if (now - value.timestamp > CACHE_EXPIRY) {\r\n            keysToDelete.push(key);\r\n          }\r\n        }\r\n      });\r\n      \r\n      keysToDelete.forEach(key => {\r\n        window.__memoryCache?.delete(key);\r\n      });\r\n    }\r\n    \r\n    console.log('오래된 캐시 정리 완료');\r\n  } catch (error) {\r\n    console.warn('오래된 캐시 정리 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 캐시 최적화 유틸리티\r\n */\r\n\r\n/**\r\n * 브라우저 캐시 정리\r\n * @returns {boolean} 성공 여부\r\n */\r\nexport function cleanupCache(): boolean {\r\n  if (typeof window === 'undefined') return false;\r\n  \r\n  try {\r\n    // 객체 URL 캐시 정리\r\n    cleanupObjectUrls();\r\n    \r\n    // 메모리 캐시 정리\r\n    cleanupMemoryCache();\r\n    \r\n    // 스타일 캐시 정리\r\n    cleanupStyleCache();\r\n    \r\n    // 이미지 리사이즈 캐시 정리\r\n    cleanupImageResizeCache();\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('캐시 정리 중 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 객체 URL 캐시 정리\r\n */\r\nfunction cleanupObjectUrls(): void {\r\n  if (window.__objectUrls) {\r\n    window.__objectUrls.forEach(url => {\r\n      try {\r\n        URL.revokeObjectURL(url);\r\n      } catch (e) {\r\n        // 오류 무시\r\n      }\r\n    });\r\n    window.__objectUrls.clear();\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 캐시 정리\r\n */\r\nfunction cleanupMemoryCache(): void {\r\n  if (window.__memoryCache) {\r\n    window.__memoryCache.clear();\r\n  }\r\n}\r\n\r\n/**\r\n * 스타일 캐시 정리\r\n */\r\nfunction cleanupStyleCache(): void {\r\n  if (typeof window === 'undefined') return;\r\n  \r\n  // 안전 타입 확인 후 접근\r\n  if (window.__styleCache) {\r\n    try {\r\n      if (window.__styleCache instanceof Map) {\r\n        // Map인 경우 clear 메서드 사용\r\n        window.__styleCache.clear();\r\n      } else if (typeof window.__styleCache === 'object' && window.__styleCache !== null) {\r\n        // 일반 객체인 경우 속성 삭제\r\n        Object.keys(window.__styleCache).forEach(key => {\r\n          delete (window.__styleCache as Record<string, any>)[key];\r\n        });\r\n      }\r\n    } catch (error) {\r\n      console.error('스타일 캐시 정리 오류:', error);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 이미지 리사이즈 캐시 정리\r\n */\r\nfunction cleanupImageResizeCache(): void {\r\n  if (typeof window === 'undefined') return;\r\n  \r\n  // 안전 타입 확인 후 접근\r\n  if (window.__imageResizeCache) {\r\n    try {\r\n      if (window.__imageResizeCache instanceof Map) {\r\n        window.__imageResizeCache.clear();\r\n      } else if (typeof window.__imageResizeCache === 'object' && window.__imageResizeCache !== null) {\r\n        // Map이 아닌 경우 새 Map으로 교체 (권장 방식)\r\n        window.__imageResizeCache = new Map<string, HTMLImageElement>();\r\n      }\r\n    } catch (error) {\r\n      console.error('이미지 리사이즈 캐시 정리 오류:', error);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 스타일 캐시 정리 (키를 지정하거나 전체 삭제)\r\n */\r\nfunction clearStyleCache(key?: string): boolean {\r\n  if (!window.__styleCache) {\r\n    return false;\r\n  }\r\n  \r\n  if (key) {\r\n    // Map인지 일반 객체인지 확인 후 적절한 방식으로 삭제\r\n    if (window.__styleCache instanceof Map) {\r\n      if (window.__styleCache.has(key)) {\r\n        return window.__styleCache.delete(key);\r\n      }\r\n    } else if (typeof window.__styleCache === 'object') {\r\n      if (key in (window.__styleCache as Record<string, any>)) {\r\n        delete (window.__styleCache as Record<string, any>)[key];\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  } else {\r\n    // 전체 캐시 삭제\r\n    if (window.__styleCache instanceof Map) {\r\n      window.__styleCache.clear();\r\n    } else {\r\n      window.__styleCache = {};\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * 이미지 리사이즈 캐시 정리 (키를 지정하거나 전체 삭제)\r\n */\r\nfunction clearImageResizeCache(key?: string): boolean {\r\n  if (!window.__imageResizeCache) {\r\n    return false;\r\n  }\r\n  \r\n  if (key) {\r\n    // Map 객체이므로 get 메서드 사용\r\n    if (window.__imageResizeCache instanceof Map) {\r\n      if (window.__imageResizeCache.has(key)) {\r\n        return window.__imageResizeCache.delete(key);\r\n      }\r\n    }\r\n    return false;\r\n  } else {\r\n    // 전체 캐시 삭제\r\n    if (window.__imageResizeCache instanceof Map) {\r\n      window.__imageResizeCache.clear();\r\n    } else {\r\n      window.__imageResizeCache = new Map<string, HTMLImageElement>();\r\n    }\r\n    return true;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\gc\\cache-utils.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":13,"column":8,"nodeType":"Identifier","messageId":"undef","endLine":13,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":15,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":15,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":18,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":18,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":24,"column":52,"nodeType":"Identifier","messageId":"undef","endLine":24,"endColumn":68},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":29,"column":8,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":29,"column":39,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":31,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":31,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":34,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":66,"column":55,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":71},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":73,"column":61,"nodeType":"Identifier","messageId":"undef","endLine":73,"endColumn":77}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 안전한 캐시 접근 유틸리티 함수들\r\n */\r\n\r\n/**\r\n * 스타일 캐시 안전하게 접근\r\n */\r\nexport function getStyleCache(): Record<string, any> | Map<string, any> {\r\n  if (typeof window === 'undefined') {\r\n    return {};\r\n  }\r\n  \r\n  if (!window.__styleCache) {\r\n    // 캐시가 없으면 초기화\r\n    window.__styleCache = {};\r\n  }\r\n  \r\n  return window.__styleCache;\r\n}\r\n\r\n/**\r\n * 이미지 리사이즈 캐시 안전하게 접근\r\n */\r\nexport function getImageResizeCache(): Map<string, HTMLImageElement> {\r\n  if (typeof window === 'undefined') {\r\n    return new Map();\r\n  }\r\n  \r\n  if (!window.__imageResizeCache || !(window.__imageResizeCache instanceof Map)) {\r\n    // 캐시가 없거나 Map이 아닌 경우 초기화\r\n    window.__imageResizeCache = new Map();\r\n  }\r\n  \r\n  return window.__imageResizeCache;\r\n}\r\n\r\n/**\r\n * 스타일 캐시에서 값 가져오기\r\n */\r\nexport function getStyleCacheItem<T = any>(key: string): T | undefined {\r\n  const cache = getStyleCache();\r\n  \r\n  if (cache instanceof Map) {\r\n    return cache.get(key) as T | undefined;\r\n  } else {\r\n    return (cache as Record<string, any>)[key] as T | undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * 스타일 캐시에 값 설정하기\r\n */\r\nexport function setStyleCacheItem<T = any>(key: string, value: T): void {\r\n  const cache = getStyleCache();\r\n  \r\n  if (cache instanceof Map) {\r\n    cache.set(key, value);\r\n  } else {\r\n    (cache as Record<string, any>)[key] = value;\r\n  }\r\n}\r\n\r\n/**\r\n * 이미지 리사이즈 캐시에서 값 가져오기\r\n */\r\nexport function getImageResizeCacheItem(key: string): HTMLImageElement | undefined {\r\n  return getImageResizeCache().get(key);\r\n}\r\n\r\n/**\r\n * 이미지 리사이즈 캐시에 값 설정하기\r\n */\r\nexport function setImageResizeCacheItem(key: string, value: HTMLImageElement): void {\r\n  getImageResizeCache().set(key, value);\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\gc\\dom-cleanup-util.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":21,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":21,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":21,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":21,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[341,366],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":23,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":23,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":32,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":32,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'NodeListOf' is not defined.","line":32,"column":56,"nodeType":"Identifier","messageId":"undef","endLine":32,"endColumn":66},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":32,"column":67,"nodeType":"Identifier","messageId":"undef","endLine":32,"endColumn":83},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":38,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":38,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":40,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":53,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":53,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":53,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":53,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1161,1211],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":56,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":56,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":66,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'NodeListOf' is not defined.","line":66,"column":85,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":95},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":66,"column":96,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":107},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":81,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":81,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":81,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":81,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1899,1946],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":84,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":84,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":94,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":94,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":94,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":94,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2187,2238],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * DOM 클린업 유틸리티\r\n * 메모리 사용량을 줄이기 위한 DOM 관련 정리 함수\r\n */\r\n\r\n/**\r\n * DOM 요소 정리 수행\r\n * 필요없는 DOM 요소와 이벤트 리스너 제거\r\n */\r\nexport function cleanupDOM(): void {\r\n  try {\r\n    // 비표시 이미지 최적화\r\n    optimizeOffscreenImages();\r\n    \r\n    // 숨겨진 요소 정리\r\n    cleanupHiddenElements();\r\n    \r\n    // 이벤트 리스너 정리\r\n    cleanupUnusedEventListeners();\r\n    \r\n    console.log('DOM 정리 완료');\r\n  } catch (error) {\r\n    console.error('DOM 정리 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 화면에 보이지 않는 이미지 최적화\r\n */\r\nfunction optimizeOffscreenImages(): void {\r\n  try {\r\n    const images = document.querySelectorAll('img') as NodeListOf<HTMLImageElement>;\r\n    let optimizedCount = 0;\r\n    \r\n    images.forEach(img => {\r\n      const rect = img.getBoundingClientRect();\r\n      const isVisible = (\r\n        rect.top < window.innerHeight &&\r\n        rect.bottom > 0 &&\r\n        rect.left < window.innerWidth &&\r\n        rect.right > 0\r\n      );\r\n      \r\n      // 화면 밖의 이미지를 저해상도로 대체하거나 데이터 속성으로 원본 주소 이동\r\n      if (!isVisible && !img.dataset.original) {\r\n        img.dataset.original = img.src;\r\n        img.src = '';\r\n        optimizedCount++;\r\n      }\r\n    });\r\n    \r\n    if (optimizedCount > 0) {\r\n      console.log(`최적화된 오프스크린 이미지: ${optimizedCount}개`);\r\n    }\r\n  } catch (error) {\r\n    console.warn('이미지 최적화 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 숨겨진 요소 정리\r\n */\r\nfunction cleanupHiddenElements(): void {\r\n  try {\r\n    // display: none인 대형 컨테이너 정리\r\n    const hiddenElements = document.querySelectorAll('[style*=\"display: none\"]') as NodeListOf<HTMLElement>;\r\n    let cleanedElements = 0;\r\n    \r\n    hiddenElements.forEach(el => {\r\n      // 단, 애플리케이션에 중요한 요소는 제외\r\n      if (!el.classList.contains('app-critical') && \r\n          !el.id.includes('critical') &&\r\n          el.children.length > 10) {\r\n        // 내용 임시 제거 (참조는 유지)\r\n        el.innerHTML = '';\r\n        cleanedElements++;\r\n      }\r\n    });\r\n    \r\n    if (cleanedElements > 0) {\r\n      console.log(`정리된 숨겨진 요소: ${cleanedElements}개`);\r\n    }\r\n  } catch (error) {\r\n    console.warn('숨겨진 요소 정리 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 사용하지 않는 이벤트 리스너 정리\r\n */\r\nfunction cleanupUnusedEventListeners(): void {\r\n  // 이 기능은 완전히 구현하기 어려움\r\n  // DOM API에서 요소에 연결된 이벤트 리스너를 직접 확인하는 방법이 없음\r\n  console.log('이벤트 리스너 정리 - 현재 API 제한으로 인해 구현되지 않음');\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\gc\\dom-cleanup.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":24,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":24,"endColumn":12}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * DOM 요소 정리 유틸리티\r\n */\r\n\r\n/**\r\n * 사용하지 않는 DOM 요소 정리\r\n * @returns {boolean} 성공 여부\r\n */\r\nexport function cleanupDom(): boolean {\r\n  if (typeof window === 'undefined') return false;\r\n  \r\n  try {\r\n    // 미사용 이벤트 리스너 정리\r\n    cleanupEventListeners();\r\n    \r\n    // 숨겨진 요소의 자식 요소 정리\r\n    cleanupHiddenElements();\r\n    \r\n    // 데이터 속성 정리\r\n    cleanupDataAttributes();\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('DOM 정리 중 오류 발생:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 이벤트 리스너 정리\r\n */\r\nfunction cleanupEventListeners(): void {\r\n  // 구현 필요\r\n}\r\n\r\n/**\r\n * 숨겨진 요소 최적화\r\n */\r\nfunction cleanupHiddenElements(): void {\r\n  // 구현 필요\r\n}\r\n\r\n/**\r\n * 데이터 속성 정리\r\n */\r\nfunction cleanupDataAttributes(): void {\r\n  // 구현 필요\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\gc\\dom-optimizer.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":14,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":14,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":16,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":22,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":25,"column":41,"nodeType":"Identifier","messageId":"undef","endLine":25,"endColumn":47},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":26,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":26,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":32,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":32,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":46,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":46,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":47,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":47,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":50,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":50,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":64,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":64,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":66,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":74,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":74,"endColumn":12}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * DOM 관련 최적화 모듈\r\n */\r\nimport { cleanupDOM } from '../dom-optimizer';\r\nimport { clearImageCache } from '../image-optimizer';\r\n\r\n/**\r\n * DOM 최적화\r\n */\r\nexport function optimizeDOM(): void {\r\n  // DOM 최적화 작업 구현\r\n  try {\r\n    // 숨겨진 DOM 요소 정리\r\n    const hiddenElements = document.querySelectorAll('.hidden, [hidden], [style*=\"display: none\"]');\r\n    hiddenElements.forEach(el => {\r\n      if (el instanceof HTMLElement) {\r\n        el.innerHTML = '';\r\n      }\r\n    });\r\n    \r\n    // 뷰포트 밖 DOM 요소 최적화\r\n    const elements = document.querySelectorAll('.optimize-offscreen');\r\n    elements.forEach(el => {\r\n      const rect = el.getBoundingClientRect();\r\n      if (rect.bottom < 0 || rect.top > window.innerHeight) {\r\n        const htmlEl = el as HTMLElement;\r\n        htmlEl.dataset.originalDisplay = htmlEl.style.display || '';\r\n        htmlEl.style.display = 'none';\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.warn('DOM 최적화 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 이미지 캐시 정리\r\n * 이미지 최적화 모듈과 연계하여 메모리 사용량 절감\r\n */\r\nexport function clearImageCaches(): void {\r\n  try {\r\n    // 이미지 최적화 모듈 활용\r\n    clearImageCache();\r\n    \r\n    // 추가 이미지 관련 캐시 정리\r\n    if (window._imageCache) {\r\n      window._imageCache.clear();\r\n    }\r\n  } catch (error) {\r\n    console.warn('이미지 캐시 정리 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * DOM 참조 정리\r\n * DOM 참조로 인한 메모리 누수 방지\r\n */\r\nexport function cleanupDOMReferences(): void {\r\n  try {\r\n    // DOM 참조 정리 작업 구현\r\n    cleanupDOM();\r\n    \r\n    // 추가 DOM 참조 정리 작업\r\n    const obsoleteRefs = document.querySelectorAll('[data-memory-release=\"true\"]');\r\n    obsoleteRefs.forEach(el => {\r\n      if (el instanceof HTMLElement) {\r\n        el.innerHTML = '';\r\n        if (el.parentNode && !el.dataset.keepParent) {\r\n          el.parentNode.removeChild(el);\r\n        }\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.warn('DOM 참조 정리 중 오류:', error);\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\gc\\emergency-recovery.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":14,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":14,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":30,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":30,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'global' is not defined.","line":39,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":39,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'global' is not defined.","line":40,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":77,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":77,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":77,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":77,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"debug"},"fix":{"range":[1556,1594],"text":""},"desc":"Remove the console.debug()."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":89,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":89,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":90,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":90,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":90,"column":40,"nodeType":"Identifier","messageId":"undef","endLine":90,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":91,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":91,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":104,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":104,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'Window' is not defined.","line":104,"column":45,"nodeType":"Identifier","messageId":"undef","endLine":104,"endColumn":51}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 비상 메모리 복구 유틸리티\r\n */\r\n\r\n/**\r\n * 비상 복구 모드\r\n * 메모리 부족 상황에서 적극적으로 리소스 정리\r\n * @returns {boolean} 성공 여부\r\n */\r\nexport function emergencyRecovery(): boolean {\r\n  if (typeof window === 'undefined') return false;\r\n  \r\n  try {\r\n    console.warn('비상 메모리 복구 모드 활성화');\r\n    \r\n    // 강제 가비지 컬렉션\r\n    forcedGarbageCollection();\r\n    \r\n    // 모든 캐시 정리\r\n    clearAllCaches();\r\n    \r\n    // 비필수 DOM 요소 정리\r\n    releaseNonEssentialDOM();\r\n    \r\n    // 이미지 다운샘플링\r\n    downsampleImages();\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('비상 복구 중 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 강제 가비지 컬렉션\r\n */\r\nfunction forcedGarbageCollection(): void {\r\n  if (global.gc) {\r\n    global.gc();\r\n  }\r\n  \r\n  // 메모리 압력 생성\r\n  createEmergencyPressure();\r\n}\r\n\r\n/**\r\n * 메모리 압력 상황에서 비상 조치 수행\r\n */\r\nfunction createEmergencyPressure() {\r\n  try {\r\n    const buffers = [];\r\n    // TypeScript 타입 오류 해결을 위해 문자열 키 사용\r\n    const bufferKeys: Record<string, boolean> = {};\r\n    \r\n    // 임시 버퍼 할당으로 메모리 압력 생성\r\n    for (let i = 0; i < 10; i++) {\r\n      const key = `buffer_${i}`;\r\n      buffers.push(new ArrayBuffer(1024 * 1024)); // 1MB\r\n      bufferKeys[key] = true; // 문자열 키로 접근\r\n    }\r\n    \r\n    // 참조 해제로 GC 유도\r\n    for (let i = 0; i < buffers.length; i++) {\r\n      // null 대신 undefined 사용 (타입 안전성 향상)\r\n      buffers[i] = undefined as unknown as ArrayBuffer;\r\n    }\r\n    buffers.length = 0;\r\n    \r\n    // 명시적으로 객체 키 삭제\r\n    Object.keys(bufferKeys).forEach(key => {\r\n      delete bufferKeys[key];\r\n    });\r\n    \r\n  } catch (error) {\r\n    // 메모리 부족 오류는 무시 (의도된 효과)\r\n    console.debug('비상 메모리 압력 생성 중 오류 발생');\r\n  }\r\n}\r\n\r\n// 캐시 이름 타입 정의 - 타입 안전성 향상\r\ntype CacheName = '__memoryCache' | '__styleCache' | '__widgetCache' | '__imageResizeCache';\r\n\r\n/**\r\n * 모든 캐시 정리\r\n */\r\nfunction clearAllCaches(): void {\r\n  // 객체 URL\r\n  if (window.__objectUrls) {\r\n    window.__objectUrls.forEach(url => URL.revokeObjectURL(url));\r\n    window.__objectUrls.clear();\r\n  }\r\n  \r\n  // 모든 커스텀 캐시 정리\r\n  const cacheNames: CacheName[] = [\r\n    '__memoryCache',\r\n    '__styleCache',\r\n    '__widgetCache',\r\n    '__imageResizeCache'\r\n  ];\r\n  \r\n  cacheNames.forEach(cacheName => {\r\n    // 타입 안전성을 위한 타입 가드 사용\r\n    const cache = window[cacheName as keyof Window];\r\n    if (cache) {\r\n      if (cache instanceof Map) {\r\n        // Map 타입 확인 후 안전한 호출\r\n        (cache as Map<any, any>).clear();\r\n      } else if (typeof cache === 'object' && cache !== null) {\r\n        // 객체인 경우 속성 제거\r\n        Object.keys(cache as object).forEach(key => {\r\n          delete (cache as Record<string, any>)[key];\r\n        });\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * 비필수 DOM 요소 정리\r\n */\r\nfunction releaseNonEssentialDOM(): void {\r\n  // 구현 필요\r\n}\r\n\r\n/**\r\n * 이미지 다운샘플링\r\n */\r\nfunction downsampleImages(): void {\r\n  // 구현 필요\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\gc\\event-optimizer.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'EventHandler' is defined but never used.","line":8,"column":6,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EventHandler' is defined but never used.","line":8,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":25,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":25,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'Window' is not defined.","line":25,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":25,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'Document' is not defined.","line":25,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":25,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'EventListenerOrEventListenerObject' is not defined.","line":27,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":27,"endColumn":46},{"ruleId":"no-undef","severity":2,"message":"'AddEventListenerOptions' is not defined.","line":28,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":28,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":32,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":32,"endColumn":12},{"ruleId":"no-unused-vars","severity":2,"message":"'args' is defined but never used.","line":63,"column":59,"nodeType":"Identifier","messageId":"unusedVar","endLine":63,"endColumn":63},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":74,"column":51,"nodeType":"Identifier","messageId":"undef","endLine":74,"endColumn":62},{"ruleId":"no-undef","severity":2,"message":"'Window' is not defined.","line":74,"column":65,"nodeType":"Identifier","messageId":"undef","endLine":74,"endColumn":71},{"ruleId":"no-undef","severity":2,"message":"'Document' is not defined.","line":74,"column":74,"nodeType":"Identifier","messageId":"undef","endLine":74,"endColumn":82},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":90,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":90,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'Window' is not defined.","line":90,"column":47,"nodeType":"Identifier","messageId":"undef","endLine":90,"endColumn":53},{"ruleId":"no-undef","severity":2,"message":"'Document' is not defined.","line":90,"column":56,"nodeType":"Identifier","messageId":"undef","endLine":90,"endColumn":64},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":91,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":91,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":93,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":93,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":95,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":95,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":117,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":117,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":117,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":117,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2939,3006],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":121,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":121,"endColumn":12},{"ruleId":"no-unused-vars","severity":2,"message":"'event' is defined but never used.","line":132,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":132,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'Event' is not defined.","line":132,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":132,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":140,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":140,"endColumn":11},{"ruleId":"no-unused-vars","severity":2,"message":"'event' is defined but never used.","line":154,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":154,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'UIEvent' is not defined.","line":154,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":154,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":161,"column":41,"nodeType":"Identifier","messageId":"undef","endLine":161,"endColumn":47},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":180,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":180,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'_key' is assigned a value but never used.","line":183,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":183,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_key' is assigned a value but never used.","line":183,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":183,"endColumn":23}],"suppressedMessages":[],"errorCount":27,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 이벤트 관련 메모리 최적화\r\n * 과도한 이벤트 리스너와 관련된 메모리 누수 방지\r\n */\r\n\r\nimport { debounce } from 'lodash';\r\n\r\ntype EventHandler = () => void;\r\ntype EventCleanupHandler = () => void;\r\ntype EventCleanupRegistry = Map<string, EventCleanupHandler[]>;\r\n\r\n// 이벤트 핸들러 등록 관리\r\nconst eventCleanupRegistry: EventCleanupRegistry = new Map();\r\n// 사용되지 않는 변수 제거: const globalHandlers = {};\r\n\r\n/**\r\n * 최적화된 이벤트 리스너 등록\r\n * @param element DOM 엘리먼트\r\n * @param eventType 이벤트 타입\r\n * @param handler 이벤트 핸들러\r\n * @param options 이벤트 리스너 옵션\r\n * @returns 정리 함수\r\n */\r\nexport function registerOptimizedEventListener(\r\n  element: HTMLElement | Window | Document,\r\n  eventType: string,\r\n  handler: EventListenerOrEventListenerObject,\r\n  options?: AddEventListenerOptions | boolean\r\n): EventCleanupHandler {\r\n  // 요소와 핸들러가 있는지 확인\r\n  if (!element || !handler) {\r\n    console.warn('Invalid element or handler for event registration');\r\n    return () => {}; // No-op cleanup function\r\n  }\r\n\r\n  // 이벤트 리스너 등록\r\n  element.addEventListener(eventType, handler, options);\r\n  \r\n  // 정리 함수 생성\r\n  const cleanup = () => {\r\n    element.removeEventListener(eventType, handler, options);\r\n  };\r\n  \r\n  // 등록된 정리 함수를 등록\r\n  const key = getElementKey(element);\r\n  \r\n  if (!eventCleanupRegistry.has(key)) {\r\n    eventCleanupRegistry.set(key, []);\r\n  }\r\n  \r\n  const cleanupHandlers = eventCleanupRegistry.get(key)!;\r\n  cleanupHandlers.push(cleanup);\r\n  \r\n  return cleanup;\r\n}\r\n\r\n/**\r\n * 디바운스된 이벤트 핸들러 생성\r\n * @param handler 원본 핸들러\r\n * @param wait 대기 시간\r\n * @returns 디바운스된 핸들러\r\n */\r\nexport function createDebouncedEventHandler<T extends (...args: any[]) => void>(\r\n  handler: T,\r\n  wait: number\r\n): T {\r\n  return debounce(handler, wait) as unknown as T;\r\n}\r\n\r\n/**\r\n * 특정 요소의 모든 이벤트 리스너 정리\r\n * @param element DOM 엘리먼트\r\n */\r\nexport function cleanupAllEventListeners(element: HTMLElement | Window | Document): void {\r\n  const key = getElementKey(element);\r\n  const cleanupHandlers = eventCleanupRegistry.get(key);\r\n  \r\n  if (cleanupHandlers && cleanupHandlers.length > 0) {\r\n    // 모든 정리 함수 실행\r\n    cleanupHandlers.forEach(cleanup => cleanup());\r\n    \r\n    // 정리 함수 목록 비우기\r\n    eventCleanupRegistry.set(key, []);\r\n  }\r\n}\r\n\r\n/**\r\n * 요소에 대한 고유 키 생성\r\n */\r\nfunction getElementKey(element: HTMLElement | Window | Document): string {\r\n  if (element === window) {\r\n    return 'window';\r\n  } else if (element === document) {\r\n    return 'document';\r\n  } else if (element instanceof HTMLElement) {\r\n    // ID가 있으면 사용, 없으면 태그명과 클래스 사용\r\n    const id = element.id || '';\r\n    const tagName = element.tagName || '';\r\n    const classes = element.className || '';\r\n    \r\n    return `${tagName}#${id}.${classes}`;\r\n  } else {\r\n    return String(Math.random()); // 폴백\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 누수 방지를 위한 이벤트 최적화\r\n */\r\nexport function optimizeEvents(): void {\r\n  // 현재 등록된 모든 이벤트 정리 핸들러 수 확인\r\n  let totalHandlers = 0;\r\n  for (const handlers of eventCleanupRegistry.values()) {\r\n    totalHandlers += handlers.length;\r\n  }\r\n  \r\n  console.log(`Current event handlers registered: ${totalHandlers}`);\r\n  \r\n  // 지나치게 많은 핸들러가 등록되어 있다면 경고\r\n  if (totalHandlers > 100) {\r\n    console.warn('High number of event handlers detected. Consider cleaning up unused listeners.');\r\n  }\r\n}\r\n\r\n/**\r\n * 스크롤 이벤트 최적화\r\n * @param handler 스크롤 이벤트 핸들러\r\n * @param wait 디바운스 대기 시간\r\n * @returns 정리 함수\r\n */\r\nexport function registerOptimizedScrollListener(\r\n  handler: (event: Event) => void,\r\n  wait = 100\r\n): EventCleanupHandler {\r\n  // 디바운스된 핸들러 생성\r\n  const debouncedHandler = createDebouncedEventHandler(handler, wait);\r\n  \r\n  // 스크롤 이벤트 리스너 등록 (passive true로 성능 최적화)\r\n  return registerOptimizedEventListener(\r\n    window,\r\n    'scroll',\r\n    debouncedHandler,\r\n    { passive: true }\r\n  );\r\n}\r\n\r\n/**\r\n * 리사이즈 이벤트 최적화\r\n * @param handler 리사이즈 이벤트 핸들러\r\n * @param wait 디바운스 대기 시간\r\n * @returns 정리 함수\r\n */\r\nexport function registerOptimizedResizeListener(\r\n  handler: (event: UIEvent) => void,\r\n  wait = 200\r\n): EventCleanupHandler {\r\n  // 디바운스된 핸들러 생성\r\n  const debouncedHandler = createDebouncedEventHandler(handler, wait);\r\n  \r\n  // 리사이즈 이벤트 리스너 등록\r\n  return registerOptimizedEventListener(window, 'resize', debouncedHandler);\r\n}\r\n\r\n/**\r\n * 이벤트 최적화 모듈 - ES 모듈 방식으로 내보내기\r\n */\r\nexport default {\r\n  registerOptimizedEventListener,\r\n  createDebouncedEventHandler,\r\n  cleanupAllEventListeners,\r\n  optimizeEvents,\r\n  registerOptimizedScrollListener,\r\n  registerOptimizedResizeListener\r\n};\r\n\r\n/**\r\n * 페이지 언로드 시 남아있는 모든 핸들러 정리\r\n */\r\nif (typeof window !== 'undefined') {\r\n  window.addEventListener('beforeunload', () => {\r\n    try {\r\n      // 모든 등록된 정리 함수 실행\r\n      for (const [_key, handlers] of eventCleanupRegistry.entries()) {\r\n        handlers.forEach(cleanup => cleanup());\r\n      }\r\n      \r\n      // 등록 정보 초기화\r\n      eventCleanupRegistry.clear();\r\n    } catch (_) {\r\n      // 언로드 중 오류는 무시\r\n    }\r\n  });\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\gc\\garbage-collector.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":26,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":26,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":70,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":70,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":70,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1603,1661],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":73,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":73,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":75,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":75,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":75,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":75,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1727,1764],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":76,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":76,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":77,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":77,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":77,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":77,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1792,1823],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":87,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":87,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":98,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":98,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":109,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":109,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":109,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":109,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2572,2604],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":110,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":110,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":136,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":136,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":149,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":149,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":149,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":149,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3682,3767],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":159,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":159,"endColumn":12}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 가비지 컬렉션 유틸리티\r\n * \r\n * 메모리 GC 및 최적화 기능을 제공합니다.\r\n */\r\n\r\nimport { OptimizationLevel, GCResult } from '../types';\r\nimport { MemoryInfo } from '@/types';\r\nimport { MEMORY_THRESHOLDS } from '../constants/memory-thresholds';\r\nimport { getMemoryUsage } from '../memory-info';\r\n\r\n// 마지막 GC 시간 추적\r\nlet lastGCTime = 0;\r\nconst MIN_GC_INTERVAL = MEMORY_THRESHOLDS.MIN_GC_INTERVAL; // 30초\r\n\r\n/**\r\n * 메모리 정보 확인 또는 생성\r\n */\r\nexport async function ensureMemoryInfo(): Promise<MemoryInfo> {\r\n  try {\r\n    const info = await getMemoryUsage();\r\n    if (info) {\r\n      return info;\r\n    }\r\n  } catch (error) {\r\n    console.error('메모리 정보 가져오기 실패:', error);\r\n  }\r\n  \r\n  // 오류 발생 시 기본값 반환\r\n  return {\r\n    heap_used: 0,\r\n    heapUsed: 0,\r\n    heap_total: 0,\r\n    heapTotal: 0,\r\n    heap_used_mb: 0,\r\n    heapUsedMB: 0,\r\n    rss: 0,\r\n    rss_mb: 0,\r\n    rssMB: 0,\r\n    percent_used: 0,\r\n    percentUsed: 0,\r\n    heap_limit: 0,\r\n    timestamp: Date.now()\r\n  };\r\n}\r\n\r\n/**\r\n * 최적화 레벨 결정\r\n */\r\nexport function determineOptimizationLevel(info: MemoryInfo): OptimizationLevel {\r\n  const usedMB = info.heap_used_mb;\r\n  \r\n  if (usedMB < MEMORY_THRESHOLDS.LOW) {\r\n    return OptimizationLevel.None;\r\n  } else if (usedMB < MEMORY_THRESHOLDS.MEDIUM) {\r\n    return OptimizationLevel.Low;\r\n  } else if (usedMB < MEMORY_THRESHOLDS.HIGH) {\r\n    return OptimizationLevel.Medium;\r\n  } else if (usedMB < MEMORY_THRESHOLDS.CRITICAL) {\r\n    return OptimizationLevel.High;\r\n  } else {\r\n    return OptimizationLevel.Extreme;\r\n  }\r\n}\r\n\r\n/**\r\n * 기본 GC 수행\r\n */\r\nexport async function performGC(emergency: boolean = false): Promise<GCResult> {\r\n  console.log(`[GC] ${emergency ? '긴급' : '기본'} 가비지 컬렉션 요청`);\r\n  \r\n  // 네이티브 GC 함수 호출 시도\r\n  if (window.gc) {\r\n    try {\r\n      console.log('[GC] 네이티브 GC 함수 호출 시도');\r\n      window.gc();\r\n      console.log('[GC] 네이티브 GC 성공');\r\n      \r\n      return {\r\n        success: true,\r\n        freedMemory: 0, // 실제 해제된 메모리는 알 수 없음\r\n        freedMB: 0,\r\n        duration: 0,\r\n        timestamp: Date.now()\r\n      };\r\n    } catch (error) {\r\n      console.error('[GC] 네이티브 GC 함수 호출 실패:', error);\r\n    }\r\n  }\r\n  \r\n  // GC를 유도하기 위한 대안 방법\r\n  try {\r\n    const memoryBefore = await ensureMemoryInfo();\r\n    \r\n    // 마지막 GC 이후 최소 간격 확인\r\n    const now = Date.now();\r\n    if (now - lastGCTime < MIN_GC_INTERVAL && !emergency) {\r\n      console.warn(`[GC] 최소 간격(${MIN_GC_INTERVAL}ms) 내에 GC 요청, 생략됨`);\r\n      return {\r\n        success: false,\r\n        freedMemory: 0,\r\n        freedMB: 0,\r\n        duration: 0,\r\n        timestamp: now,\r\n        error: '최소 GC 간격 내에 요청됨'\r\n      };\r\n    }\r\n    \r\n    console.log('[GC] 대체 GC 전략 시도');\r\n    const startTime = performance.now();\r\n    \r\n    // 대규모 임시 메모리 할당 후 해제 (GC 유도)\r\n    const size = emergency ? 100 * 1024 * 1024 : 10 * 1024 * 1024; // 100MB or 10MB\r\n    const tempArrays = [];\r\n    \r\n    // 여러 개의 큰 배열 생성\r\n    const arrayCount = emergency ? 5 : 2;\r\n    for (let i = 0; i < arrayCount; i++) {\r\n      tempArrays.push(new Array(size).fill(0));\r\n    }\r\n    \r\n    // 배열 해제\r\n    tempArrays.length = 0;\r\n    \r\n    // 추가 GC 유도\r\n    if (emergency) {\r\n      // 추가 임시 객체 생성 및 해제\r\n      for (let i = 0; i < 10; i++) {\r\n        const tempObj = {};\r\n        for (let j = 0; j < 1000; j++) {\r\n          (tempObj as any)[`key_${j}`] = new Array(1000).fill(j);\r\n        }\r\n      }\r\n    }\r\n    \r\n    const endTime = performance.now();\r\n    const duration = endTime - startTime;\r\n    \r\n    // 메모리 상태 다시 확인\r\n    const memoryAfter = await ensureMemoryInfo();\r\n    \r\n    // 해제된 메모리 계산\r\n    const freedMemory = Math.max(0, memoryBefore.heap_used - memoryAfter.heap_used);\r\n    const freedMB = freedMemory / (1024 * 1024);\r\n    \r\n    // GC 시간 업데이트\r\n    lastGCTime = now;\r\n    \r\n    console.log(`[GC] 메모리 해제됨: ${freedMB.toFixed(2)}MB, 소요시간: ${duration.toFixed(2)}ms`);\r\n    \r\n    return {\r\n      success: true,\r\n      freedMemory: freedMemory,\r\n      freedMB: freedMB,\r\n      duration,\r\n      timestamp: now\r\n    };\r\n  } catch (error) {\r\n    console.error('[GC] 대체 GC 전략 실패:', error);\r\n    return {\r\n      success: false,\r\n      freedMemory: 0,\r\n      freedMB: 0,\r\n      duration: 0,\r\n      timestamp: Date.now(),\r\n      error: error instanceof Error ? error.message : String(error)\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * GC 수행 횟수 및 마지막 GC 시간 조회 함수\r\n */\r\nexport function getGCStats() {\r\n  return {\r\n    lastGCTime,\r\n    totalGCCalls: 0 // 실제 구현에서는 카운터 추가\r\n  };\r\n}\r\n\r\n/**\r\n * 마지막 GC 시간 조회\r\n */\r\nexport function getLastGCTime(): number {\r\n  return lastGCTime;\r\n}\r\n\r\n/**\r\n * 총 GC 수행 횟수 조회\r\n */\r\nexport function getTotalGCCount(): number {\r\n  return 0; // 실제 구현에서는 카운터 추가\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\gc\\gc-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\gc\\optimization-controller.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":45,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":45,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":56,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":56,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":61,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":61,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":69,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":69,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":80,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":80,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":82,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":82,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":90,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":90,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":101,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":101,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":103,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":103,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":104,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":104,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":109,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":109,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":114,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":114,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":125,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":125,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":129,"column":36,"nodeType":"Identifier","messageId":"undef","endLine":129,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":130,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":130,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":140,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":140,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":151,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":151,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":151,"column":53,"nodeType":"Identifier","messageId":"undef","endLine":151,"endColumn":59},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":152,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":152,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'cancelAnimationFrame' is not defined.","line":153,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":153,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":155,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":155,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":160,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":160,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":171,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":171,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":171,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":171,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":174,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":174,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":180,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":180,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":187,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":187,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":193,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":193,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":221,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":221,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":228,"column":8,"nodeType":"Identifier","messageId":"undef","endLine":228,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":229,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":229,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":233,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":233,"endColumn":9},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":234,"column":8,"nodeType":"Identifier","messageId":"undef","endLine":234,"endColumn":14}],"suppressedMessages":[],"errorCount":33,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 메모리 최적화 컨트롤러\r\n * \r\n * 이 모듈은 네이티브 모듈을 통해 다양한 수준의 메모리 최적화를 제공합니다.\r\n * 모든 실제 최적화 로직은 Rust 네이티브 모듈에서 처리됩니다.\r\n */\r\n\r\nimport { OptimizationLevel } from '@/types';\r\nimport { OptimizationResult } from '@/types';\r\nimport { requestNativeMemoryOptimization, requestNativeGarbageCollection } from '../../native-memory-bridge';\r\n\r\n// 네이티브 모듈을 사용하여 기본 최적화 수행\r\nexport async function performBasicOptimization(): Promise<OptimizationResult> {\r\n  return requestNativeMemoryOptimization(0, false) as Promise<OptimizationResult>;\r\n}\r\n\r\n// 네이티브 모듈을 사용하여 중간 수준 최적화 수행\r\nexport async function performMediumOptimization(): Promise<OptimizationResult> {\r\n  return requestNativeMemoryOptimization(OptimizationLevel.MEDIUM, false) as Promise<OptimizationResult>;\r\n}\r\n\r\n// 네이티브 모듈을 사용하여 높은 수준 최적화 수행\r\nexport async function performHighOptimization(): Promise<OptimizationResult> {\r\n  return requestNativeMemoryOptimization(OptimizationLevel.HIGH, false) as Promise<OptimizationResult>;\r\n}\r\n\r\n// 네이티브 모듈을 사용하여 위험 수준 최적화 수행\r\nexport async function performCriticalOptimization(): Promise<OptimizationResult> {\r\n  return requestNativeMemoryOptimization(OptimizationLevel.EXTREME, true) as Promise<OptimizationResult>;\r\n}\r\n\r\n// 최적화 수준별 작업\r\nexport async function performOptimizationByLevel(level: OptimizationLevel): Promise<OptimizationResult> {\r\n  return requestNativeMemoryOptimization(level, level === OptimizationLevel.EXTREME) as Promise<OptimizationResult>;\r\n}\r\n\r\n// 메모리 최적화 단계를 간략화한 버전\r\nexport async function optimizeMemoryByLevel(level: 0 | 1 | 2 | 3 | 4): Promise<boolean> {\r\n  try {\r\n    // 최적화 수준에 따라 다른 동작 수행\r\n    const optimizationLevel = level as OptimizationLevel;\r\n    await requestNativeMemoryOptimization(optimizationLevel, level === 4);\r\n    return true;\r\n  } catch (error) {\r\n    console.error(`메모리 최적화 실패 (레벨 ${level}):`, error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// 이미지 및 미디어 캐시 정리\r\nexport async function clearImageCaches(): Promise<boolean> {\r\n  try {\r\n    if (typeof window === 'undefined') return false;\r\n    \r\n    // 이미지 요소 재로드\r\n    const images = document.querySelectorAll('img');\r\n    images.forEach(img => {\r\n      if (img.src && !img.src.startsWith('data:')) {\r\n        const currentSrc = img.src;\r\n        img.src = '';\r\n        setTimeout(() => {\r\n          img.src = currentSrc;\r\n        }, 10);\r\n      }\r\n    });\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('이미지 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// DOM 요소 참조 정리\r\nexport async function cleanupDOMReferences(): Promise<boolean> {\r\n  try {\r\n    if (typeof window === 'undefined') return false;\r\n    \r\n    // 숨겨진 요소에 연결된 이벤트 정리\r\n    const hiddenElements = document.querySelectorAll('.hidden, [hidden], [style*=\"display: none\"]');\r\n    hiddenElements.forEach(element => {\r\n      if (element instanceof HTMLElement) {\r\n        // Element에 연결된 모든 속성 정리\r\n        element.innerHTML = '';\r\n      }\r\n    });\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('DOM 참조 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// 브라우저 스토리지 캐시 정리\r\nexport async function clearStorageCaches(): Promise<boolean> {\r\n  try {\r\n    if (typeof window === 'undefined') return false;\r\n    \r\n    // 세션 스토리지에서 캐시 키 정리\r\n    if (window.sessionStorage) {\r\n      const keysToRemove = [];\r\n      for (let i = 0; i < sessionStorage.length; i++) {\r\n        const key = sessionStorage.key(i);\r\n        if (key && (key.includes('cache') || key.includes('temp'))) {\r\n          keysToRemove.push(key);\r\n        }\r\n      }\r\n      keysToRemove.forEach(key => sessionStorage.removeItem(key));\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('스토리지 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// 비표시 요소 리소스 해제\r\nexport async function unloadNonVisibleResources(): Promise<boolean> {\r\n  try {\r\n    if (typeof window === 'undefined') return false;\r\n    \r\n    // 화면 밖에 있는 이미지 unload\r\n    const images = document.querySelectorAll('img');\r\n    \r\n    images.forEach(img => {\r\n      const rect = img.getBoundingClientRect();\r\n      const isVisible = rect.top < window.innerHeight && rect.bottom > 0 &&\r\n                         rect.left < window.innerWidth && rect.right > 0;\r\n      \r\n      if (!isVisible && img.src && !img.dataset.keepLoaded) {\r\n        img.dataset.originalSrc = img.src;\r\n        img.src = '';\r\n      }\r\n    });\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('비표시 리소스 해제 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// 이벤트 리스너 최적화\r\nexport async function optimizeEventListeners(): Promise<boolean> {\r\n  try {\r\n    if (typeof window === 'undefined') return false;\r\n    \r\n    // 전역 이벤트 리스너 정리 (애플리케이션 코드에서 관리하지 않는 것들)\r\n    if (window.__animationFrameIds && Array.isArray(window.__animationFrameIds)) {\r\n      for (const id of window.__animationFrameIds) {\r\n        cancelAnimationFrame(id);\r\n      }\r\n      window.__animationFrameIds = [];\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('이벤트 리스너 최적화 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// 동적 모듈 해제\r\nexport async function unloadDynamicModules(): Promise<boolean> {\r\n  try {\r\n    if (typeof window === 'undefined') return false;\r\n    \r\n    // 애플리케이션이 관리하는 사용자 정의 모듈 언로드\r\n    if (window.__loadedModules && window.__loadedModules instanceof Map) {\r\n      const modulesToUnload: string[] = [];\r\n      \r\n      window.__loadedModules.forEach((module, key) => {\r\n        if (module && typeof module.unload === 'function') {\r\n          try {\r\n            module.unload();\r\n            modulesToUnload.push(key);\r\n          } catch (err) {\r\n            console.warn(`모듈 언로드 오류 (${key}):`, err);\r\n          }\r\n        }\r\n      });\r\n      \r\n      // 언로드된 모듈 삭제\r\n      modulesToUnload.forEach(key => {\r\n        window.__loadedModules?.delete(key);\r\n      });\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('동적 모듈 해제 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// 긴급 메모리 복구\r\nexport async function emergencyMemoryRecovery(): Promise<boolean> {\r\n  try {\r\n    if (typeof window === 'undefined') return false;\r\n    \r\n    // 모든 최적화 함수 호출\r\n    await Promise.all([\r\n      clearImageCaches(),\r\n      cleanupDOMReferences(), \r\n      clearStorageCaches(),\r\n      unloadNonVisibleResources(),\r\n      optimizeEventListeners(),\r\n      unloadDynamicModules()\r\n    ]);\r\n    \r\n    // 네이티브 모듈에 긴급 최적화 요청\r\n    await requestNativeMemoryOptimization(OptimizationLevel.EXTREME, true);\r\n    \r\n    // 브라우저 GC 요청\r\n    await requestNativeGarbageCollection();\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('긴급 메모리 복구 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// 전역 API에 최적화 함수 등록\r\nif (typeof window !== 'undefined') {\r\n  if (!window.__memoryOptimizer) {\r\n    window.__memoryOptimizer = {};\r\n  }\r\n  \r\n  // 기존에 정의된 함수가 있다면 유지, 없다면 새로 추가\r\n  window.__memoryOptimizer = {\r\n    ...window.__memoryOptimizer,\r\n    performBasicOptimization,\r\n    performMediumOptimization,\r\n    performHighOptimization,\r\n    performCriticalOptimization,\r\n    performOptimizationByLevel,\r\n    emergencyMemoryRecovery\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\gc\\optimization-levels.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":18,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":18,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":30,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":30,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":42,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":42,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":54,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":54,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":136,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":136,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":136,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":136,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3283,3304],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":141,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":141,"endColumn":12}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 최적화 수준별 구현\r\n * Rust 네이티브 모듈을 호출하는 래퍼 함수들\r\n */\r\nimport { requestNativeMemoryOptimization } from '@/app/utils/native-memory-bridge';\r\nimport { OptimizationLevel } from '@/types/native-module';\r\nimport { getMemoryInfo } from '../memory-info';\r\nimport { logMemoryUsage, MemoryEventType } from '../logger';\r\n\r\n/**\r\n * 가벼운 수준의 메모리 최적화 수행\r\n * Rust 네이티브 모듈을 통해 처리\r\n */\r\nexport async function lightOptimization(): Promise<void> {\r\n  try {\r\n    await requestNativeMemoryOptimization(OptimizationLevel.Low, false);\r\n  } catch (error) {\r\n    console.error('가벼운 메모리 최적화 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 중간 수준의 메모리 최적화 수행\r\n * Rust 네이티브 모듈을 통해 처리\r\n */\r\nexport async function mediumOptimization(): Promise<void> {\r\n  try {\r\n    await requestNativeMemoryOptimization(OptimizationLevel.Medium, false);\r\n  } catch (error) {\r\n    console.error('중간 수준 메모리 최적화 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 높은 수준의 메모리 최적화 수행\r\n * Rust 네이티브 모듈을 통해 처리\r\n */\r\nexport async function highOptimization(): Promise<void> {\r\n  try {\r\n    await requestNativeMemoryOptimization(OptimizationLevel.High, false);\r\n  } catch (error) {\r\n    console.error('높은 수준 메모리 최적화 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 적극적인 메모리 최적화 수행\r\n * Rust 네이티브 모듈을 통해 처리\r\n */\r\nexport async function aggressiveOptimization(): Promise<void> {\r\n  try {\r\n    await requestNativeMemoryOptimization(OptimizationLevel.Critical, true);\r\n  } catch (error) {\r\n    console.error('적극적인 메모리 최적화 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 최적화 레벨 관리 및 보고\r\n */\r\n\r\n// 최적화 레벨 설명\r\nexport const OPTIMIZATION_LEVEL_DESCRIPTIONS = {\r\n  0: \"최적화 없음 - 기본 상태 유지\",\r\n  1: \"낮은 수준 최적화 - 비필수 캐시 정리\",\r\n  2: \"중간 수준 최적화 - 사용하지 않는 리소스 정리\",\r\n  3: \"높은 수준 최적화 - 적극적인 메모리 회수\",\r\n  4: \"긴급 최적화 - 모든 비필수 리소스 해제\"\r\n};\r\n\r\n// 레벨별 임계값 (메모리 사용률 %)\r\nexport const OPTIMIZATION_THRESHOLDS = {\r\n  LEVEL_0: 50,  // 50% 미만\r\n  LEVEL_1: 70,  // 50-70%\r\n  LEVEL_2: 80,  // 70-80%\r\n  LEVEL_3: 90,  // 80-90%\r\n  LEVEL_4: 95   // 90% 이상 (위험)\r\n};\r\n\r\n// 최적화 히스토리\r\nconst optimizationHistory: Array<{\r\n  timestamp: number;\r\n  level: number;\r\n  memoryBefore: number;\r\n  memoryAfter: number;\r\n}> = [];\r\n\r\n/**\r\n * 현재 메모리 상태에 따른 최적화 레벨 추천\r\n */\r\nexport async function recommendOptimizationLevel(): Promise<number> {\r\n  const memoryInfo = await getMemoryInfo();\r\n  \r\n  if (!memoryInfo) {\r\n    return 0; // 정보를 얻을 수 없는 경우 기본값\r\n  }\r\n  \r\n  const memoryUsagePercent = memoryInfo.percentUsed || 0;\r\n  \r\n  if (memoryUsagePercent > OPTIMIZATION_THRESHOLDS.LEVEL_4) {\r\n    return 4;\r\n  } else if (memoryUsagePercent > OPTIMIZATION_THRESHOLDS.LEVEL_3) {\r\n    return 3;\r\n  } else if (memoryUsagePercent > OPTIMIZATION_THRESHOLDS.LEVEL_2) {\r\n    return 2;\r\n  } else if (memoryUsagePercent > OPTIMIZATION_THRESHOLDS.LEVEL_1) {\r\n    return 1;\r\n  }\r\n  \r\n  return 0;\r\n}\r\n\r\n/**\r\n * 최적화 후 메모리 사용량 보고\r\n */\r\nexport async function reportMemoryUsage(level: number): Promise<void> {\r\n  try {\r\n    const memoryInfo = await getMemoryInfo();\r\n    \r\n    if (!memoryInfo) {\r\n      return;\r\n    }\r\n    \r\n    const heapUsedMB = memoryInfo.heapUsedMB || 0;\r\n    const percentUsed = memoryInfo.percentUsed || 0;\r\n    \r\n    const message = `메모리 최적화 (레벨 ${level}) 완료: ${heapUsedMB.toFixed(2)}MB (${percentUsed.toFixed(1)}%)`;\r\n    \r\n    // 로그 기록\r\n    await logMemoryUsage(\r\n      MemoryEventType.OPTIMIZATION,\r\n      message\r\n    );\r\n    \r\n    // 콘솔 로깅\r\n    console.log(message);\r\n    \r\n    // 내역 저장\r\n    recordOptimization(level, heapUsedMB);\r\n  } catch (error) {\r\n    console.error('메모리 사용량 보고 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 최적화 내역 기록\r\n */\r\nfunction recordOptimization(level: number, currentMemory: number): void {\r\n  const lastEntry = optimizationHistory[optimizationHistory.length - 1];\r\n  \r\n  optimizationHistory.push({\r\n    timestamp: Date.now(),\r\n    level,\r\n    memoryBefore: lastEntry?.memoryAfter || currentMemory,\r\n    memoryAfter: currentMemory\r\n  });\r\n  \r\n  // 최대 100개 항목 유지\r\n  if (optimizationHistory.length > 100) {\r\n    optimizationHistory.shift();\r\n  }\r\n}\r\n\r\n/**\r\n * 최적화 내역 가져오기\r\n */\r\nexport function getOptimizationHistory() {\r\n  return [...optimizationHistory];\r\n}\r\n\r\n/**\r\n * 특정 최적화 레벨에 필요한 작업 설명\r\n */\r\nexport function getOptimizationActions(level: number): string[] {\r\n  switch (level) {\r\n    case 0:\r\n      return [\r\n        \"기본 상태 유지\",\r\n        \"일반적인 가비지 컬렉션 허용\"\r\n      ];\r\n    case 1:\r\n      return [\r\n        \"비필수 캐시 정리\",\r\n        \"사용하지 않는 이미지 언로드\",\r\n        \"비활성 이벤트 리스너 정리\"\r\n      ];\r\n    case 2:\r\n      return [\r\n        \"모든 레벨 1 작업 포함\",\r\n        \"DOM 참조 정리\",\r\n        \"비표시 요소 정리\",\r\n        \"메모리 풀 최적화\"\r\n      ];\r\n    case 3:\r\n      return [\r\n        \"모든 레벨 2 작업 포함\",\r\n        \"애니메이션 및 타이머 일시 중지\",\r\n        \"대용량 객체 참조 해제\",\r\n        \"인메모리 캐시 축소\"\r\n      ];\r\n    case 4:\r\n      return [\r\n        \"모든 레벨 3 작업 포함\",\r\n        \"비필수 모듈 언로드\",\r\n        \"GPU 가속화 비활성화\",\r\n        \"백그라운드 작업 중지\",\r\n        \"인메모리 DB 압축\"\r\n      ];\r\n    default:\r\n      return [\"알 수 없는 최적화 레벨\"];\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\gc\\optimization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\gc\\resource-optimizer.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":62,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":62,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":62,"column":65,"nodeType":"Identifier","messageId":"undef","endLine":62,"endColumn":81},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":92,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":92,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":99,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":99,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":132,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":132,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":162,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":162,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":199,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":199,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":250,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":250,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":260,"column":36,"nodeType":"Identifier","messageId":"undef","endLine":260,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":279,"column":63,"nodeType":"Identifier","messageId":"undef","endLine":279,"endColumn":74},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":285,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":285,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'Element' is not defined.","line":287,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":287,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":289,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":289,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":299,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":299,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'Text' is not defined.","line":306,"column":48,"nodeType":"Identifier","messageId":"undef","endLine":306,"endColumn":52},{"ruleId":"no-undef","severity":2,"message":"'Text' is not defined.","line":312,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":312,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Node' is not defined.","line":314,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":314,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'Node' is not defined.","line":315,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":315,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'Text' is not defined.","line":316,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":316,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":327,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":327,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'Element' is not defined.","line":334,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":334,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'Element' is not defined.","line":340,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":340,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":341,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":341,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":347,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":347,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":347,"column":61,"nodeType":"Identifier","messageId":"undef","endLine":347,"endColumn":67},{"ruleId":"no-unused-vars","severity":2,"message":"'rootElement' is defined but never used.","line":358,"column":41,"nodeType":"Identifier","messageId":"unusedVar","endLine":358,"endColumn":65},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'rootElement' is defined but never used. Allowed unused args must match /^_/u.","line":358,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":358,"endColumn":52},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":358,"column":54,"nodeType":"Identifier","messageId":"undef","endLine":358,"endColumn":65},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":379,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":379,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":416,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":416,"endColumn":28},{"ruleId":"no-unused-vars","severity":2,"message":"'classArray' is assigned a value but never used.","line":422,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":422,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'classArray' is assigned a value but never used.","line":422,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":422,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":444,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":444,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":447,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":447,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":455,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":455,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":458,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":458,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":466,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":466,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":469,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":469,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":495,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":495,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":524,"column":6,"nodeType":"Identifier","messageId":"undef","endLine":524,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":545,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":545,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":607,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":607,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'HTMLCanvasElement' is not defined.","line":611,"column":39,"nodeType":"Identifier","messageId":"undef","endLine":611,"endColumn":56}],"suppressedMessages":[],"errorCount":41,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 리소스 최적화 모듈\r\n * \r\n * 메모리 사용량을 줄이기 위한 다양한 리소스 최적화 기능을 제공합니다.\r\n */\r\n\r\nimport { logger } from '../logger';\r\n\r\n// 최적화 상태 추적용 카운터\r\nlet optimizationCount = 0;\r\nlet lastOptimizationTime = 0;\r\nlet totalFreedMemoryBytes = 0;\r\n\r\n/**\r\n * 브라우저 캐시 정리\r\n * 브라우저 환경에서 캐시를 정리하여 메모리를 확보\r\n */\r\nexport function clearBrowserCaches(): boolean {\r\n  try {\r\n    // 브라우저 환경 체크\r\n    if (typeof window === 'undefined') {\r\n      return false;\r\n    }\r\n\r\n    // 캐시된 이미지 정리\r\n    clearImageCache();\r\n    \r\n    // Object URL 정리\r\n    clearObjectURLs();\r\n    \r\n    // 메모리 캐시 정리\r\n    clearMemoryCache();\r\n    \r\n    // 스타일 캐시 정리\r\n    clearStyleCache();\r\n    \r\n    // 위젯 캐시 정리\r\n    clearWidgetCache();\r\n    \r\n    // 정리 후 측정 시간 업데이트\r\n    lastOptimizationTime = Date.now();\r\n    optimizationCount++;\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    logger.error('[Resource Optimizer] Failed to clear browser caches:', error as Record<string, unknown> | undefined);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 이미지 캐시 정리\r\n */\r\nexport function clearImageCache(): boolean {\r\n  try {\r\n    // 브라우저 환경 체크\r\n    if (typeof window === 'undefined') {\r\n      return false;\r\n    }\r\n    \r\n    // 글로벌 이미지 리사이즈 캐시 정리\r\n    const imageCache = window.__imageResizeCache as Map<string, HTMLImageElement> | undefined;\r\n    \r\n    if (imageCache && typeof imageCache.clear === 'function') {\r\n      const cacheSize = imageCache.size;\r\n      imageCache.clear();\r\n      logger.info(`[Resource Optimizer] Cleared ${cacheSize} cached images`);\r\n      \r\n      // 통계 업데이트 - 이미지당 약 100KB로 추정\r\n      totalFreedMemoryBytes += cacheSize * 100 * 1024;\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  } catch (error) {\r\n    logger.error('[Resource Optimizer] Failed to clear image cache:', error as Record<string, unknown> | undefined);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Object URL 정리\r\n */\r\nexport function clearObjectURLs(): boolean {\r\n  try {\r\n    // 브라우저 환경 체크\r\n    if (typeof window === 'undefined' || typeof URL === 'undefined') {\r\n      return false;\r\n    }\r\n    \r\n    // 글로벌 Object URL 캐시 정리\r\n    const urlCache = window.__objectUrls as Map<string, string> | undefined;\r\n    \r\n    if (urlCache && typeof urlCache.forEach === 'function') {\r\n      let count = 0;\r\n      \r\n      urlCache.forEach((url) => {\r\n        try {\r\n          URL.revokeObjectURL(url);\r\n          count++;\r\n        } catch (e) {\r\n          // URL 해제 실패는 무시\r\n        }\r\n      });\r\n      \r\n      urlCache.clear();\r\n      logger.info(`[Resource Optimizer] Revoked ${count} object URLs`);\r\n      \r\n      // 통계 업데이트 - URL당 약 50KB로 추정\r\n      totalFreedMemoryBytes += count * 50 * 1024;\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  } catch (error) {\r\n    logger.error('[Resource Optimizer] Failed to clear object URLs:', error as Record<string, unknown> | undefined);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 캐시 정리\r\n */\r\nexport function clearMemoryCache(): boolean {\r\n  try {\r\n    // 브라우저 환경 체크\r\n    if (typeof window === 'undefined') {\r\n      return false;\r\n    }\r\n    \r\n    // 글로벌 메모리 캐시 정리\r\n    const memoryCache = window.__memoryCache as Map<string, any> | undefined;\r\n    \r\n    if (memoryCache && typeof memoryCache.clear === 'function') {\r\n      const cacheSize = memoryCache.size;\r\n      memoryCache.clear();\r\n      logger.info(`[Resource Optimizer] Cleared memory cache with ${cacheSize} items`);\r\n      \r\n      // 통계 업데이트 - 항목당 약 20KB로 추정\r\n      totalFreedMemoryBytes += cacheSize * 20 * 1024;\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  } catch (error) {\r\n    logger.error('[Resource Optimizer] Failed to clear memory cache:', error as Record<string, unknown> | undefined);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 스타일 캐시 정리\r\n */\r\nexport function clearStyleCache(): boolean {\r\n  try {\r\n    // 브라우저 환경 체크\r\n    if (typeof window === 'undefined') {\r\n      return false;\r\n    }\r\n    \r\n    // 글로벌 스타일 캐시 정리\r\n    const styleCache = window.__styleCache as Record<string, any> | undefined;\r\n    \r\n    if (styleCache) {\r\n      let count = 0;\r\n      \r\n      for (const key in styleCache) {\r\n        if (Object.prototype.hasOwnProperty.call(styleCache, key)) {\r\n          delete styleCache[key];\r\n          count++;\r\n        }\r\n      }\r\n      \r\n      logger.info(`[Resource Optimizer] Cleared style cache with ${count} items`);\r\n      \r\n      // 통계 업데이트 - 스타일당 약 5KB로 추정\r\n      totalFreedMemoryBytes += count * 5 * 1024;\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  } catch (error) {\r\n    logger.error('[Resource Optimizer] Failed to clear style cache:', error as Record<string, unknown> | undefined);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 위젯 캐시 정리\r\n */\r\nexport function clearWidgetCache(): boolean {\r\n  try {\r\n    // 브라우저 환경 체크\r\n    if (typeof window === 'undefined') {\r\n      return false;\r\n    }\r\n    \r\n    // 글로벌 위젯 캐시 정리\r\n    const widgetCache = window.__widgetCache as Map<string, any> | undefined;\r\n    \r\n    if (widgetCache && typeof widgetCache.clear === 'function') {\r\n      const cacheSize = widgetCache.size;\r\n      widgetCache.clear();\r\n      logger.info(`[Resource Optimizer] Cleared widget cache with ${cacheSize} items`);\r\n      \r\n      // 통계 업데이트 - 위젯당 약 30KB로 추정\r\n      totalFreedMemoryBytes += cacheSize * 30 * 1024;\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  } catch (error) {\r\n    logger.error('[Resource Optimizer] Failed to clear widget cache:', error as Record<string, unknown> | undefined);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * DOM 최적화\r\n * DOM 구조 최적화 및 메모리 누수 방지\r\n */\r\nexport function optimizeDOM(): boolean {\r\n  try {\r\n    // 브라우저 환경 체크\r\n    if (typeof window === 'undefined' || typeof document === 'undefined') {\r\n      return false;\r\n    }\r\n    \r\n    let optimizedCount = 0;\r\n    \r\n    // 과도하게 깊은 DOM 깊이를 가진 요소 검사\r\n    const deepElements = findDeepDOMElements('div');\r\n    if (deepElements.length > 0) {\r\n      logger.warn(`[Resource Optimizer] Found ${deepElements.length} excessively deep DOM structures`);\r\n    }\r\n    \r\n    // 큰 DOM 노드 최적화\r\n    const textNodes = findLargeTextNodes();\r\n    textNodes.forEach(node => {\r\n      // 텍스트 노드가 너무 큰 경우 잘라내기\r\n      if (node.textContent && node.textContent.length > 5000) {\r\n        node.textContent = node.textContent.substring(0, 5000) + '...';\r\n        optimizedCount++;\r\n      }\r\n    });\r\n    \r\n    // 뷰포트 밖 DOM 요소 최적화\r\n    const offscreenElements = findOffscreenElements();\r\n    offscreenElements.forEach(el => {\r\n      if (el instanceof HTMLElement) {\r\n        // 데이터 속성에 원래 display 스타일 저장\r\n        el.dataset.originalDisplay = el.style.display || '';\r\n        // 화면 밖 요소 감추기\r\n        el.style.display = 'none';\r\n        optimizedCount++;\r\n      }\r\n    });\r\n    \r\n    // 깊은 이벤트 리스너 정리\r\n    cleanupDuplicateEventListeners(document.body);\r\n    \r\n    // 다양한 DOM 최적화 기법 적용\r\n    removeEmptyNodes();\r\n    mergeAdjacentTextNodes();\r\n    \r\n    // CSS 클래스 최적화 (너무 많은 클래스를 가진 요소)\r\n    optimizeCSSClasses();\r\n    \r\n    return optimizedCount > 0;\r\n  } catch (error) {\r\n    logger.error('[Resource Optimizer] DOM optimization error:', error as Record<string, unknown> | undefined);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 특정 태그의 깊은 DOM 요소 찾기\r\n */\r\nfunction findDeepDOMElements(tagName: string, maxDepth = 15): HTMLElement[] {\r\n  // DOM이 없는 환경 처리\r\n  if (typeof document === 'undefined') {\r\n    return [];\r\n  }\r\n  \r\n  const results: HTMLElement[] = [];\r\n  \r\n  function checkDepth(element: Element, depth = 0) {\r\n    if (depth > maxDepth && element.tagName.toLowerCase() === tagName.toLowerCase()) {\r\n      if (element instanceof HTMLElement) {\r\n        results.push(element);\r\n      }\r\n    }\r\n    \r\n    for (let i = 0; i < element.children.length; i++) {\r\n      checkDepth(element.children[i], depth + 1);\r\n    }\r\n  }\r\n  \r\n  checkDepth(document.body);\r\n  return results;\r\n}\r\n\r\n/**\r\n * 큰 텍스트 노드 찾기 \r\n */\r\nfunction findLargeTextNodes(minLength = 3000): Text[] {\r\n  // DOM이 없는 환경 처리\r\n  if (typeof document === 'undefined') {\r\n    return [];\r\n  }\r\n  \r\n  const textNodes: Text[] = [];\r\n  \r\n  function findTextNodes(node: Node) {\r\n    if (node.nodeType === Node.TEXT_NODE) {\r\n      const textNode = node as Text;\r\n      if (textNode.textContent && textNode.textContent.length > minLength) {\r\n        textNodes.push(textNode);\r\n      }\r\n    } else {\r\n      for (let i = 0; i < node.childNodes.length; i++) {\r\n        findTextNodes(node.childNodes[i]);\r\n      }\r\n    }\r\n  }\r\n  \r\n  findTextNodes(document.body);\r\n  return textNodes;\r\n}\r\n\r\n/**\r\n * 화면 밖 요소 찾기\r\n */\r\nfunction findOffscreenElements(): Element[] {\r\n  // DOM이 없는 환경 처리\r\n  if (typeof document === 'undefined' || typeof window === 'undefined') {\r\n    return [];\r\n  }\r\n  \r\n  const elements: Element[] = [];\r\n  const allElements = document.querySelectorAll('*');\r\n  \r\n  allElements.forEach(el => {\r\n    const rect = el.getBoundingClientRect();\r\n    \r\n    // 요소가 화면 밖에 있는지 확인 (위쪽으로 -200%, 아래쪽으로 200% 이상)\r\n    if (rect.bottom < -window.innerHeight * 2 || rect.top > window.innerHeight * 3) {\r\n      elements.push(el);\r\n    }\r\n  });\r\n  \r\n  return elements;\r\n}\r\n\r\n/**\r\n * 중복 이벤트 리스너 정리\r\n */\r\nfunction cleanupDuplicateEventListeners(rootElement: HTMLElement): void {\r\n  // DOM이 없는 환경 처리\r\n  if (typeof document === 'undefined') {\r\n    return;\r\n  }\r\n  \r\n  // 이 함수는 가상이며, 실제로는 구현이 어렵습니다\r\n  // 브라우저에서 이벤트 리스너를 직접 검사하는 API가 제한적입니다\r\n  logger.debug('[Resource Optimizer] Duplicate event listeners cleanup simulation');\r\n}\r\n\r\n/**\r\n * 빈 노드 제거\r\n */\r\nfunction removeEmptyNodes(): void {\r\n  // DOM이 없는 환경 처리\r\n  if (typeof document === 'undefined') {\r\n    return;\r\n  }\r\n  \r\n  // 실제 구현을 위한 골격\r\n  const emptyDivs = document.querySelectorAll('div:empty');\r\n  let removed = 0;\r\n  \r\n  emptyDivs.forEach(div => {\r\n    if (div.parentNode && !div.hasAttribute('data-keep-empty')) {\r\n      div.parentNode.removeChild(div);\r\n      removed++;\r\n    }\r\n  });\r\n  \r\n  logger.debug(`[Resource Optimizer] Removed ${removed} empty nodes`);\r\n}\r\n\r\n/**\r\n * 인접한 텍스트 노드 병합\r\n */\r\nfunction mergeAdjacentTextNodes(): void {\r\n  // DOM이 없는 환경 처리\r\n  if (typeof document === 'undefined') {\r\n    return;\r\n  }\r\n  \r\n  // 실제 구현을 위한 골격\r\n  // 텍스트 노드 병합은 DOM 순회가 필요합니다\r\n  logger.debug('[Resource Optimizer] Text nodes merging simulation');\r\n}\r\n\r\n/**\r\n * CSS 클래스 최적화\r\n */\r\nfunction optimizeCSSClasses(): void {\r\n  // DOM이 없는 환경 처리\r\n  if (typeof document === 'undefined') {\r\n    return;\r\n  }\r\n  \r\n  // 너무 많은 클래스를 가진 요소 찾기\r\n  const elements = document.querySelectorAll('*');\r\n  let optimized = 0;\r\n  \r\n  elements.forEach(el => {\r\n    if (el.classList && el.classList.length > 10) {\r\n      // 사용하지 않는 클래스 정리 (데모 용도)\r\n      const classArray = Array.from(el.classList);\r\n      // 실제로는 어떤 클래스가 사용되지 않는지 판단하기 어려움\r\n      // 여기서는 시뮬레이션만 실행\r\n      optimized++;\r\n    }\r\n  });\r\n  \r\n  logger.debug(`[Resource Optimizer] Optimized classes for ${optimized} elements`);\r\n}\r\n\r\n/**\r\n * 타이머 정리\r\n * 비활성 타이머 및 Animation Frame 제거\r\n */\r\nexport function cleanupTimers(): boolean {\r\n  try {\r\n    // 브라우저 환경 체크\r\n    if (typeof window === 'undefined') {\r\n      return false;\r\n    }\r\n    \r\n    // Animation frame IDs 정리\r\n    const frameIds = window.__animationFrameIds as number[] | undefined;\r\n    if (Array.isArray(frameIds) && frameIds.length > 0) {\r\n      frameIds.forEach(id => {\r\n        window.cancelAnimationFrame(id);\r\n      });\r\n      \r\n      logger.info(`[Resource Optimizer] Canceled ${frameIds.length} animation frames`);\r\n      frameIds.length = 0;\r\n    }\r\n    \r\n    // Interval IDs 정리\r\n    const intervalIds = window.__intervalIds as number[] | undefined;\r\n    if (Array.isArray(intervalIds) && intervalIds.length > 0) {\r\n      intervalIds.forEach(id => {\r\n        window.clearInterval(id);\r\n      });\r\n      \r\n      logger.info(`[Resource Optimizer] Cleared ${intervalIds.length} intervals`);\r\n      intervalIds.length = 0;\r\n    }\r\n    \r\n    // Timeout IDs 정리\r\n    const timeoutIds = window.__timeoutIds as number[] | undefined;\r\n    if (Array.isArray(timeoutIds) && timeoutIds.length > 0) {\r\n      timeoutIds.forEach(id => {\r\n        window.clearTimeout(id);\r\n      });\r\n      \r\n      logger.info(`[Resource Optimizer] Cleared ${timeoutIds.length} timeouts`);\r\n      timeoutIds.length = 0;\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    logger.error('[Resource Optimizer] Failed to cleanup timers:', error as Record<string, unknown> | undefined);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 웹 워커 정리\r\n * 필요 없는 워커 종료\r\n */\r\nexport function terminateUnusedWorkers(): boolean {\r\n  try {\r\n    // 브라우저 환경 체크\r\n    if (typeof window === 'undefined') {\r\n      return false;\r\n    }\r\n    \r\n    // 글로벌 웹 워커 관리 객체\r\n    const workers = (window as any).__webWorkers;\r\n    if (!Array.isArray(workers)) {\r\n      return false;\r\n    }\r\n    \r\n    let terminated = 0;\r\n    const workersToKeep = [];\r\n    \r\n    // 각 워커 확인\r\n    for (const worker of workers) {\r\n      if (!worker) continue;\r\n      \r\n      // 활성 상태 체크 (구체적인 구현은 애플리케이션마다 다름)\r\n      const isActive = worker.active === true;\r\n      \r\n      if (!isActive) {\r\n        try {\r\n          worker.terminate();\r\n          terminated++;\r\n        } catch (e) {\r\n          // 워커 종료 실패는 무시\r\n        }\r\n      } else {\r\n        workersToKeep.push(worker);\r\n      }\r\n    }\r\n    \r\n    // 활성 워커만 유지\r\n    const newWorkers = workers.filter(w => w !== null);\r\n    (window as any).__webWorkers = newWorkers;\r\n    \r\n    logger.info(`[Resource Optimizer] Terminated ${terminated} unused web workers`);\r\n    return terminated > 0;\r\n  } catch (error) {\r\n    logger.error('[Resource Optimizer] Failed to terminate workers:', error as Record<string, unknown> | undefined);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 동적 모듈 정리\r\n * 일정 시간 동안 사용하지 않은 동적 모듈 언로드\r\n */\r\nexport function unloadUnusedModules(maxAgeMs = 300000): boolean {\r\n  // 브라우저 환경 체크\r\n  if (typeof window === 'undefined') {\r\n    return false;\r\n  }\r\n  \r\n  // 동적 모듈 맵 확인\r\n  const modules = window._dynamicModules;\r\n  \r\n  if (!modules || typeof modules.forEach !== 'function') {\r\n    return false;\r\n  }\r\n  \r\n  try {\r\n    const now = Date.now();\r\n    let unloaded = 0;\r\n    const keysToDelete: string[] = [];\r\n    \r\n    // 각 모듈 확인\r\n    modules.forEach((moduleInfo, key) => {\r\n      if (moduleInfo && moduleInfo.loaded && \r\n          now - moduleInfo.lastUsed > maxAgeMs && \r\n          typeof moduleInfo.unload === 'function') {\r\n        try {\r\n          moduleInfo.unload();\r\n          unloaded++;\r\n          keysToDelete.push(key);\r\n        } catch (e) {\r\n          // 모듈 언로드 실패는 무시\r\n        }\r\n      }\r\n    });\r\n    \r\n    // 언로드된 모듈 제거\r\n    keysToDelete.forEach(key => {\r\n      modules.delete(key);\r\n    });\r\n    \r\n    logger.info(`[Resource Optimizer] Unloaded ${unloaded} unused dynamic modules`);\r\n    return unloaded > 0;\r\n  } catch (error) {\r\n    logger.error('[Resource Optimizer] Failed to unload dynamic modules:', error as Record<string, unknown> | undefined);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 최적화 통계 얻기\r\n */\r\nexport function getOptimizationStats() {\r\n  return {\r\n    optimizationCount,\r\n    lastOptimizationTime,\r\n    totalFreedMemoryKB: Math.round(totalFreedMemoryBytes / 1024),\r\n    totalFreedMemoryMB: Math.round(totalFreedMemoryBytes / (1024 * 1024) * 100) / 100\r\n  };\r\n}\r\n\r\n/**\r\n * 캔버스 정리\r\n * 사용하지 않는 캔버스 리소스 해제\r\n */\r\nexport function clearCanvasResources(): boolean {\r\n  // DOM이 없는 환경 처리\r\n  if (typeof document === 'undefined') {\r\n    return false;\r\n  }\r\n  \r\n  try {\r\n    const canvases = document.querySelectorAll('canvas[data-disposable=\"true\"]');\r\n    let cleared = 0;\r\n    \r\n    canvases.forEach(canvas => {\r\n      const canvasElement = canvas as HTMLCanvasElement;\r\n      const ctx = canvasElement.getContext('2d');\r\n      if (ctx) {\r\n        // 캔버스 내용 지우기\r\n        ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);\r\n        cleared++;\r\n      }\r\n    });\r\n    \r\n    logger.info(`[Resource Optimizer] Cleared ${cleared} canvas resources`);\r\n    return cleared > 0;\r\n  } catch (error) {\r\n    logger.error('[Resource Optimizer] Failed to clear canvas resources:', error as Record<string, unknown> | undefined);\r\n    return false;\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\global.d.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":44,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":44,"endColumn":54},{"ruleId":"no-undef","severity":2,"message":"'DOMStringMap' is not defined.","line":64,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":64,"endColumn":26}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 메모리 최적화 관련 전역 타입 정의\r\n */\r\nimport { MemoryOptimizerUtility } from './types-extended';\r\n\r\n// 전역 타입 확장\r\ndeclare global {\r\n  interface Window {\r\n    // GC 함수 (--expose-gc 플래그 활성화 시 사용 가능)\r\n    gc?: () => void;\r\n    \r\n    // 메모리 최적화 유틸리티\r\n    __memoryOptimizer?: MemoryOptimizerUtility;\r\n    \r\n    // 임시 캐시 및 정리 대상 컬렉션\r\n    _imageCache?: Map<string, any> | { clear: () => void };\r\n    _memoryTables?: Array<{ clear: () => void }>;\r\n    _eventListeners?: Record<string, Array<{ cleanup?: () => void }>>;\r\n    _dynamicModules?: Record<string, {\r\n      lastUsed: number;\r\n      loaded: boolean;\r\n      unload: () => void;\r\n    }>;\r\n    _largeDataObjects?: Array<{ release: () => void }>;\r\n    \r\n    // 앱 캐시 객체 (추가)\r\n    _appCache?: { clear: () => void } | Map<string, any>;\r\n    \r\n    // GPU 정보 객체 (추가)\r\n    __gpuInfo?: {\r\n      renderer?: string;\r\n      vendor?: string;\r\n      isAccelerated?: boolean;\r\n      [key: string]: any;\r\n    };\r\n    \r\n    // Electron API 타입은 별도 정의 활용\r\n    electronAPI?: any;\r\n\r\n    // 스타일 캐시 - 두 가지 타입 모두 가능하게 설정\r\n    __styleCache?: Record<string, any> | Map<string, any>;\r\n    \r\n    // 이미지 리사이즈 캐시 - Map으로 설정\r\n    __imageResizeCache?: Map<string, HTMLImageElement>;\r\n    \r\n    // 기타 메모리 관련 전역 속성\r\n    __objectUrls?: Map<string, string>;\r\n    __memoryCache?: Map<string, any>;\r\n    __widgetCache?: Map<string, any>;\r\n  }\r\n\r\n  // 타입 스크립트가 WebGL 호환성 오류를 발생시키지 않도록 확장\r\n  interface WebGLRenderingContext {\r\n    // 기존 속성 유지\r\n  }\r\n\r\n  interface WebGL2RenderingContext {\r\n    // 기존 속성 유지\r\n  }\r\n\r\n  // HTML 요소 확장\r\n  interface HTMLElement {\r\n    _eventHandlers?: Record<string, any[]>;\r\n    dataset: DOMStringMap;\r\n  }\r\n}\r\n\r\n// 이 파일은 모듈로 처리되어야 함\r\nexport {};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\gpu-accelerator.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'HTMLCanvasElement' is not defined.","line":19,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":19,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'WebGLRenderingContext' is not defined.","line":19,"column":52,"nodeType":"Identifier","messageId":"undef","endLine":19,"endColumn":73},{"ruleId":"no-undef","severity":2,"message":"'WebGL2RenderingContext' is not defined.","line":19,"column":76,"nodeType":"Identifier","messageId":"undef","endLine":19,"endColumn":98},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":36,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":36,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":36,"column":36,"nodeType":"Identifier","messageId":"undef","endLine":36,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":37,"column":51,"nodeType":"Identifier","messageId":"undef","endLine":37,"endColumn":57},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":43,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":43,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'WebGLRenderingContext' is not defined.","line":48,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":48,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'WebGL2RenderingContext' is not defined.","line":48,"column":37,"nodeType":"Identifier","messageId":"undef","endLine":48,"endColumn":59},{"ruleId":"no-undef","severity":2,"message":"'WebGLRenderingContext' is not defined.","line":48,"column":142,"nodeType":"Identifier","messageId":"undef","endLine":48,"endColumn":163},{"ruleId":"no-undef","severity":2,"message":"'WebGL2RenderingContext' is not defined.","line":52,"column":43,"nodeType":"Identifier","messageId":"undef","endLine":52,"endColumn":65},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":56,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":56,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":72,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":72,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":72,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":72,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"debug"},"fix":{"range":[2403,2450],"text":""},"desc":"Remove the console.debug()."}]},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":102,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":102,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":104,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":104,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":112,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":112,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":127,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":127,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":154,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":154,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":215,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":215,"endColumn":23},{"ruleId":"no-self-assign","severity":2,"message":"'style.transform' is assigned to itself.","line":217,"column":25,"nodeType":"MemberExpression","messageId":"selfAssignment","endLine":217,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":223,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":223,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'HTMLCanvasElement' is not defined.","line":234,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":234,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'WebGLRenderingContext' is not defined.","line":236,"column":4,"nodeType":"Identifier","messageId":"undef","endLine":236,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'WebGL2RenderingContext' is not defined.","line":236,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":236,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'WebGLContextAttributes' is not defined.","line":244,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":244,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'WebGLRenderingContext' is not defined.","line":265,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":265,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'WebGL2RenderingContext' is not defined.","line":265,"column":37,"nodeType":"Identifier","messageId":"undef","endLine":265,"endColumn":59},{"ruleId":"no-undef","severity":2,"message":"'WebGL2RenderingContext' is not defined.","line":268,"column":59,"nodeType":"Identifier","messageId":"undef","endLine":268,"endColumn":81},{"ruleId":"no-undef","severity":2,"message":"'WebGLRenderingContext' is not defined.","line":273,"column":58,"nodeType":"Identifier","messageId":"undef","endLine":273,"endColumn":79},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":277,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":277,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":289,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":289,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'WebGLRenderingContext' is not defined.","line":300,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":300,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'WebGL2RenderingContext' is not defined.","line":300,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":300,"endColumn":53},{"ruleId":"no-undef","severity":2,"message":"'WebGL2RenderingContext' is not defined.","line":305,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":305,"endColumn":53},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":336,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":336,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'WebGLBuffer' is not defined.","line":342,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":342,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'WebGLTexture' is not defined.","line":343,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":343,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'WebGLFramebuffer' is not defined.","line":344,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":344,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'WebGLShader' is not defined.","line":345,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":345,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'WebGLProgram' is not defined.","line":346,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":346,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'WebGLRenderingContext' is not defined.","line":355,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":355,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'WebGL2RenderingContext' is not defined.","line":355,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":355,"endColumn":53},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":396,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":396,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":408,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":408,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":413,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":413,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":415,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":415,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":421,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":421,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":423,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":423,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":429,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":429,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":431,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":431,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":437,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":437,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":444,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":444,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":447,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":447,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":449,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":449,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":454,"column":4,"nodeType":"Identifier","messageId":"undef","endLine":454,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":471,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":471,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":472,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":472,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":476,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":476,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'WebGLRenderingContext' is not defined.","line":484,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":484,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":497,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":497,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":507,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":507,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":518,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":518,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":520,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":520,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":521,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":521,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":522,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":522,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":527,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":527,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'WebGLRenderingContext' is not defined.","line":535,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":535,"endColumn":48},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":548,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":548,"endColumn":9}],"suppressedMessages":[],"errorCount":68,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GPU 가속화 및 하드웨어 가속 최적화 유틸리티\r\n * 실무 최적화 전략에 따른 GPU 가속화 기능 제공\r\n */\r\n\r\n// GPU 가속 효과가 큰 임계값 (픽셀 크기)\r\nconst GPU_ACCELERATION_THRESHOLDS = {\r\n  CANVAS_AREA: 500000,    // 500,000 픽셀 (약 700x700)\r\n  ANIMATION_FRAMES: 10,   // 초당 10 프레임 이상에서 가속 필요\r\n  TRANSFORM_ELEMENTS: 50  // CSS 변환 요소가 50개 이상일 때 하드웨어 가속 권장\r\n};\r\n\r\n// GPU 가속 상태 추적\r\nlet gpuAccelerationStatus = {\r\n  hardwareAccelerated: false,\r\n  gpuTier: 0, // 0: 알 수 없음, 1: 저사양, 2: 중간, 3: 고사양\r\n  lastCheck: 0,\r\n  acceleratedElements: new WeakSet(),\r\n  canvas3DContexts: new WeakMap<HTMLCanvasElement, WebGLRenderingContext | WebGL2RenderingContext>(),\r\n  failedDetection: false\r\n};\r\n\r\n/**\r\n * GPU 하드웨어 가속 가능 여부 확인\r\n * @returns GPU 가속 가능 여부\r\n */\r\nexport async function detectGPUAcceleration(): Promise<boolean> {\r\n  try {\r\n    // 캐시된 결과 반환 (1분 이내)\r\n    const now = Date.now();\r\n    if (now - gpuAccelerationStatus.lastCheck < 60000 && !gpuAccelerationStatus.failedDetection) {\r\n      return gpuAccelerationStatus.hardwareAccelerated;\r\n    }\r\n    \r\n    // 이미 전역 객체에 GPU 정보가 있는 경우\r\n    if (window.__gpuInfo && typeof window.__gpuInfo.isHardwareAccelerated === 'function') {\r\n      gpuAccelerationStatus.hardwareAccelerated = window.__gpuInfo.isHardwareAccelerated();\r\n      gpuAccelerationStatus.lastCheck = now;\r\n      return gpuAccelerationStatus.hardwareAccelerated;\r\n    }\r\n    \r\n    // WebGL을 통한 GPU 가속 확인\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = 1;\r\n    canvas.height = 1;\r\n    \r\n    // WebGL 1.0 먼저 시도\r\n    let gl: WebGLRenderingContext | WebGL2RenderingContext | null = canvas.getContext('webgl') || canvas.getContext('experimental-webgl') as WebGLRenderingContext | null;\r\n    \r\n    // WebGL 2.0 시도\r\n    if (!gl) {\r\n      gl = canvas.getContext('webgl2') as WebGL2RenderingContext | null;\r\n    }\r\n    \r\n    if (!gl) {\r\n      console.warn('WebGL 컨텍스트를 얻을 수 없음: GPU 가속 불가능');\r\n      gpuAccelerationStatus.hardwareAccelerated = false;\r\n      gpuAccelerationStatus.failedDetection = true;\r\n      gpuAccelerationStatus.lastCheck = now;\r\n      return false;\r\n    }\r\n    \r\n    // GPU 정보 가져오기\r\n    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');\r\n    let renderer = 'Unknown';\r\n    let vendor = 'Unknown';\r\n    \r\n    if (debugInfo) {\r\n      renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) as string;\r\n      vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) as string;\r\n      \r\n      console.debug('GPU 정보:', { renderer, vendor });\r\n      \r\n      // GPU 티어 추정 (간단한 휴리스틱)\r\n      if (renderer) {\r\n        if (renderer.includes('NVIDIA') || renderer.includes('AMD') || renderer.includes('Radeon')) {\r\n          gpuAccelerationStatus.gpuTier = 3; // 고사양\r\n        } else if (renderer.includes('Intel') && !renderer.includes('HD Graphics')) {\r\n          gpuAccelerationStatus.gpuTier = 2; // 중간\r\n        } else if (!renderer.includes('SwiftShader') && !renderer.includes('ANGLE') && !renderer.includes('Mesa')) {\r\n          gpuAccelerationStatus.gpuTier = 2; // 중간 (기본값)\r\n        } else {\r\n          gpuAccelerationStatus.gpuTier = 1; // 저사양 또는 소프트웨어 렌더링\r\n        }\r\n      }\r\n      \r\n      // 소프트웨어 렌더링 감지\r\n      const isSoftwareRenderer = \r\n        renderer?.includes('SwiftShader') || \r\n        renderer?.includes('ANGLE') || \r\n        renderer?.includes('llvmpipe') ||\r\n        renderer?.includes('Basic');\r\n      \r\n      gpuAccelerationStatus.hardwareAccelerated = !isSoftwareRenderer;\r\n    } else {\r\n      // Debug info를 얻을 수 없는 경우 기본적으로 하드웨어 가속 가능 가정\r\n      gpuAccelerationStatus.hardwareAccelerated = true;\r\n      gpuAccelerationStatus.gpuTier = 1; // 정보 없음 - 기본 저사양 가정\r\n    }\r\n    \r\n    // 추가 확인: CSS 3D 변환 지원\r\n    const testElement = document.createElement('div');\r\n    testElement.style.transform = 'translate3d(0, 0, 0)';\r\n    const has3DTransforms = window.getComputedStyle(testElement).transform === 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)';\r\n    \r\n    // CSS 3D 변환 지원하지 않으면 하드웨어 가속 불가능\r\n    if (!has3DTransforms) {\r\n      gpuAccelerationStatus.hardwareAccelerated = false;\r\n    }\r\n    \r\n    // 전역 GPU 정보 객체 설정\r\n    window.__gpuInfo = {\r\n      isAccelerated: () => gpuAccelerationStatus.hardwareAccelerated,\r\n      renderer: renderer,\r\n      vendor: vendor,\r\n      getGPUTier: () => ({\r\n        tier: gpuAccelerationStatus.gpuTier,\r\n        type: getTierDescription(gpuAccelerationStatus.gpuTier)\r\n      }),\r\n      isHardwareAccelerated: () => gpuAccelerationStatus.hardwareAccelerated\r\n    };\r\n    \r\n    // 상태 업데이트\r\n    gpuAccelerationStatus.lastCheck = now;\r\n    return gpuAccelerationStatus.hardwareAccelerated;\r\n  } catch (error) {\r\n    console.error('GPU 가속 감지 중 오류:', error);\r\n    gpuAccelerationStatus.failedDetection = true;\r\n    gpuAccelerationStatus.lastCheck = Date.now();\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 티어 설명 반환\r\n * @param tier GPU 티어\r\n * @returns 설명 문자열\r\n */\r\nfunction getTierDescription(tier: number): string {\r\n  switch (tier) {\r\n    case 3: return 'high-end';\r\n    case 2: return 'mid-range';\r\n    case 1: return 'low-end';\r\n    default: return 'unknown';\r\n  }\r\n}\r\n\r\n/**\r\n * 요소에 하드웨어 가속 적용\r\n * @param element 가속할 DOM 요소\r\n * @param options 가속 옵션\r\n */\r\nexport function applyHardwareAcceleration(\r\n  element: HTMLElement, \r\n  options: { \r\n    force?: boolean;           // 항상 적용 여부\r\n    useTranslate3d?: boolean;  // transform: translate3d 사용\r\n    useWillChange?: boolean;   // will-change 속성 사용\r\n    highPriority?: boolean;    // 높은 우선순위 (애니메이션 요소)\r\n  } = {}\r\n): void {\r\n  try {\r\n    // 이미 가속 중인 요소 확인\r\n    if (gpuAccelerationStatus.acceleratedElements.has(element)) {\r\n      return;\r\n    }\r\n    \r\n    const { \r\n      force = false, \r\n      useTranslate3d = true, \r\n      useWillChange = true,\r\n      highPriority = false\r\n    } = options;\r\n    \r\n    // 하드웨어 가속이 불가능하고 강제 적용이 아닌 경우 무시\r\n    if (!gpuAccelerationStatus.hardwareAccelerated && !force) return;\r\n    \r\n    // 성능 영향 평가 (면적 기준)\r\n    const rect = element.getBoundingClientRect();\r\n    const area = rect.width * rect.height;\r\n    \r\n    // 작은 요소는 가속이 오히려 성능 저하를 가져올 수 있음\r\n    // 단, 높은 우선순위 요소는 항상 가속 적용\r\n    if (!highPriority && area < 100 && !force) return;\r\n    \r\n    // 하드웨어 가속 적용\r\n    const style = element.style;\r\n    \r\n    // GPU 티어에 따른 최적화 전략 조정\r\n    const gpuTier = gpuAccelerationStatus.gpuTier;\r\n    \r\n    if (useTranslate3d || highPriority) {\r\n      // translate3d를 사용한 GPU 가속\r\n      // 이미 transform이 설정되어 있으면 그대로 유지하고 translate3d만 추가\r\n      const currentTransform = style.transform;\r\n      if (!currentTransform || currentTransform === 'none') {\r\n        style.transform = 'translate3d(0, 0, 0)';\r\n      } else if (!currentTransform.includes('translate3d')) {\r\n        style.transform = `${currentTransform} translate3d(0, 0, 0)`;\r\n      }\r\n    }\r\n    \r\n    // will-change 속성은 고사양 GPU에서만 최대한 활용\r\n    // 저사양 GPU에서는 메모리 부담이 크므로 필요한 경우만 적용\r\n    if (useWillChange && (gpuTier >= 2 || highPriority)) {\r\n      // 애니메이션 대상 요소인 경우 transform + opacity로 최적화\r\n      if (highPriority) {\r\n        style.willChange = 'transform, opacity';\r\n      } else {\r\n        style.willChange = 'transform';\r\n      }\r\n    }\r\n    \r\n    // IE 대응이 필요한 경우\r\n    if (typeof (window as any).MSCSSMatrix !== 'undefined') {\r\n      // msTransform 대신 표준 transform 사용\r\n      style.transform = style.transform;\r\n    }\r\n    \r\n    // 캐시에 저장\r\n    gpuAccelerationStatus.acceleratedElements.add(element);\r\n  } catch (error) {\r\n    console.warn('하드웨어 가속 적용 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Canvas에 WebGL 컨텍스트 생성 및 최적화\r\n * @param canvas 타겟 캔버스\r\n * @param preferWebGL2 WebGL 2 선호 여부\r\n * @returns WebGL 컨텍스트\r\n */\r\nexport function createOptimizedWebGLContext(\r\n  canvas: HTMLCanvasElement,\r\n  preferWebGL2: boolean = true\r\n): WebGLRenderingContext | WebGL2RenderingContext | null {\r\n  try {\r\n    // 이미 생성된 컨텍스트가 있으면 반환\r\n    if (gpuAccelerationStatus.canvas3DContexts.has(canvas)) {\r\n      return gpuAccelerationStatus.canvas3DContexts.get(canvas) || null;\r\n    }\r\n    \r\n    // WebGL 컨텍스트 옵션\r\n    const contextOptions: WebGLContextAttributes = {\r\n      alpha: false,           // 투명도 불필요한 경우 성능 향상\r\n      antialias: false,       // 안티앨리어싱은 필요한 경우만 활성화\r\n      depth: true,            // 3D 렌더링 필요 시\r\n      failIfMajorPerformanceCaveat: false,\r\n      powerPreference: 'high-performance',\r\n      preserveDrawingBuffer: false,\r\n      stencil: false,         // 스텐실 버퍼 필요한 경우만 활성화\r\n      desynchronized: true    // 지연 감소를 위해 활성화\r\n    };\r\n    \r\n    // GPU 티어와 요소 크기에 따라 옵션 조정\r\n    const rect = canvas.getBoundingClientRect();\r\n    const area = rect.width * rect.height;\r\n    \r\n    // 큰 캔버스이고 고사양 GPU인 경우 안티앨리어싱 활성화\r\n    if (area > GPU_ACCELERATION_THRESHOLDS.CANVAS_AREA && gpuAccelerationStatus.gpuTier >= 2) {\r\n      contextOptions.antialias = true;\r\n    }\r\n    \r\n    // WebGL 버전 결정\r\n    let gl: WebGLRenderingContext | WebGL2RenderingContext | null = null;\r\n    \r\n    if (preferWebGL2) {\r\n      gl = canvas.getContext('webgl2', contextOptions) as WebGL2RenderingContext;\r\n    }\r\n    \r\n    // WebGL 2를 지원하지 않으면 WebGL 1로 폴백\r\n    if (!gl) {\r\n      gl = canvas.getContext('webgl', contextOptions) as WebGLRenderingContext;\r\n    }\r\n    \r\n    if (!gl) {\r\n      console.warn('WebGL 컨텍스트를 생성할 수 없습니다.');\r\n      return null;\r\n    }\r\n    \r\n    // 성능 최적화 설정\r\n    applyWebGLOptimizations(gl, area);\r\n    \r\n    // 캐시에 저장\r\n    gpuAccelerationStatus.canvas3DContexts.set(canvas, gl);\r\n    \r\n    return gl;\r\n  } catch (error) {\r\n    console.error('WebGL 컨텍스트 생성 중 오류:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * WebGL 컨텍스트에 성능 최적화 적용\r\n * @param gl WebGL 컨텍스트\r\n * @param area 캔버스 영역 (픽셀)\r\n */\r\nfunction applyWebGLOptimizations(\r\n  gl: WebGLRenderingContext | WebGL2RenderingContext,\r\n  area: number\r\n): void {\r\n  try {\r\n    // 확장 기능 가져오기\r\n    const isWebGL2 = !!(gl as WebGL2RenderingContext).drawBuffers;\r\n    \r\n    // 아래 확장 기능들이 성능 향상에 도움\r\n    if (!isWebGL2) {\r\n      // WebGL 1 확장\r\n      gl.getExtension('OES_element_index_uint');\r\n      gl.getExtension('OES_vertex_array_object');\r\n    }\r\n    \r\n    // 공통 확장\r\n    gl.getExtension('EXT_texture_filter_anisotropic');\r\n    \r\n    // 캔버스 크기가 크면 GPU 메모리 사용량을 줄이기 위한 설정\r\n    if (area > GPU_ACCELERATION_THRESHOLDS.CANVAS_AREA) {\r\n      // 큰 텍스처 처리를 위한 확장 (필요한 경우)\r\n      gl.getExtension('OES_texture_float');\r\n      gl.getExtension('WEBGL_compressed_texture_s3tc');\r\n    }\r\n    \r\n    // 기본 상태 설정\r\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);\r\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);\r\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\r\n    \r\n    // 뎁스 테스트 설정 (필요한 경우)\r\n    gl.enable(gl.DEPTH_TEST);\r\n    gl.depthFunc(gl.LEQUAL);\r\n    \r\n    // 최적화를 위한 힌트 설정\r\n    gl.hint(gl.GENERATE_MIPMAP_HINT, gl.NICEST);\r\n  } catch (error) {\r\n    console.warn('WebGL 최적화 적용 중 오류:', error);\r\n  }\r\n}\r\n\r\n// WebGL 리소스 타입 정의\r\ninterface WebGLResources {\r\n  buffers?: WebGLBuffer[];\r\n  textures?: WebGLTexture[];\r\n  framebuffers?: WebGLFramebuffer[];\r\n  shaders?: WebGLShader[];\r\n  programs?: WebGLProgram[];\r\n}\r\n\r\n/**\r\n * 불필요한 WebGL 리소스 정리\r\n * @param gl WebGL 컨텍스트\r\n * @param resources 정리할 리소스 목록\r\n */\r\nexport function cleanupWebGLResources(\r\n  gl: WebGLRenderingContext | WebGL2RenderingContext,\r\n  resources: WebGLResources\r\n): void {\r\n  try {\r\n    const { buffers, textures, framebuffers, shaders, programs } = resources;\r\n    \r\n    // 버퍼 삭제\r\n    if (buffers && buffers.length > 0) {\r\n      buffers.forEach(buffer => {\r\n        if (buffer) gl.deleteBuffer(buffer);\r\n      });\r\n    }\r\n    \r\n    // 텍스처 삭제\r\n    if (textures && textures.length > 0) {\r\n      textures.forEach(texture => {\r\n        if (texture) gl.deleteTexture(texture);\r\n      });\r\n    }\r\n    \r\n    // 프레임버퍼 삭제\r\n    if (framebuffers && framebuffers.length > 0) {\r\n      framebuffers.forEach(framebuffer => {\r\n        if (framebuffer) gl.deleteFramebuffer(framebuffer);\r\n      });\r\n    }\r\n    \r\n    // 쉐이더 삭제\r\n    if (shaders && shaders.length > 0) {\r\n      shaders.forEach(shader => {\r\n        if (shader) gl.deleteShader(shader);\r\n      });\r\n    }\r\n    \r\n    // 프로그램 삭제\r\n    if (programs && programs.length > 0) {\r\n      programs.forEach(program => {\r\n        if (program) gl.deleteProgram(program);\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.warn('WebGL 리소스 정리 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 요소에 CSS 하드웨어 가속 최적화를 적용하는 React 훅\r\n */\r\nexport function enableGPUAcceleration(): void {\r\n  try {\r\n    // GPU 가속을 사용할 수 있는지 확인\r\n    detectGPUAcceleration().then(supported => {\r\n      if (!supported) {\r\n        console.warn('GPU 하드웨어 가속이 지원되지 않습니다.');\r\n        return;\r\n      }\r\n      \r\n      // 애니메이션 요소에 하드웨어 가속 적용\r\n      const animatedElements = document.querySelectorAll('.animated, .animate, [data-animate=\"true\"], .animation');\r\n      animatedElements.forEach(el => {\r\n        if (el instanceof HTMLElement) {\r\n          applyHardwareAcceleration(el, { highPriority: true });\r\n        }\r\n      });\r\n      \r\n      // 차트 요소에 하드웨어 가속 적용\r\n      const chartElements = document.querySelectorAll('.chart, .graph, canvas[data-chart=\"true\"]');\r\n      chartElements.forEach(el => {\r\n        if (el instanceof HTMLElement) {\r\n          applyHardwareAcceleration(el, { useWillChange: true });\r\n        }\r\n      });\r\n      \r\n      // 스크롤 컨테이너에 하드웨어 가속 적용\r\n      const scrollContainers = document.querySelectorAll('.scroll-container, [data-scroll=\"true\"], .overflow-auto');\r\n      scrollContainers.forEach(el => {\r\n        if (el instanceof HTMLElement) {\r\n          applyHardwareAcceleration(el, { useTranslate3d: true });\r\n        }\r\n      });\r\n    });\r\n  } catch (error) {\r\n    console.error('GPU 가속 활성화 중 오류:', error);\r\n  }\r\n}\r\n\r\n// 브라우저 환경에서만 실행\r\nif (typeof window !== 'undefined') {\r\n  // GPU 가속 감지 자동 실행 (페이지 로드 후)\r\n  if (document.readyState === 'complete') {\r\n    detectGPUAcceleration();\r\n  } else {\r\n    window.addEventListener('load', () => {\r\n      // 페이지 로드 완료 후 GPU 가속 감지 및 최적화\r\n      setTimeout(() => detectGPUAcceleration(), 1000);\r\n    });\r\n  }\r\n  \r\n  // 전역 객체에 GPU 가속 함수 노출\r\n  (window as any).__gpuAccelerator = {\r\n    detectGPUAcceleration,\r\n    applyHardwareAcceleration,\r\n    createOptimizedWebGLContext,\r\n    cleanupWebGLResources,\r\n    enableGPUAcceleration,\r\n    getStatus: () => ({ ...gpuAccelerationStatus })\r\n  };\r\n}\r\n\r\n/**\r\n * 현재 GPU 가속화 상태 확인\r\n * @returns {boolean} GPU 가속화 활성화 여부\r\n */\r\nexport function isGPUAccelerationEnabled(): boolean {\r\n  try {\r\n    // 캐시된 정보 사용 (있는 경우)\r\n    if (window.__gpuInfo !== undefined) {\r\n      return window.__gpuInfo.isAccelerated();\r\n    }\r\n\r\n    // 캐시된 정보가 없으면 직접 확인\r\n    const canvas = document.createElement('canvas');\r\n    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\r\n    \r\n    if (!gl) {\r\n      return false;\r\n    }\r\n    \r\n    // WebGL 타입으로 명시적 캐스팅 추가\r\n    const glContext = gl as WebGLRenderingContext;\r\n    const debugInfo = glContext.getExtension('WEBGL_debug_renderer_info');\r\n    const renderer = debugInfo ? glContext.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : '';\r\n    \r\n    // WebGL 렌더러 문자열 기반으로 확인\r\n    const isAccelerated = !(\r\n      renderer.includes('SwiftShader') || \r\n      renderer.includes('Basic Renderer') ||\r\n      renderer.includes('Software') ||\r\n      renderer.includes('llvmpipe')\r\n    );\r\n    \r\n    // 결과 캐싱\r\n    window.__gpuInfo = {\r\n      isAccelerated: () => isAccelerated,\r\n      renderer,\r\n      vendor: debugInfo ? glContext.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : '',\r\n      getGPUTier: () => ({ tier: 0, type: 'unknown' }),\r\n      isHardwareAccelerated: () => isAccelerated\r\n    };\r\n    \r\n    return isAccelerated;\r\n  } catch (error) {\r\n    console.warn('GPU 가속화 상태 확인 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 현재 GPU 정보 가져오기\r\n * @returns {Object} GPU 정보\r\n */\r\nexport function getGPUInfo(): { renderer: string, vendor: string, isAccelerated: boolean } {\r\n  // 캐시된 정보 사용 (있는 경우)\r\n  if (window.__gpuInfo) {\r\n    return {\r\n      renderer: window.__gpuInfo.renderer || 'Unknown',\r\n      vendor: window.__gpuInfo.vendor || 'Unknown',\r\n      isAccelerated: window.__gpuInfo.isAccelerated()\r\n    };\r\n  }\r\n  \r\n  // GPU 정보 가져오기\r\n  const canvas = document.createElement('canvas');\r\n  const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\r\n  \r\n  if (!gl) {\r\n    return { renderer: 'Unknown', vendor: 'Unknown', isAccelerated: false };\r\n  }\r\n  \r\n  // WebGL 타입으로 명시적 캐스팅 추가\r\n  const glContext = gl as WebGLRenderingContext;\r\n  const debugInfo = glContext.getExtension('WEBGL_debug_renderer_info');\r\n  const renderer = debugInfo ? glContext.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'Unknown';\r\n  const vendor = debugInfo ? glContext.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'Unknown';\r\n  \r\n  const isAccelerated = !(\r\n    renderer.includes('SwiftShader') || \r\n    renderer.includes('Basic Renderer') ||\r\n    renderer.includes('Software') ||\r\n    renderer.includes('llvmpipe')\r\n  );\r\n  \r\n  // 결과 캐싱\r\n  window.__gpuInfo = {\r\n    isAccelerated: () => isAccelerated,\r\n    renderer,\r\n    vendor,\r\n    getGPUTier: () => ({ tier: 0, type: 'unknown' }),\r\n    isHardwareAccelerated: () => isAccelerated\r\n  };\r\n  \r\n  return { renderer, vendor, isAccelerated };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\hooks.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":39,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":39,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":119,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":119,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":127,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":127,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":162,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":162,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":185,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":185,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'fetchMemoryInfo' is assigned a value but never used.","line":218,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":218,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fetchMemoryInfo' is assigned a value but never used.","line":218,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":218,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":223,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":223,"endColumn":16},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":223,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":223,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5829,5885],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":227,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":227,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":230,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":230,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":254,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":254,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":315,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":315,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":320,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":320,"endColumn":22}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\n/**\r\n * 메모리 관련 React 훅 통합 모듈\r\n * \r\n * 네이티브 모듈과 기존 JavaScript 최적화 기능을 통합하여 사용하는\r\n * React 훅을 제공합니다.\r\n */\r\nimport { useState, useEffect, useCallback, useRef } from 'react';\r\nimport { useToast } from '@/app/hooks/useToast';\r\nimport type { MemoryInfo, MemorySettings, OptimizationResult } from '@/types';\r\nimport { getMemoryInfo, optimizeMemory } from '@/app/utils/nativeModuleClient';\r\nimport { formatBytes } from './format-utils';\r\n\r\nexport interface UseMemoryOptions {\r\n  autoFetch?: boolean;\r\n  interval?: number;\r\n  autoOptimize?: boolean;\r\n  threshold?: number;\r\n  optimizationLevel?: number;\r\n}\r\n\r\n/**\r\n * 메모리 정보 및 최적화를 위한 훅\r\n */\r\nexport function useMemory(options: UseMemoryOptions = {}) {\r\n  const {\r\n    autoFetch = false,\r\n    interval = 30000,\r\n    autoOptimize = false,\r\n    threshold = 80,\r\n    optimizationLevel = 0\r\n  } = options;\r\n  \r\n  const [memoryInfo, setMemoryInfo] = useState<MemoryInfo | null>(null);\r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const [lastUpdate, setLastUpdate] = useState(0);\r\n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\r\n  const { showToast } = useToast();\r\n  \r\n  // 메모리 정보 가져오기\r\n  const fetchMemoryInfo = useCallback(async () => {\r\n    try {\r\n      setLoading(true);\r\n      const response = await getMemoryInfo();\r\n      \r\n      if (response.success && response.memoryInfo) {\r\n        setMemoryInfo(response.memoryInfo);\r\n        setLastUpdate(Date.now());\r\n        setError(null);\r\n        return response.memoryInfo;\r\n      } else {\r\n        setError(response.error || 'Failed to fetch memory info');\r\n        return null;\r\n      }\r\n    } catch (err) {\r\n      setError(err instanceof Error ? err.message : 'Unknown error');\r\n      return null;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, []);\r\n  \r\n  // 메모리 최적화 실행\r\n  const runMemoryOptimization = useCallback(async (level?: number) => {\r\n    try {\r\n      setLoading(true);\r\n      \r\n      // 최적화 레벨 결정\r\n      const optimizationLevel = level ?? optimizationLevel;\r\n      \r\n      // 메모리 최적화 수행\r\n      const response = await optimizeMemory(optimizationLevel);\r\n      \r\n      if (response.success) {\r\n        // 최적화 후 메모리 정보 갱신\r\n        await fetchMemoryInfo();\r\n        \r\n        // 알림 표시 (옵션에 따라)\r\n        showToast({\r\n          title: 'Memory Optimized',\r\n          description: `Freed ${response.result?.freed_mb.toFixed(2)} MB of memory`,\r\n          type: 'success',\r\n          duration: 3000\r\n        });\r\n        \r\n        return response.result;\r\n      } else {\r\n        setError(response.error || 'Optimization failed');\r\n        return null;\r\n      }\r\n    } catch (err) {\r\n      setError(err instanceof Error ? err.message : 'Unknown error');\r\n      return null;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [fetchMemoryInfo, showToast]);\r\n  \r\n  // 자동 최적화 수행\r\n  const checkAndOptimizeIfNeeded = useCallback(async () => {\r\n    const info = await fetchMemoryInfo();\r\n    \r\n    if (info && autoOptimize && info.percentUsed > threshold) {\r\n      await runMemoryOptimization();\r\n    }\r\n  }, [autoOptimize, fetchMemoryInfo, threshold, runMemoryOptimization]);\r\n  \r\n  // 초기화 및 주기적 실행\r\n  useEffect(() => {\r\n    // 초기 데이터 로드\r\n    if (autoFetch) {\r\n      fetchMemoryInfo();\r\n    }\r\n    \r\n    // 주기적 갱신 설정\r\n    if (autoFetch && interval > 0) {\r\n      intervalRef.current = setInterval(() => {\r\n        autoOptimize ? checkAndOptimizeIfNeeded() : fetchMemoryInfo();\r\n      }, interval);\r\n    }\r\n    \r\n    // 정리 함수\r\n    return () => {\r\n      if (intervalRef.current) {\r\n        clearInterval(intervalRef.current);\r\n      }\r\n    };\r\n  }, [autoFetch, autoOptimize, checkAndOptimizeIfNeeded, fetchMemoryInfo, interval]);\r\n  \r\n  return {\r\n    memoryInfo,\r\n    loading,\r\n    error,\r\n    lastUpdate,\r\n    optimizationLevel,\r\n    fetchMemoryInfo,\r\n    runMemoryOptimization\r\n  };\r\n}\r\n\r\n/**\r\n * 메모리 설정 관리를 위한 훅\r\n */\r\nexport function useMemorySettings() {\r\n  const [settings, setSettings] = useState<MemorySettings>({\r\n    autoOptimize: true,\r\n    optimizationThreshold: 75,\r\n    lowMemoryMode: false,\r\n    gcInterval: 60000\r\n  });\r\n  \r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n  \r\n  // 설정 로드\r\n  const loadSettings = useCallback(async () => {\r\n    try {\r\n      setLoading(true);\r\n      // localStorage에서 설정 로드\r\n      const savedSettings = localStorage.getItem('memorySettings');\r\n      \r\n      if (savedSettings) {\r\n        setSettings(JSON.parse(savedSettings));\r\n      }\r\n      \r\n      setError(null);\r\n    } catch (err) {\r\n      setError(err instanceof Error ? err.message : 'Failed to load settings');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, []);\r\n  \r\n  // 설정 저장\r\n  const saveSettings = useCallback((newSettings: Partial<MemorySettings>) => {\r\n    try {\r\n      setLoading(true);\r\n      \r\n      // 기존 설정과 병합\r\n      const updatedSettings = { ...settings, ...newSettings };\r\n      \r\n      // localStorage에 저장\r\n      localStorage.setItem('memorySettings', JSON.stringify(updatedSettings));\r\n      \r\n      // 상태 업데이트\r\n      setSettings(updatedSettings);\r\n      setError(null);\r\n      \r\n      return true;\r\n    } catch (err) {\r\n      setError(err instanceof Error ? err.message : 'Failed to save settings');\r\n      return false;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [settings]);\r\n  \r\n  // 초기화\r\n  useEffect(() => {\r\n    loadSettings();\r\n  }, [loadSettings]);\r\n  \r\n  return {\r\n    settings,\r\n    loading,\r\n    error,\r\n    saveSettings,\r\n    loadSettings\r\n  };\r\n}\r\n\r\n/**\r\n * 메모리 사용량 로깅을 위한 훅\r\n */\r\nexport function useMemoryLogging(interval = 60000) {\r\n  const { memoryInfo, fetchMemoryInfo } = useMemory({ autoFetch: true, interval });\r\n  \r\n  useEffect(() => {\r\n    const logMemoryUsage = () => {\r\n      if (memoryInfo) {\r\n        console.log(`Memory Usage: ${memoryInfo.percentUsed}%`);\r\n      }\r\n    };\r\n    \r\n    const intervalId = setInterval(logMemoryUsage, interval);\r\n    \r\n    return () => {\r\n      clearInterval(intervalId);\r\n    };\r\n  }, [memoryInfo, interval]);\r\n}\r\n\r\n/**\r\n * 메모리 사용량이 높을 때 자동 최적화를 수행하는 훅\r\n */\r\nexport function useAutoMemoryOptimization(options: {\r\n  enabled?: boolean;\r\n  threshold?: number;\r\n  interval?: number;\r\n  showNotifications?: boolean;\r\n} = {}) {\r\n  const {\r\n    enabled = true,\r\n    threshold = 80,\r\n    interval = 60000,\r\n    showNotifications = true\r\n  } = options;\r\n  \r\n  const { showToast } = useToast();\r\n  const [isOptimizing, setIsOptimizing] = useState(false);\r\n  const [lastOptimization, setLastOptimization] = useState<OptimizationResult | null>(null);\r\n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\r\n  \r\n  // 최적화 실행 함수\r\n  const optimizeMemory = useCallback(async () => {\r\n    if (!enabled || isOptimizing) return;\r\n    \r\n    try {\r\n      setIsOptimizing(true);\r\n      \r\n      // 현재 메모리 정보 가져오기\r\n      const memoryResponse = await getMemoryInfo();\r\n      \r\n      if (!memoryResponse.success) {\r\n        throw new Error(memoryResponse.error || 'Failed to get memory info');\r\n      }\r\n      \r\n      const memInfo = memoryResponse.memoryInfo;\r\n      \r\n      // 임계값을 초과하는지 확인\r\n      if (memInfo && memInfo.percentUsed > threshold) {\r\n        // 최적화 수행\r\n        const optimizationResponse = await optimizeMemory(\r\n          memInfo.percentUsed > 90 ? 3 : \r\n          memInfo.percentUsed > 80 ? 2 : 1\r\n        );\r\n        \r\n        if (optimizationResponse.success && optimizationResponse.result) {\r\n          setLastOptimization(optimizationResponse.result);\r\n          \r\n          // 알림 표시 (옵션에 따라)\r\n          if (showNotifications) {\r\n            const freedMB = optimizationResponse.result.freed_mb || 0;\r\n            showToast({\r\n              title: 'Memory Optimized',\r\n              description: `Freed ${freedMB.toFixed(2)} MB of memory`,\r\n              type: 'success',\r\n              duration: 3000\r\n            });\r\n          }\r\n        }\r\n      }\r\n    } catch (err) {\r\n      if (showNotifications) {\r\n        showToast({\r\n          title: 'Memory Optimization Failed',\r\n          description: err instanceof Error ? err.message : 'Unknown error',\r\n          type: 'error'\r\n        });\r\n      }\r\n    } finally {\r\n      setIsOptimizing(false);\r\n    }\r\n  }, [enabled, isOptimizing, threshold, showNotifications, showToast]);\r\n  \r\n  // 주기적 검사 설정\r\n  useEffect(() => {\r\n    if (enabled && interval > 0) {\r\n      // 초기 최적화 실행\r\n      optimizeMemory();\r\n      \r\n      // 주기적 최적화 설정\r\n      intervalRef.current = setInterval(optimizeMemory, interval);\r\n    }\r\n    \r\n    return () => {\r\n      if (intervalRef.current) {\r\n        clearInterval(intervalRef.current);\r\n        intervalRef.current = null;\r\n      }\r\n    };\r\n  }, [enabled, interval, optimizeMemory]);\r\n  \r\n  return {\r\n    isOptimizing,\r\n    lastOptimization,\r\n    optimizeMemory\r\n  };\r\n}\r\n\r\n/**\r\n * 포맷된 메모리 정보를 제공하는 훅\r\n */\r\nexport function useFormattedMemoryInfo(options: {\r\n  autoFetch?: boolean;\r\n  interval?: number;\r\n} = {}) {\r\n  const { \r\n    autoFetch = true, \r\n    interval = 30000 \r\n  } = options;\r\n  \r\n  const { memoryInfo, loading, error, fetchMemoryInfo } = \r\n    useMemory({ autoFetch, interval });\r\n  \r\n  // 포맷된 메모리 정보\r\n  const formattedInfo = memoryInfo ? {\r\n    heapUsed: formatBytes(memoryInfo.heapUsed),\r\n    heapTotal: formatBytes(memoryInfo.heapTotal),\r\n    rss: formatBytes(memoryInfo.rss),\r\n    percentUsed: `${memoryInfo.percentUsed.toFixed(1)}%`,\r\n    heapUsedMB: `${memoryInfo.heapUsedMB.toFixed(2)} MB`,\r\n    rssMB: `${memoryInfo.rssMB.toFixed(2)} MB`,\r\n    timestamp: new Date(memoryInfo.timestamp).toLocaleTimeString()\r\n  } : null;\r\n  \r\n  return {\r\n    memoryInfo,\r\n    formattedInfo,\r\n    loading,\r\n    error,\r\n    fetchMemoryInfo\r\n  };\r\n}\r\n\r\n/**\r\n * 임계값에 따른 메모리 상태를 제공하는 훅\r\n */\r\nexport function useMemoryStatus(thresholds: {\r\n  warning?: number;\r\n  critical?: number;\r\n} = {}) {\r\n  const { warning = 70, critical = 85 } = thresholds;\r\n  \r\n  const { memoryInfo, loading, error, fetchMemoryInfo } = \r\n    useMemory({ autoFetch: true });\r\n  \r\n  // 메모리 상태 결정\r\n  const status = memoryInfo \r\n    ? (memoryInfo.percentUsed >= critical \r\n      ? 'critical' \r\n      : memoryInfo.percentUsed >= warning \r\n        ? 'warning' \r\n        : 'normal')\r\n    : 'unknown';\r\n  \r\n  return {\r\n    memoryInfo,\r\n    status,\r\n    loading,\r\n    error,\r\n    fetchMemoryInfo,\r\n    isNormal: status === 'normal',\r\n    isWarning: status === 'warning',\r\n    isCritical: status === 'critical'\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\image-optimizer.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":14,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":14,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":18,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":18,"endColumn":51},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":33,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":33,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":44,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":44,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":48,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":48,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":52,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":52,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":52,"column":60,"nodeType":"Identifier","messageId":"undef","endLine":52,"endColumn":66},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":53,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":53,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":53,"column":59,"nodeType":"Identifier","messageId":"undef","endLine":53,"endColumn":65},{"ruleId":"no-undef","severity":2,"message":"'IntersectionObserver' is not defined.","line":64,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":64,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":67,"column":49,"nodeType":"Identifier","messageId":"undef","endLine":67,"endColumn":65},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":88,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":88,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":88,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":88,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3021,3079],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":92,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":92,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":102,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":102,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":102,"column":63,"nodeType":"Identifier","messageId":"undef","endLine":102,"endColumn":69},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":105,"column":44,"nodeType":"Identifier","messageId":"undef","endLine":105,"endColumn":55},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":115,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":115,"endColumn":12}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 이미지 최적화 관련 유틸리티\r\n * 이미지 캐시 정리 및 최적화 기능 제공\r\n */\r\nimport { isElementInViewport } from './dom-optimizer';\r\n\r\n/**\r\n * 이미지 캐시 정리\r\n * 렌더러에 로드된 이미지 캐시를 효율적으로 관리\r\n */\r\nexport function clearImageCache(): void {\r\n  try {\r\n    // 화면에 보이지 않는 이미지 선택\r\n    const images = document.querySelectorAll('img:not([data-keep-cache=\"true\"])');\r\n    images.forEach(img => {\r\n      if (!isElementInViewport(img)) {\r\n        // HTMLImageElement로 타입 캐스팅하여 src 속성에 접근\r\n        const imgElement = img as HTMLImageElement;\r\n        const originalSrc = imgElement.src;\r\n        if (originalSrc) {\r\n          imgElement.setAttribute('data-original-src', originalSrc);\r\n          imgElement.src = '';\r\n          \r\n          // 필요할 때 복원하기 위한 이벤트 리스너\r\n          imgElement.addEventListener('error', () => {\r\n            const savedSrc = imgElement.getAttribute('data-original-src');\r\n            if (savedSrc) imgElement.src = savedSrc;\r\n          }, { once: true });\r\n        }\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.warn('이미지 캐시 정리 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 이미지 리소스를 최적화하여 메모리 사용량을 줄입니다.\r\n * @returns Promise<boolean>\r\n */\r\nexport async function optimizeImageResources(): Promise<boolean> {\r\n  try {\r\n    // 1. 화면에 보이지 않는 이미지 검색\r\n    const images = document.querySelectorAll('img:not([data-optimized])');\r\n    let optimizedCount = 0;\r\n    \r\n    for (const img of Array.from(images)) {\r\n      const imgElement = img as HTMLImageElement;\r\n      const rect = imgElement.getBoundingClientRect();\r\n      \r\n      // 화면에 보이지 않는 이미지이고 소스가 있는 경우\r\n      if ((rect.top < -window.innerHeight || rect.bottom > window.innerHeight * 2 ||\r\n           rect.left < -window.innerWidth || rect.right > window.innerWidth * 2) && \r\n          imgElement.src && !imgElement.src.startsWith('data:')) {\r\n        \r\n        // 원본 소스 저장\r\n        const originalSrc = imgElement.src;\r\n        imgElement.setAttribute('data-original-src', originalSrc);\r\n        \r\n        // 빈 이미지 또는 초소형 플레이스홀더로 대체\r\n        imgElement.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\r\n        \r\n        // 이미지가 다시 보이게 되면 복원하기 위한 Intersection Observer 설정\r\n        const observer = new IntersectionObserver((entries) => {\r\n          entries.forEach(entry => {\r\n            if (entry.isIntersecting) {\r\n              const targetImg = entry.target as HTMLImageElement;\r\n              const originalSrc = targetImg.getAttribute('data-original-src');\r\n              \r\n              if (originalSrc) {\r\n                targetImg.src = originalSrc;\r\n                targetImg.removeAttribute('data-original-src');\r\n                targetImg.setAttribute('data-optimized', 'restored');\r\n              }\r\n              \r\n              observer.disconnect();\r\n            }\r\n          });\r\n        }, { rootMargin: '200px' }); // 뷰포트 주변 200px 영역까지 고려\r\n        \r\n        observer.observe(imgElement);\r\n        imgElement.setAttribute('data-optimized', 'true');\r\n        optimizedCount++;\r\n      }\r\n    }\r\n    \r\n    if (optimizedCount > 0) {\r\n      console.log(`이미지 리소스 최적화 완료: ${optimizedCount}개 이미지 처리됨`);\r\n    }\r\n    \r\n    // 2. 초대형 캔버스 및 SVG 요소 처리\r\n    const heavyElements = document.querySelectorAll('canvas[width][height], svg[width][height]');\r\n    heavyElements.forEach(element => {\r\n      const width = parseInt(element.getAttribute('width') || '0');\r\n      const height = parseInt(element.getAttribute('height') || '0');\r\n      \r\n      // 너무 큰 캔버스/SVG가 메모리를 많이 차지할 수 있음\r\n      if (width * height > 1000000) { // 1M 픽셀 이상\r\n        if (!element.hasAttribute('data-optimized')) {\r\n          // 화면에 보이지 않을 때만 처리\r\n          const rect = element.getBoundingClientRect();\r\n          if (rect.top < -window.innerHeight || rect.bottom > window.innerHeight * 2) {\r\n            element.setAttribute('data-optimized', 'hidden');\r\n            // HTMLElement로 타입 캐스팅하여 style 속성에 접근\r\n            const htmlElement = element as HTMLElement;\r\n            htmlElement.setAttribute('data-original-display', htmlElement.style.display);\r\n            htmlElement.style.display = 'none';\r\n          }\r\n        }\r\n      }\r\n    });\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('이미지 리소스 최적화 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\logger.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'MemoryInfo' is defined but never used.","line":10,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MemoryInfo' is defined but never used.","line":10,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":20},{"ruleId":"no-unused-vars","severity":2,"message":"'DEBUG' is defined but never used.","line":21,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":8},{"ruleId":"no-unused-vars","severity":2,"message":"'INFO' is defined but never used.","line":22,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":7},{"ruleId":"no-unused-vars","severity":2,"message":"'WARN' is defined but never used.","line":23,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":7},{"ruleId":"no-unused-vars","severity":2,"message":"'ERROR' is defined but never used.","line":24,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":8},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":106,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":106,"endColumn":16},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":106,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":106,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"debug"},"fix":{"range":[2168,2237],"text":""},"desc":"Remove the console.debug()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":109,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":109,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":112,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":112,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":115,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":115,"endColumn":16},{"ruleId":"no-unused-vars","severity":2,"message":"'PERIODIC_CHECK' is defined but never used.","line":209,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":209,"endColumn":17},{"ruleId":"no-unused-vars","severity":2,"message":"'GC_REQUEST' is defined but never used.","line":210,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":210,"endColumn":13},{"ruleId":"no-unused-vars","severity":2,"message":"'THRESHOLD_EXCEEDED' is defined but never used.","line":211,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":211,"endColumn":21},{"ruleId":"no-unused-vars","severity":2,"message":"'EMERGENCY_GC' is defined but never used.","line":212,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":212,"endColumn":15},{"ruleId":"no-unused-vars","severity":2,"message":"'LOW_MEMORY_WARNING' is defined but never used.","line":213,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":213,"endColumn":21},{"ruleId":"no-unused-vars","severity":2,"message":"'OPTIMIZATION' is defined but never used.","line":214,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":214,"endColumn":15},{"ruleId":"no-unused-vars","severity":2,"message":"'RESOURCE_RELEASE' is defined but never used.","line":215,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":215,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'STATE_CHANGE' is defined but never used.","line":216,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":216,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":253,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":253,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'memoryLogs' is not defined.","line":268,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":268,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'memoryLogs' is not defined.","line":271,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":271,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'MAX_LOG_ENTRIES' is not defined.","line":271,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":271,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'memoryLogs' is not defined.","line":272,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":272,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":277,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":277,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":289,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":289,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":293,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":293,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":303,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":303,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":309,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":309,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'MEMORY_LOG_DB' is not defined.","line":309,"column":43,"nodeType":"Identifier","messageId":"undef","endLine":309,"endColumn":56},{"ruleId":"no-undef","severity":2,"message":"'IDBOpenDBRequest' is not defined.","line":313,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":313,"endColumn":51},{"ruleId":"no-undef","severity":2,"message":"'INDEXEDDB_STORE' is not defined.","line":316,"column":41,"nodeType":"Identifier","messageId":"undef","endLine":316,"endColumn":56},{"ruleId":"no-undef","severity":2,"message":"'INDEXEDDB_STORE' is not defined.","line":317,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":317,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'IDBOpenDBRequest' is not defined.","line":323,"column":58,"nodeType":"Identifier","messageId":"undef","endLine":323,"endColumn":74},{"ruleId":"no-undef","severity":2,"message":"'IDBOpenDBRequest' is not defined.","line":328,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":328,"endColumn":51},{"ruleId":"no-undef","severity":2,"message":"'INDEXEDDB_STORE' is not defined.","line":332,"column":45,"nodeType":"Identifier","messageId":"undef","endLine":332,"endColumn":60},{"ruleId":"no-undef","severity":2,"message":"'INDEXEDDB_STORE' is not defined.","line":333,"column":47,"nodeType":"Identifier","messageId":"undef","endLine":333,"endColumn":62},{"ruleId":"no-unused-vars","severity":2,"message":"'now' is assigned a value but never used.","line":391,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":391,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'now' is assigned a value but never used.","line":391,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":391,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'memoryLogs' is not defined.","line":392,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":392,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'MemoryUsageStats' is not defined.","line":418,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":418,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'MAX_LOG_ENTRIES' is not defined.","line":507,"column":36,"nodeType":"Identifier","messageId":"undef","endLine":507,"endColumn":51},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":516,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":516,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":517,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":517,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":518,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":518,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":542,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":542,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":543,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":543,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":549,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":549,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":550,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":550,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":556,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":556,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":559,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":559,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":560,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":560,"endColumn":41}],"suppressedMessages":[],"errorCount":49,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 메모리 사용량 로깅 및 분석 유틸리티\r\n * \r\n * 장기적인 메모리 사용 패턴 분석과 최적화 전략 수립에 필요한\r\n * 데이터를 수집하고 저장합니다.\r\n */\r\n\r\nimport { getMemoryInfo } from '../memory-management';\r\nimport { getPerformanceHistory } from '../performance-metrics';\r\nimport { MemoryInfo } from '@/types';\r\nimport { normalizeMemoryInfo } from './format-utils';\r\n\r\n/**\r\n * 메모리 로거 모듈\r\n * \r\n * 메모리 사용량 및 관련 이벤트를 로깅하기 위한 유틸리티\r\n */\r\n\r\n// 로그 레벨 정의\r\nexport enum LogLevel {\r\n  DEBUG = 0,\r\n  INFO = 1,\r\n  WARN = 2,\r\n  ERROR = 3\r\n}\r\n\r\n// 로그 항목 인터페이스\r\nexport interface LogEntry {\r\n  timestamp: number;\r\n  level: LogLevel;\r\n  message: string;\r\n  data?: Record<string, unknown>;\r\n}\r\n\r\n// 로그 설정 인터페이스\r\nexport interface LoggerOptions {\r\n  minLevel?: LogLevel;\r\n  maxLogs?: number;\r\n  printToConsole?: boolean;\r\n  moduleName?: string;\r\n}\r\n\r\n// 기본 로거 옵션\r\nconst DEFAULT_OPTIONS: LoggerOptions = {\r\n  minLevel: LogLevel.INFO,\r\n  maxLogs: 100,\r\n  printToConsole: true,\r\n  moduleName: 'memory'\r\n};\r\n\r\n/**\r\n * 메모리 로거 클래스\r\n */\r\nexport class MemoryLogger {\r\n  private logs: LogEntry[] = [];\r\n  private options: LoggerOptions;\r\n\r\n  constructor(options: LoggerOptions = {}) {\r\n    this.options = { ...DEFAULT_OPTIONS, ...options };\r\n  }\r\n\r\n  /**\r\n   * 로그 기록\r\n   * @param level 로그 레벨\r\n   * @param message 메시지\r\n   * @param data 추가 데이터\r\n   */\r\n  private log(level: LogLevel, message: string, data?: Record<string, unknown>): void {\r\n    // 설정된 최소 레벨보다 낮은 로그는 무시\r\n    if (level < this.options.minLevel!) {\r\n      return;\r\n    }\r\n\r\n    // 로그 항목 생성\r\n    const entry: LogEntry = {\r\n      timestamp: Date.now(),\r\n      level,\r\n      message,\r\n      data\r\n    };\r\n\r\n    // 로그 배열에 추가\r\n    this.logs.push(entry);\r\n\r\n    // 로그 개수 제한\r\n    if (this.logs.length > this.options.maxLogs!) {\r\n      this.logs.shift();\r\n    }\r\n\r\n    // 콘솔 출력 (설정된 경우)\r\n    if (this.options.printToConsole) {\r\n      this.printToConsole(entry);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 콘솔에 로그 출력\r\n   * @param entry 로그 항목\r\n   */\r\n  private printToConsole(entry: LogEntry): void {\r\n    const timestamp = new Date(entry.timestamp).toISOString();\r\n    const prefix = this.options.moduleName ? `[${this.options.moduleName}]` : '';\r\n\r\n    switch (entry.level) {\r\n      case LogLevel.DEBUG:\r\n        console.debug(`${timestamp} ${prefix} ${entry.message}`, entry.data);\r\n        break;\r\n      case LogLevel.INFO:\r\n        console.info(`${timestamp} ${prefix} ${entry.message}`, entry.data);\r\n        break;\r\n      case LogLevel.WARN:\r\n        console.warn(`${timestamp} ${prefix} ${entry.message}`, entry.data);\r\n        break;\r\n      case LogLevel.ERROR:\r\n        console.error(`${timestamp} ${prefix} ${entry.message}`, entry.data);\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 디버그 로그 기록\r\n   * @param message 메시지\r\n   * @param data 추가 데이터\r\n   */\r\n  debug(message: string, data?: Record<string, unknown>): void {\r\n    this.log(LogLevel.DEBUG, message, data);\r\n  }\r\n\r\n  /**\r\n   * 정보 로그 기록\r\n   * @param message 메시지\r\n   * @param data 추가 데이터\r\n   */\r\n  info(message: string, data?: Record<string, unknown>): void {\r\n    this.log(LogLevel.INFO, message, data);\r\n  }\r\n\r\n  /**\r\n   * 경고 로그 기록\r\n   * @param message 메시지\r\n   * @param data 추가 데이터\r\n   */\r\n  warn(message: string, data?: Record<string, unknown>): void {\r\n    this.log(LogLevel.WARN, message, data);\r\n  }\r\n\r\n  /**\r\n   * 오류 로그 기록\r\n   * @param message 메시지\r\n   * @param data 추가 데이터\r\n   */\r\n  error(message: string, data?: Record<string, unknown>): void {\r\n    this.log(LogLevel.ERROR, message, data);\r\n  }\r\n\r\n  /**\r\n   * 모든 로그 가져오기\r\n   */\r\n  getLogs(): LogEntry[] {\r\n    return [...this.logs];\r\n  }\r\n\r\n  /**\r\n   * 특정 레벨 이상의 로그만 가져오기\r\n   * @param level 최소 로그 레벨\r\n   */\r\n  getLogsByLevel(level: LogLevel): LogEntry[] {\r\n    return this.logs.filter(entry => entry.level >= level);\r\n  }\r\n\r\n  /**\r\n   * 오류 로그만 가져오기\r\n   */\r\n  getErrorLogs(): LogEntry[] {\r\n    return this.logs.filter(entry => entry.level === LogLevel.ERROR);\r\n  }\r\n}\r\n\r\n// 기본 로거 인스턴스\r\nexport const memoryLogger = new MemoryLogger();\r\nexport const logger = memoryLogger; // 편의를 위한 별칭\r\n\r\n// 편의성을 위한 기본 함수 내보내기\r\nexport const debug = memoryLogger.debug.bind(memoryLogger);\r\nexport const info = memoryLogger.info.bind(memoryLogger);\r\nexport const warn = memoryLogger.warn.bind(memoryLogger);\r\nexport const error = memoryLogger.error.bind(memoryLogger);\r\n\r\n// 메모리 로그 엔트리 인터페이스\r\nexport interface MemoryLogEntry {\r\n  timestamp: number;\r\n  type: string;\r\n  info: {\r\n    heap_used?: number;\r\n    heap_total?: number;\r\n    heap_limit?: number;\r\n    external?: number;\r\n    heap_used_mb?: number;\r\n    percent_used?: number;\r\n    [key: string]: any;\r\n  };\r\n  tags?: string[];\r\n  sessionId?: string;\r\n  eventType?: string;\r\n}\r\n\r\n// 메모리 이벤트 타입 정의\r\nexport enum MemoryEventType {\r\n  PERIODIC_CHECK = 'periodic_check',\r\n  GC_REQUEST = 'gc_request',\r\n  THRESHOLD_EXCEEDED = 'threshold_exceeded',\r\n  EMERGENCY_GC = 'emergency_gc',\r\n  LOW_MEMORY_WARNING = 'low_memory_warning',\r\n  OPTIMIZATION = 'optimization',\r\n  RESOURCE_RELEASE = 'resource_release',\r\n  STATE_CHANGE = 'state_change'\r\n}\r\n\r\n/**\r\n * 메모리 사용량 로깅\r\n * @param eventType 이벤트 타입\r\n * @param eventDescription 이벤트 설명 (선택)\r\n * @param componentId 컴포넌트 ID (선택)\r\n * @param route 현재 라우트 (선택)\r\n */\r\nexport async function logMemoryUsage(\r\n  eventType: MemoryEventType,\r\n  eventDescription?: string,\r\n  componentId?: string,\r\n  route?: string\r\n): Promise<MemoryLogEntry> {\r\n  // 현재 메모리 정보 가져오기\r\n  const rawMemoryInfo = getMemoryInfo() || {\r\n    heap_used: 0,\r\n    heap_total: 0,\r\n    heap_used_mb: 0,\r\n    heapUsed: 0,\r\n    heapTotal: 0,\r\n    heapUsedMB: 0,\r\n    rss: 0,\r\n    rss_mb: 0,\r\n    rssMB: 0,\r\n    percent_used: 0,\r\n    percentUsed: 0,\r\n    timestamp: Date.now()\r\n  };\r\n  \r\n  // 표준화된 MemoryInfo 인터페이스로 변환\r\n  const standardizedInfo = normalizeMemoryInfo(rawMemoryInfo);\r\n  \r\n  // 현재 라우트 가져오기 (route 매개변수가 없는 경우)\r\n  if (!route && typeof window !== 'undefined') {\r\n    route = window.location.pathname;\r\n  }\r\n  \r\n  // 로그 항목 생성\r\n  const logEntry: MemoryLogEntry = {\r\n    timestamp: Date.now(),\r\n    type: 'memory',\r\n    info: standardizedInfo,\r\n    eventType,\r\n    eventDescription,\r\n    componentId,\r\n    route\r\n  };\r\n  \r\n  // 인메모리 로그에 추가\r\n  memoryLogs.push(logEntry);\r\n  \r\n  // 최대 개수 제한\r\n  if (memoryLogs.length > MAX_LOG_ENTRIES) {\r\n    memoryLogs.shift();\r\n  }\r\n  \r\n  // IndexedDB에 저장 (백그라운드로 실행)\r\n  saveLogToIndexedDB(logEntry).catch(err => \r\n    console.error('메모리 로그 저장 중 오류:', err)\r\n  );\r\n  \r\n  return logEntry;\r\n}\r\n\r\n/**\r\n * 주기적인 메모리 모니터링 시작\r\n * @param intervalMs 체크 간격 (밀리초)\r\n * @returns 모니터링 중지 함수\r\n */\r\nexport function startMemoryMonitoring(intervalMs: number = 60000): () => void {\r\n  const intervalId = setInterval(() => {\r\n    logMemoryUsage(MemoryEventType.PERIODIC_CHECK);\r\n  }, intervalMs);\r\n  \r\n  return () => clearInterval(intervalId);\r\n}\r\n\r\n/**\r\n * IndexedDB에 로그 저장\r\n * @param logEntry 로그 항목\r\n */\r\nasync function saveLogToIndexedDB(logEntry: MemoryLogEntry): Promise<void> {\r\n  return new Promise((resolve, reject) => {\r\n    // IndexedDB가 사용 가능한지 확인\r\n    if (!window.indexedDB) {\r\n      reject(new Error('IndexedDB를 지원하지 않는 브라우저입니다'));\r\n      return;\r\n    }\r\n    \r\n    // 데이터베이스 열기\r\n    const request = window.indexedDB.open(MEMORY_LOG_DB, 1);\r\n    \r\n    // 데이터베이스 생성/업그레이드 이벤트\r\n    request.onupgradeneeded = (event) => {\r\n      const db = (event.target as IDBOpenDBRequest).result;\r\n      \r\n      // 객체 저장소가 없으면 생성\r\n      if (!db.objectStoreNames.contains(INDEXEDDB_STORE)) {\r\n        db.createObjectStore(INDEXEDDB_STORE, { keyPath: 'timestamp' });\r\n      }\r\n    };\r\n    \r\n    // 오류 처리\r\n    request.onerror = (event) => {\r\n      reject(new Error(`IndexedDB 오류: ${(event.target as IDBOpenDBRequest).error}`));\r\n    };\r\n    \r\n    // 성공 처리\r\n    request.onsuccess = (event) => {\r\n      const db = (event.target as IDBOpenDBRequest).result;\r\n      \r\n      try {\r\n        // 트랜잭션 시작\r\n        const transaction = db.transaction([INDEXEDDB_STORE], 'readwrite');\r\n        const store = transaction.objectStore(INDEXEDDB_STORE);\r\n        \r\n        // 로그 항목 저장\r\n        const addRequest = store.add(logEntry);\r\n        \r\n        addRequest.onsuccess = () => {\r\n          resolve();\r\n        };\r\n        \r\n        addRequest.onerror = () => {\r\n          reject(new Error(`로그 항목 저장 실패: ${addRequest.error}`));\r\n        };\r\n        \r\n        // 트랜잭션 완료 이벤트\r\n        transaction.oncomplete = () => {\r\n          db.close();\r\n        };\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\n/**\r\n * 저장된 메모리 로그 가져오기\r\n * \r\n        \r\n        addRequest.onerror = () => {\r\n          reject(new Error(`로그 항목 저장 실패: ${addRequest.error}`));\r\n        };\r\n        \r\n        // 트랜잭션 완료 이벤트\r\n        transaction.oncomplete = () => {\r\n          db.close();\r\n        };\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\n/**\r\n * 저장된 메모리 로그 가져오기\r\n * @param limit 가져올 최대 항목 수\r\n * @param startTime 시작 시간 (밀리초)\r\n * @param endTime 종료 시간 (밀리초)\r\n * @param eventTypes 필터링할 이벤트 타입 배열\r\n * @returns 로그 항목 배열\r\n */\r\nexport async function getMemoryLogs(\r\n  limit: number = 100,\r\n  startTime?: number,\r\n  endTime?: number,\r\n  eventTypes?: MemoryEventType[]\r\n): Promise<MemoryLogEntry[]> {\r\n  // 시간 기준 필터링\r\n  const now = Date.now();\r\n  const filteredByTime = memoryLogs.filter(log => {\r\n    if (startTime && log.timestamp < startTime) return false;\r\n    if (endTime && log.timestamp > endTime) return false;\r\n    return true;\r\n  });\r\n  \r\n  // 이벤트 타입 기준 필터링\r\n  const filtered = eventTypes \r\n    ? filteredByTime.filter(log => eventTypes.includes(log.eventType))\r\n    : filteredByTime;\r\n  \r\n  // 최신 순으로 정렬하고 제한된 개수 반환\r\n  return filtered\r\n    .sort((a, b) => b.timestamp - a.timestamp)\r\n    .slice(0, limit);\r\n}\r\n\r\n/**\r\n * 메모리 사용 통계 분석\r\n * @param startTime 시작 시간 (밀리초)\r\n * @param endTime 종료 시간 (밀리초)\r\n * @returns 메모리 사용 통계\r\n */\r\nexport async function analyzeMemoryUsage(\r\n  startTime: number = Date.now() - 24 * 60 * 60 * 1000, // 기본: 24시간\r\n  endTime: number = Date.now()\r\n): Promise<MemoryUsageStats> {\r\n  // 지정된 기간의 로그 가져오기\r\n  const logs = await getMemoryLogs(1000, startTime, endTime);\r\n  \r\n  if (logs.length === 0) {\r\n    throw new Error('분석할 메모리 로그가 없습니다');\r\n  }\r\n  \r\n  // 기본 통계 계산\r\n  const usages = logs.map(log => log.info.heap_used_mb || 0);\r\n  const avgUsage = usages.reduce((sum, usage) => sum + usage, 0) / usages.length;\r\n  const peakUsage = Math.max(...usages);\r\n  const minUsage = Math.min(...usages);\r\n  const lastUsage = usages[0]; // 최신 로그가 첫 번째\r\n  \r\n  // 시간별 사용량\r\n  const usageOverTime = logs.map(log => ({\r\n    timestamp: log.timestamp,\r\n    usageMB: log.info.heap_used_mb || 0\r\n  })).sort((a, b) => a.timestamp - b.timestamp);\r\n  \r\n  // 최적화 이벤트 추출\r\n  const optimizationEvents = logs\r\n    .filter(log => log.eventType === MemoryEventType.OPTIMIZATION)\r\n    .map(log => {\r\n      // 최적화 전후 메모리 차이 계산 (이전 로그와 비교)\r\n      const index = logs.indexOf(log);\r\n      const prevLog = logs[index + 1]; // 역순 정렬이므로 다음 인덱스가 이전 로그\r\n      const freedMemory = prevLog \r\n        ? (prevLog.info.heap_used_mb || 0) - (log.info.heap_used_mb || 0)\r\n        : 0;\r\n        \r\n      return {\r\n        timestamp: log.timestamp,\r\n        freedMemory: Math.max(0, freedMemory) // 음수인 경우 0으로 처리\r\n      };\r\n    });\r\n  \r\n  // GC 이벤트 추출\r\n  const gcEvents = logs\r\n    .filter(log => log.eventType === MemoryEventType.GARBAGE_COLLECTION)\r\n    .map(log => {\r\n      // GC 전후 메모리 차이 계산\r\n      const index = logs.indexOf(log);\r\n      const prevLog = logs[index + 1];\r\n      const freedMemory = prevLog \r\n        ? (prevLog.info.heap_used_mb || 0) - (log.info.heap_used_mb || 0)\r\n        : 0;\r\n        \r\n      return {\r\n        timestamp: log.timestamp,\r\n        freedMemory: Math.max(0, freedMemory)\r\n      };\r\n    });\r\n  \r\n  // 메모리 누수 의심 컴포넌트 분석\r\n  const componentMounts = logs.filter(log => \r\n    log.eventType === MemoryEventType.COMPONENT_MOUNT && log.componentId\r\n  );\r\n  \r\n  const componentCounts: Record<string, number> = {};\r\n  for (const log of componentMounts) {\r\n    const id = log.componentId!;\r\n    componentCounts[id] = (componentCounts[id] || 0) + 1;\r\n  }\r\n  \r\n  // 누수 의심 컴포넌트 (상위 10개)\r\n  const leakSuspects = Object.entries(componentCounts)\r\n    .map(([componentId, frequency]) => ({ componentId, frequency }))\r\n    .sort((a, b) => b.frequency - a.frequency)\r\n    .slice(0, 10);\r\n  \r\n  return {\r\n    averageUsage: avgUsage,\r\n    peakUsage,\r\n    minUsage,\r\n    lastUsage,\r\n    usageOverTime,\r\n    optimizationEvents,\r\n    gcEvents,\r\n    leakSuspects\r\n  };\r\n}\r\n\r\n/**\r\n * 메모리 로그 내보내기 (JSON)\r\n * @returns JSON 문자열\r\n */\r\nexport async function exportMemoryLogs(): Promise<string> {\r\n  const logs = await getMemoryLogs(MAX_LOG_ENTRIES);\r\n  const performanceData = getPerformanceHistory();\r\n  \r\n  const exportData = {\r\n    logs,\r\n    performanceHistory: performanceData,\r\n    exportTimestamp: Date.now(),\r\n    appVersion: '1.0.0', // 앱 버전\r\n    systemInfo: {\r\n      userAgent: navigator.userAgent,\r\n      platform: navigator.platform,\r\n      language: navigator.language\r\n    }\r\n  };\r\n  \r\n  return JSON.stringify(exportData, null, 2);\r\n}\r\n\r\n/**\r\n * 메모리 자동 로그 설정\r\n * 주요 이벤트에 대한 메모리 로깅을 자동화합니다.\r\n */\r\nexport function setupAutomaticMemoryLogging(): () => void {\r\n  const cleanupFunctions: Array<() => void> = [];\r\n  \r\n  // 주기적 모니터링 시작\r\n  const stopMonitoring = startMemoryMonitoring(60000); // 1분마다\r\n  cleanupFunctions.push(stopMonitoring);\r\n  \r\n  // 페이지 탐색 추적\r\n  if (typeof window !== 'undefined') {\r\n    // 페이지 로드 시\r\n    const handleLoad = () => {\r\n      logMemoryUsage(MemoryEventType.PAGE_NAVIGATION, 'Page loaded');\r\n    };\r\n    window.addEventListener('load', handleLoad);\r\n    cleanupFunctions.push(() => window.removeEventListener('load', handleLoad));\r\n    \r\n    // 페이지 언로드 시\r\n    const handleBeforeUnload = () => {\r\n      logMemoryUsage(MemoryEventType.PAGE_NAVIGATION, 'Page unloaded');\r\n    };\r\n    window.addEventListener('beforeunload', handleBeforeUnload);\r\n    cleanupFunctions.push(() => window.removeEventListener('beforeunload', handleBeforeUnload));\r\n    \r\n    // 가시성 변경 시\r\n    const handleVisibilityChange = () => {\r\n      logMemoryUsage(\r\n        MemoryEventType.PAGE_NAVIGATION, \r\n        `Visibility changed: ${document.visibilityState}`\r\n      );\r\n    };\r\n    document.addEventListener('visibilitychange', handleVisibilityChange);\r\n    cleanupFunctions.push(() => document.removeEventListener('visibilitychange', handleVisibilityChange));\r\n  }\r\n  \r\n  // 모든 정리 함수를 호출하는 함수 반환\r\n  return () => {\r\n    cleanupFunctions.forEach(cleanup => cleanup());\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\memory-info.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":22,"column":43,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":54},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":22,"column":60,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":71},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":26,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":26,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":47,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":47,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":79,"column":42,"nodeType":"Identifier","messageId":"undef","endLine":79,"endColumn":48},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":80,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":80,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":86,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":86,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":102,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":102,"endColumn":12}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 메모리 정보 유틸리티\r\n * \r\n * 브라우저 및 시스템 메모리 정보를 제공합니다.\r\n */\r\nimport { MemoryInfo } from '@/types';\r\nimport { requestNativeMemoryInfo } from '../native-memory-bridge';\r\n\r\n// 브라우저 메모리 성능 API를 위한 타입 확장\r\ninterface PerformanceMemory {\r\n  usedJSHeapSize: number;\r\n  totalJSHeapSize: number;\r\n  jsHeapSizeLimit: number;\r\n}\r\n\r\n/**\r\n * 현재 메모리 사용량 가져오기\r\n */\r\nexport async function getMemoryUsage(): Promise<MemoryInfo | null> {\r\n  try {\r\n    // 브라우저에서 사용 가능한 메모리 API 사용\r\n    if (typeof window === 'undefined' || !performance || !(performance as any).memory) {\r\n      return createEstimatedMemoryInfo();\r\n    }\r\n    \r\n    const memory = (performance as any).memory as PerformanceMemory;\r\n    \r\n    const heap_used = memory.usedJSHeapSize;\r\n    const heap_total = memory.totalJSHeapSize;\r\n    const heap_limit = memory.jsHeapSizeLimit;\r\n    const percent_used = (heap_used / heap_total) * 100;\r\n    \r\n    // RSS 추정 (정확한 값을 얻을 수 없으므로 힙 크기의 1.5배로 추정)\r\n    const rss = Math.round(heap_total * 1.5);\r\n    \r\n    return {\r\n      heap_used,\r\n      heap_total,\r\n      heap_limit,\r\n      heap_used_mb: heap_used / (1024 * 1024),\r\n      percent_used,\r\n      rss,\r\n      rss_mb: rss / (1024 * 1024),\r\n      timestamp: Date.now()\r\n    };\r\n  } catch (err) {\r\n    console.error('메모리 정보 가져오기 오류:', err);\r\n    return createEstimatedMemoryInfo();\r\n  }\r\n}\r\n\r\n/**\r\n * 추정 메모리 정보 생성\r\n * 브라우저가 메모리 API를 지원하지 않을 때 호출됩니다.\r\n */\r\nfunction createEstimatedMemoryInfo(): MemoryInfo {\r\n  // 추정치로 기본값 제공\r\n  const estimatedHeapUsed = 50 * 1024 * 1024; // 50MB\r\n  const estimatedHeapTotal = 100 * 1024 * 1024; // 100MB\r\n  \r\n  return {\r\n    heap_used: estimatedHeapUsed,\r\n    heap_total: estimatedHeapTotal,\r\n    heap_limit: estimatedHeapTotal * 2,\r\n    heap_used_mb: Math.round(estimatedHeapUsed / (1024 * 1024) * 10) / 10,\r\n    rss: Math.round(estimatedHeapTotal * 1.5),\r\n    rss_mb: Math.round(estimatedHeapTotal * 1.5 / (1024 * 1024) * 10) / 10,\r\n    percent_used: 50,\r\n    timestamp: Date.now()\r\n  };\r\n}\r\n\r\n/**\r\n * 네이티브 모듈을 통한 메모리 정보 가져오기\r\n */\r\nexport async function getNativeMemoryInfo(): Promise<MemoryInfo | null> {\r\n  try {\r\n    // 네이티브 모듈 연동 함수 호출\r\n    if (typeof window !== 'undefined' && window.__memoryOptimizer?.getMemoryInfo) {\r\n      return await window.__memoryOptimizer.getMemoryInfo();\r\n    }\r\n    \r\n    // 네이티브 모듈 사용 불가능한 경우 브라우저 정보 반환\r\n    return getMemoryUsage();\r\n  } catch (error) {\r\n    console.error('네이티브 메모리 정보 가져오기 오류:', error);\r\n    return getMemoryUsage();\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 정보 가져오기 (MemoryMonitor 컴포넌트와의 호환성을 위한 함수)\r\n */\r\nexport async function getMemoryInfo(): Promise<MemoryInfo> {\r\n  // 네이티브 브리지를 통한 요청 시도\r\n  try {\r\n    const response = await requestNativeMemoryInfo();\r\n    if (response && response.success) {\r\n      return response;\r\n    }\r\n  } catch (e) {\r\n    console.error('Native memory info request failed:', e);\r\n  }\r\n\r\n  // 실패 시 브라우저 메모리 정보 반환\r\n  const memoryInfo = await getMemoryUsage();\r\n  return memoryInfo || createEstimatedMemoryInfo();\r\n}\r\n\r\n/**\r\n * 메모리 정보 포맷팅 함수\r\n */\r\nexport function formatMemoryInfo(info: MemoryInfo): string {\r\n  if (!info) return 'Memory info not available';\r\n  \r\n  const usedMB = info.heap_used_mb.toFixed(1);\r\n  const totalMB = (info.heap_total / (1024 * 1024)).toFixed(1);\r\n  const percent = info.percent_used.toFixed(1);\r\n  \r\n  return `Memory: ${usedMB}MB / ${totalMB}MB (${percent}%)`;\r\n}\r\n\r\n/**\r\n * 메모리 상태 평가\r\n */\r\nexport function assessMemoryState(memoryInfo: MemoryInfo): 'normal' | 'warning' | 'critical' {\r\n  const percentUsed = memoryInfo.percent_used;\r\n  \r\n  if (percentUsed > 85) {\r\n    return 'critical';\r\n  } else if (percentUsed > 70) {\r\n    return 'warning';\r\n  }\r\n  \r\n  return 'normal';\r\n}\r\n\r\n/**\r\n * 네이티브 메모리 정보를 앱 형식으로 변환\r\n */\r\nexport function convertNativeMemoryInfo(nativeInfo: any): MemoryInfo {\r\n  return {\r\n    heap_used: nativeInfo.heap_used || 0,\r\n    heap_total: nativeInfo.heap_total || 0,\r\n    heap_limit: nativeInfo.heap_limit || 0,\r\n    heap_used_mb: nativeInfo.heap_used_mb || 0,\r\n    percent_used: nativeInfo.percent_used || 0,\r\n    rss: nativeInfo.rss || 0,\r\n    rss_mb: nativeInfo.rss_mb || 0,\r\n    timestamp: nativeInfo.timestamp || Date.now()\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\optimization-utils.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'OptimizationResult' is defined but never used.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'OptimizationResult' is defined but never used.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":37,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":37,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":38,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":38,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":43,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":43,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":43,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":43,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":44,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":44,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":62,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":62,"endColumn":12},{"ruleId":"no-unused-vars","severity":2,"message":"'isVisible' is defined but never used.","line":164,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":164,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":171,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":171,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":179,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":179,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":182,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":182,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":183,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":183,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":191,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":191,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":195,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":195,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":199,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":199,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":203,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":203,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":205,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":205,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":207,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":207,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":212,"column":42,"nodeType":"Identifier","messageId":"undef","endLine":212,"endColumn":53},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":213,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":213,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'HTMLElement' is not defined.","line":216,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":216,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":225,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":225,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":236,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":236,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":237,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":237,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":239,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":239,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":244,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":244,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":249,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":249,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":250,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":250,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":256,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":256,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":268,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":268,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":269,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":269,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'cancelAnimationFrame' is not defined.","line":270,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":270,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":272,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":272,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":277,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":277,"endColumn":12}],"suppressedMessages":[],"errorCount":34,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 메모리 최적화 유틸리티\r\n */\r\n\r\nimport { MemoryInfo } from '@/types';\r\nimport { OptimizationResult } from '@/types/native-module';\r\n\r\n// MemoryInfo 인터페이스에 error 속성 추가\r\nexport interface MemoryInfoWithError extends MemoryInfo {\r\n  error?: string;\r\n}\r\n\r\n// 메모리 정보 변환 유틸리티\r\nexport function convertNativeMemoryInfo(nativeInfo: any): Partial<MemoryInfo> {\r\n  if (!nativeInfo) return {};\r\n\r\n  return {\r\n    heapUsed: nativeInfo.heap_used || 0,\r\n    heapTotal: nativeInfo.heap_total || 0,\r\n    heapLimit: nativeInfo.heap_limit,\r\n    heapUsedMB: nativeInfo.heap_used_mb || 0,\r\n    rss: nativeInfo.rss,\r\n    rssMB: nativeInfo.rss_mb,\r\n    percentUsed: nativeInfo.percent_used || 0,\r\n    timestamp: nativeInfo.timestamp || Date.now(),\r\n  };\r\n}\r\n\r\n// 메모리 정보 가져오기\r\nexport async function getMemoryInfoAsync(): Promise<Partial<MemoryInfo>> {\r\n  if (typeof window === 'undefined') {\r\n    return {};\r\n  }\r\n  \r\n  try {\r\n    // 네이티브 모듈에서 정보 가져오기\r\n    if (window.__memoryOptimizer?.getMemoryInfo) {\r\n      const nativeInfo = await window.__memoryOptimizer.getMemoryInfo();\r\n      return await Promise.resolve(convertNativeMemoryInfo(nativeInfo));\r\n    }\r\n    \r\n    // 브라우저 performance API 사용\r\n    if (performance && (performance as any).memory) {\r\n      const mem = (performance as any).memory;\r\n      \r\n      const result: Partial<MemoryInfo> = {\r\n        heapUsed: mem.usedJSHeapSize,\r\n        heapTotal: mem.totalJSHeapSize,\r\n        heapLimit: mem.jsHeapSizeLimit,\r\n        heapUsedMB: mem.usedJSHeapSize / (1024 * 1024),\r\n        percentUsed: (mem.usedJSHeapSize / mem.totalJSHeapSize) * 100,\r\n        timestamp: Date.now()\r\n      };\r\n      \r\n      return result;\r\n    }\r\n    \r\n    return {\r\n      timestamp: Date.now()\r\n    };\r\n  } catch (error) {\r\n    console.error('메모리 정보 가져오기 실패:', error);\r\n    return {\r\n      timestamp: Date.now(),\r\n      error: String(error)\r\n    } as MemoryInfoWithError;\r\n  }\r\n}\r\n\r\n// OptimizationLevel 열거형을 값으로 사용할 수 있도록 상수로 선언\r\nexport const OptimizationLevelValues = {\r\n  NONE: 0,\r\n  LOW: 1,\r\n  MEDIUM: 2,\r\n  HIGH: 3,\r\n  EXTREME: 4\r\n};\r\n\r\n// 안전한 최적화 레벨 확인\r\nexport function safeOptimizationLevel(level: number | string | undefined): number {\r\n  if (level === undefined) {\r\n    return OptimizationLevelValues.NONE;\r\n  }\r\n  \r\n  // 문자열인 경우 숫자로 변환 시도\r\n  if (typeof level === 'string') {\r\n    const numLevel = parseInt(level, 10);\r\n    if (!isNaN(numLevel)) {\r\n      level = numLevel;\r\n    } else {\r\n      // 열거형 문자열 매핑\r\n      switch (level.toUpperCase()) {\r\n        case 'NONE': return OptimizationLevelValues.NONE;\r\n        case 'LOW': return OptimizationLevelValues.LOW;\r\n        case 'MEDIUM': return OptimizationLevelValues.MEDIUM;\r\n        case 'HIGH': return OptimizationLevelValues.HIGH;\r\n        case 'EXTREME': return OptimizationLevelValues.EXTREME;\r\n        default: return OptimizationLevelValues.NONE;\r\n      }\r\n    }\r\n  }\r\n  \r\n  // 숫자로 처리\r\n  const numLevel = Number(level);\r\n  \r\n  if (numLevel < OptimizationLevelValues.NONE) {\r\n    return OptimizationLevelValues.NONE;\r\n  }\r\n  \r\n  if (numLevel > OptimizationLevelValues.EXTREME) {\r\n    return OptimizationLevelValues.EXTREME;\r\n  }\r\n  \r\n  return numLevel;\r\n}\r\n\r\n// 네이티브 최적화 레벨로 변환\r\nexport function toNativeOptimizationLevel(level: number): number {\r\n  const safeLevel = safeOptimizationLevel(level);\r\n  \r\n  switch (safeLevel) {\r\n    case OptimizationLevelValues.NONE: return 0;\r\n    case OptimizationLevelValues.LOW: return 1;\r\n    case OptimizationLevelValues.MEDIUM: return 2;\r\n    case OptimizationLevelValues.HIGH: return 3;\r\n    case OptimizationLevelValues.EXTREME: return 4;\r\n    default: return 0;\r\n  }\r\n}\r\n\r\n/**\r\n * 현재 메모리 사용량 기준으로 최적화 레벨 결정\r\n */\r\nexport async function determineOptimizationLevel(): Promise<number> {\r\n  const memoryInfo = await getMemoryInfoAsync();\r\n  const percentUsed = memoryInfo.percentUsed || 0;\r\n  \r\n  // 문자열을 숫자로 명시적 변환\r\n  const percent = Number(percentUsed);\r\n  \r\n  if (percent >= 90) {\r\n    return OptimizationLevelValues.EXTREME;\r\n  }\r\n  \r\n  if (percent >= 75) {\r\n    return OptimizationLevelValues.HIGH;\r\n  }\r\n  \r\n  if (percent >= 60) {\r\n    return OptimizationLevelValues.MEDIUM;\r\n  }\r\n  \r\n  if (percent >= 40) {\r\n    return OptimizationLevelValues.LOW;\r\n  }\r\n  \r\n  return OptimizationLevelValues.NONE;\r\n}\r\n\r\n/**\r\n * 브라우저의 가시성 상태에 따른 메모리 최적화\r\n */\r\nexport function setupVisibilityBasedOptimization(\r\n  onVisibilityChange?: (isVisible: boolean) => void\r\n): () => void {\r\n  if (typeof document === 'undefined') {\r\n    return () => {};\r\n  }\r\n\r\n  const handleVisibilityChange = () => {\r\n    const isVisible = document.visibilityState === 'visible';\r\n    \r\n    if (onVisibilityChange) {\r\n      onVisibilityChange(isVisible);\r\n    }\r\n    \r\n    if (!isVisible) {\r\n      // 페이지가 숨겨진 경우 메모리 최적화 수행\r\n      setTimeout(async () => {\r\n        const level = await determineOptimizationLevel();\r\n        if (level > OptimizationLevelValues.NONE) {\r\n          if (window.__memoryOptimizer?.optimizeMemory) {\r\n            window.__memoryOptimizer.optimizeMemory(level >= OptimizationLevelValues.HIGH);\r\n          }\r\n        }\r\n      }, 500);\r\n    }\r\n  };\r\n\r\n  // 여러 브라우저 접두사 지원\r\n  document.addEventListener('visibilitychange', handleVisibilityChange);\r\n  \r\n  // MS 접두사 이벤트 (cSpell 경고 무시)\r\n  /* cspell:disable-next-line */\r\n  document.addEventListener('msvisibilitychange', handleVisibilityChange);\r\n  \r\n  // Webkit 접두사 이벤트 (cSpell 경고 무시)\r\n  /* cspell:disable-next-line */\r\n  document.addEventListener('webkitvisibilitychange', handleVisibilityChange);\r\n\r\n  // 정리 함수 반환\r\n  return () => {\r\n    document.removeEventListener('visibilitychange', handleVisibilityChange);\r\n    /* cspell:disable-next-line */\r\n    document.removeEventListener('msvisibilitychange', handleVisibilityChange);\r\n    /* cspell:disable-next-line */\r\n    document.removeEventListener('webkitvisibilitychange', handleVisibilityChange);\r\n  };\r\n}\r\n\r\n// DOM 정리 함수\r\nexport function cleanupDom(rootElement?: HTMLElement): void {\r\n  const root = rootElement || document.body;\r\n  \r\n  // 메모리 누수 방지를 위한 참조 정리\r\n  const cleanElement = (element: HTMLElement) => {\r\n    // 이벤트 리스너 정리\r\n    const clonedElement = element.cloneNode(false);\r\n    if (element.parentNode) {\r\n      element.parentNode.replaceChild(clonedElement, element);\r\n    }\r\n  };\r\n  \r\n  // 선택적으로 DOM 요소 정리\r\n  if (root !== document.body) {\r\n    cleanElement(root);\r\n  }\r\n}\r\n\r\n// 캐시 정리 함수\r\nexport function cleanupCache(): boolean {\r\n  let success = false;\r\n  \r\n  try {\r\n    // Object URL 캐시 정리\r\n    if (window.__objectUrls) {\r\n      window.__objectUrls.forEach(url => {\r\n        try {\r\n          URL.revokeObjectURL(url);\r\n        } catch (e) {\r\n          // 무시\r\n        }\r\n      });\r\n      window.__objectUrls.clear();\r\n      success = true;\r\n    }\r\n    \r\n    // 이미지 리사이즈 캐시 정리\r\n    if (window.__imageResizeCache) {\r\n      window.__imageResizeCache = new Map();\r\n      success = true;\r\n    }\r\n    \r\n    return success;\r\n  } catch (e) {\r\n    console.error('캐시 정리 중 오류 발생:', e);\r\n    return false;\r\n  }\r\n}\r\n\r\n// 리소스 최적화 함수\r\nexport function optimizeResources(): boolean {\r\n  cleanupCache();\r\n  \r\n  // 추가 최적화 로직\r\n  try {\r\n    // 비활성 애니메이션 정리\r\n    if (window.__animationFrameIds) {\r\n      window.__animationFrameIds.forEach(id => {\r\n        cancelAnimationFrame(id);\r\n      });\r\n      window.__animationFrameIds = [];\r\n    }\r\n    \r\n    return true;\r\n  } catch (e) {\r\n    console.error('리소스 최적화 중 오류 발생:', e);\r\n    return false;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\optimizer.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'NativeOptimizationLevel' is defined but never used.","line":11,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":54},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NativeOptimizationLevel' is defined but never used.","line":11,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":54},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":32,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":32,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":40,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":40,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":41,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":41,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":46,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":46,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":70,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":12}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 메모리 최적화 코어 유틸리티\r\n * \r\n * 이 모듈은 네이티브 모듈 기반 최적화 함수를 제공합니다.\r\n * 모든 최적화 작업은 Rust로 구현된 네이티브 모듈을 통해 수행됩니다.\r\n */\r\n\r\nimport { requestNativeMemoryOptimization } from '../native-memory-bridge';\r\nimport { suggestGarbageCollection, requestGC } from './gc-utils';\r\nimport { OptimizationLevel as AppOptimizationLevel } from '@/types';\r\nimport { OptimizationLevel as NativeOptimizationLevel } from '@/types/native-module';\r\nimport { toNativeOptimizationLevel } from '../enum-converters';\r\n\r\n/**\r\n * 메모리 최적화 수행 함수 (내부 구현)\r\n * 네이티브 모듈을 통해 메모리 최적화를 수행합니다.\r\n * \r\n * @param {boolean} aggressive 적극적 최적화 여부\r\n * @returns {Promise<boolean>} 성공 여부\r\n */\r\nexport async function internalOptimizeMemory(aggressive: boolean = false): Promise<boolean> {\r\n  try {\r\n    // 적절한 최적화 레벨 선택\r\n    const appLevel = aggressive ? AppOptimizationLevel.HIGH : AppOptimizationLevel.MEDIUM;\r\n    // 명시적 변환 함수 사용\r\n    const nativeLevel = toNativeOptimizationLevel(appLevel);\r\n    \r\n    // 네이티브 모듈 최적화 호출\r\n    const result = await requestNativeMemoryOptimization(nativeLevel, aggressive);\r\n    \r\n    if (!result) {\r\n      console.warn('네이티브 메모리 최적화 실패');\r\n      return false;\r\n    }\r\n    \r\n    // 브라우저에 GC 힌트 제공\r\n    suggestGarbageCollection();\r\n    \r\n    // Electron 메인 프로세스에 메모리 최적화 요청 (지원되는 경우)\r\n    if (window.electronAPI && window.electronAPI.optimizeMemory) {\r\n      window.electronAPI.optimizeMemory(aggressive);\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('메모리 최적화 중 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 최적화 수행 함수 (공개 API)\r\n * \r\n * @param {boolean} deepCleanup 심층 정리 여부\r\n * @returns {Promise<boolean>} 성공 여부\r\n */\r\nexport async function optimizeMemory(deepCleanup = false): Promise<boolean> {\r\n  try {\r\n    // 적극적인 플래그 설정\r\n    const aggressive = deepCleanup;\r\n    \r\n    // 내부 최적화 함수 호출\r\n    const result = await internalOptimizeMemory(aggressive);\r\n    \r\n    // GC 요청\r\n    await requestGC(deepCleanup);\r\n    \r\n    return result;\r\n  } catch (error) {\r\n    console.error('메모리 최적화 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\pool\\memory-pool.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'obj' is defined but never used.","line":13,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":32,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":32,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":55,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":55,"endColumn":12},{"ruleId":"no-unused-vars","severity":2,"message":"'obj' is defined but never used.","line":86,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":86,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":120,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":120,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":120,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":120,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2463,2530],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":145,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":145,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":145,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":145,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3059,3098],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 메모리 풀 관리 유틸리티\r\n * \r\n * 객체 생성 및 파괴로 인한 메모리 단편화와 GC 부하를 줄이기 위한\r\n * 객체 풀링 메커니즘을 제공합니다.\r\n */\r\n\r\n// 메모리 풀 인터페이스\r\ninterface MemoryPool<T> {\r\n  name: string;\r\n  pool: T[];\r\n  createObject: () => T;\r\n  resetObject?: (obj: T) => void;\r\n  maxSize: number;\r\n  lastUsed: number;\r\n}\r\n\r\n// 전역 메모리 풀 저장소\r\nexport const memoryPools: Map<string, MemoryPool<any>> = new Map();\r\n\r\n// 마지막 풀 정리 시간\r\nlet lastPoolCleanup = Date.now();\r\n\r\n/**\r\n * 메모리 풀에서 객체 가져오기\r\n * @param poolName 풀 이름\r\n * @returns 풀에서 가져온 객체\r\n */\r\nexport function acquireFromPool<T>(poolName: string): T {\r\n  // 풀이 없으면 생성\r\n  if (!memoryPools.has(poolName)) {\r\n    console.warn(`메모리 풀 \"${poolName}\"이 존재하지 않습니다. 기본 풀을 생성합니다.`);\r\n    createPool(poolName, () => ({} as T), { maxSize: 50 });\r\n  }\r\n  \r\n  const pool = memoryPools.get(poolName)!;\r\n  pool.lastUsed = Date.now();\r\n  \r\n  // 풀에 객체가 있으면 반환\r\n  if (pool.pool.length > 0) {\r\n    return pool.pool.pop()!;\r\n  }\r\n  \r\n  // 풀이 비어있으면 새 객체 생성\r\n  return pool.createObject();\r\n}\r\n\r\n/**\r\n * 객체를 메모리 풀에 반환\r\n * @param poolName 풀 이름\r\n * @param obj 반환할 객체\r\n */\r\nexport function releaseToPool<T>(poolName: string, obj: T): void {\r\n  if (!memoryPools.has(poolName)) {\r\n    console.warn(`메모리 풀 \"${poolName}\"이 존재하지 않습니다. 객체는 폐기됩니다.`);\r\n    return;\r\n  }\r\n  \r\n  const pool = memoryPools.get(poolName)!;\r\n  pool.lastUsed = Date.now();\r\n  \r\n  // 풀 크기가 최대 크기보다 작으면 객체 추가\r\n  if (pool.pool.length < pool.maxSize) {\r\n    // 객체 초기화 함수가 있으면 호출\r\n    if (pool.resetObject) {\r\n      pool.resetObject(obj);\r\n    }\r\n    \r\n    // 풀에 객체 추가\r\n    pool.pool.push(obj);\r\n  }\r\n  // 풀이 가득 찬 경우 객체는 자동으로 폐기됨\r\n}\r\n\r\n/**\r\n * 새 메모리 풀 생성\r\n * @param name 풀 이름\r\n * @param createFn 객체 생성 함수\r\n * @param options 풀 옵션\r\n */\r\nexport function createPool<T>(\r\n  name: string,\r\n  createFn: () => T,\r\n  options: {\r\n    maxSize?: number;\r\n    resetFn?: (obj: T) => void;\r\n    prealloc?: number;\r\n  } = {}\r\n): void {\r\n  // 기본값 설정\r\n  const maxSize = options.maxSize || 100;\r\n  const prealloc = options.prealloc || 0;\r\n  \r\n  // 풀 생성\r\n  const pool: MemoryPool<T> = {\r\n    name,\r\n    pool: [],\r\n    createObject: createFn,\r\n    resetObject: options.resetFn,\r\n    maxSize,\r\n    lastUsed: Date.now()\r\n  };\r\n  \r\n  // 사전 할당\r\n  if (prealloc > 0) {\r\n    for (let i = 0; i < Math.min(prealloc, maxSize); i++) {\r\n      pool.pool.push(createFn());\r\n    }\r\n  }\r\n  \r\n  // 풀 저장\r\n  memoryPools.set(name, pool);\r\n}\r\n\r\n/**\r\n * 모든 풀에서 메모리 객체 해제\r\n */\r\nexport function releaseAllPooledObjects(): void {\r\n  memoryPools.forEach(pool => {\r\n    console.log(`메모리 풀 \"${pool.name}\" 정리: ${pool.pool.length}개 객체 해제`);\r\n    pool.pool.length = 0;\r\n  });\r\n}\r\n\r\n/**\r\n * 오래된 메모리 풀 정리\r\n * 일정 시간 사용되지 않은 풀 정리\r\n * @param maxIdleTime 최대 유휴 시간 (밀리초)\r\n */\r\nexport function cleanupIdlePools(maxIdleTime: number = 5 * 60 * 1000): void {\r\n  const now = Date.now();\r\n  \r\n  // 너무 자주 실행되지 않도록 제한\r\n  if (now - lastPoolCleanup < 60000) {\r\n    return;\r\n  }\r\n  \r\n  lastPoolCleanup = now;\r\n  \r\n  memoryPools.forEach((pool, name) => {\r\n    if (now - pool.lastUsed > maxIdleTime) {\r\n      // 오래된 풀 정리\r\n      pool.pool.length = 0;\r\n      memoryPools.delete(name);\r\n      console.log(`오래된 메모리 풀 \"${name}\" 제거됨`);\r\n    }\r\n  });\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\storage-cleaner.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":15,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":15,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":16,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":22,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":24,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":24,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":34,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":35,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":35,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":37,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":37,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":43,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":43,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'caches' is not defined.","line":44,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":44,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'caches' is not defined.","line":47,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":47,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":53,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":53,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":64,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":64,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":67,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":67,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":68,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":68,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'sessionStorage' is not defined.","line":74,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":74,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":77,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":77,"endColumn":12}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 스토리지 정리 관련 유틸리티\r\n * 로컬 스토리지 정리 및 캐시 관리 기능 제공\r\n */\r\n\r\n/**\r\n * LocalStorage 정리\r\n * 불필요하거나 오래된 데이터 정리\r\n */\r\nexport function cleanLocalStorage(): void {\r\n  try {\r\n    // 임시 데이터 정리 (예: 'temp_' 로 시작하는 항목들)\r\n    const keysToRemove: string[] = [];\r\n    \r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      if (key && key.startsWith('temp_')) {\r\n        keysToRemove.push(key);\r\n      }\r\n    }\r\n    \r\n    keysToRemove.forEach(key => localStorage.removeItem(key));\r\n  } catch (error) {\r\n    console.warn('로컬 스토리지 정리 중 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 큰 객체와 캐시를 정리합니다.\r\n */\r\nexport function clearLargeObjectsAndCaches(): void {\r\n  try {\r\n    // 로컬 스토리지의 임시 항목 정리\r\n    if (window.localStorage) {\r\n      Object.keys(localStorage).forEach(key => {\r\n        if (key.startsWith('temp_') || key.startsWith('cache_')) {\r\n          localStorage.removeItem(key);\r\n        }\r\n      });\r\n    }\r\n    \r\n    // 모든 응용 프로그램 캐시 정리 시도\r\n    if (window.caches) {\r\n      caches.keys().then(cacheNames => {\r\n        cacheNames.forEach(cacheName => {\r\n          if (cacheName.includes('temp') || cacheName.includes('nonessential')) {\r\n            caches.delete(cacheName);\r\n          }\r\n        });\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error('캐시 정리 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 세션 스토리지 정리\r\n * 임시 세션 데이터 정리\r\n */\r\nexport function cleanSessionStorage(): void {\r\n  try {\r\n    // 세션 스토리지에서 임시 데이터 정리\r\n    if (window.sessionStorage) {\r\n      const keysToRemove: string[] = [];\r\n      \r\n      for (let i = 0; i < sessionStorage.length; i++) {\r\n        const key = sessionStorage.key(i);\r\n        if (key && (key.startsWith('temp_') || key.includes('cache'))) {\r\n          keysToRemove.push(key);\r\n        }\r\n      }\r\n      \r\n      keysToRemove.forEach(key => sessionStorage.removeItem(key));\r\n    }\r\n  } catch (error) {\r\n    console.warn('세션 스토리지 정리 중 오류:', error);\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\types-extended.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":31,"column":36,"nodeType":"Identifier","messageId":"undef","endLine":31,"endColumn":52},{"ruleId":"no-unused-vars","severity":2,"message":"'aggressive' is defined but never used.","line":68,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":68,"endColumn":39},{"ruleId":"no-unused-vars","severity":2,"message":"'interval' is defined but never used.","line":71,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":71,"endColumn":48},{"ruleId":"no-unused-vars","severity":2,"message":"'threshold' is defined but never used.","line":71,"column":50,"nodeType":"Identifier","messageId":"unusedVar","endLine":71,"endColumn":68},{"ruleId":"no-undef","severity":2,"message":"'Window' is not defined.","line":81,"column":42,"nodeType":"Identifier","messageId":"undef","endLine":81,"endColumn":48}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 메모리 관련 확장 타입 정의\r\n */\r\nimport { \r\n  GCResult, \r\n  OptimizationLevel, \r\n  MemoryUsageInfo \r\n} from './types';\r\n\r\n// ExtendedGCResult 타입 정의 - 중복 선언 해결\r\nexport interface ExtendedGCResult extends GCResult {\r\n  // 추가 필드 정의\r\n  optimizationLevel?: OptimizationLevel;\r\n  memoryInfoBefore?: MemoryUsageInfo;\r\n  memoryInfoAfter?: MemoryUsageInfo;\r\n  detachedEventListeners?: number; \r\n  removedElements?: number;\r\n  cleanedCaches?: number;\r\n  optimizationSource?: string;\r\n  \r\n  // 추가 필드 (타입 일관성 유지)\r\n  heapUsedBefore?: number;\r\n  heapUsedAfter?: number;\r\n  percentFreed?: number;\r\n  source?: string;\r\n}\r\n\r\n// 애플리케이션 캐시 관련 확장 타입\r\n// Window 인터페이스 확장 대신 별도 타입으로 정의\r\nexport type WindowCacheObjects = {\r\n  __imageResizeCache?: Map<string, HTMLImageElement>;\r\n  __objectUrls?: Map<string, string>;\r\n  __memoryCache?: Map<string, unknown>;\r\n  __styleCache?: Map<string, unknown>;\r\n  __widgetCache?: Map<string, unknown>;\r\n};\r\n\r\n// 메모리 최적화 상태 인터페이스\r\nexport interface MemoryOptimizationState {\r\n  lastRun: number | null;\r\n  totalOptimizations: number;\r\n  freedMemory: number;\r\n  active: boolean;\r\n  running: boolean;\r\n}\r\n\r\n// 제네릭 캐시 엔트리 인터페이스\r\nexport interface CacheEntry<T> {\r\n  data: T;\r\n  timestamp: number;\r\n  expires?: number;\r\n  priority?: number;\r\n}\r\n\r\n// 메모리 풀 옵션 인터페이스\r\nexport interface MemoryPoolOptions {\r\n  initialSize: number;\r\n  maxSize: number;\r\n  growFactor: number;\r\n  shrinkThreshold: number;\r\n  itemType: string;\r\n}\r\n\r\n// 메모리 최적화 유틸리티 - 함수 정의\r\nexport interface MemoryOptimizerUtility {\r\n  getMemoryInfo: () => Promise<MemoryUsageInfo>;\r\n  getMemoryUsagePercentage: () => Promise<number>;\r\n  optimizeMemory: (aggressive: boolean) => Promise<any>;\r\n  suggestGarbageCollection: () => void;\r\n  clearAllCaches: () => void;\r\n  setupPeriodicOptimization: (interval?: number, threshold?: number) => () => void;\r\n  cleanupPeriodicOptimization: () => void;\r\n}\r\n\r\n/**\r\n * 확장된 윈도우 인터페이스 정의\r\n * 메모리 관리 및 캐시 관련 속성 추가\r\n */\r\n\r\n// 전역 윈도우 객체에 캐시 관련 속성 추가\r\nexport interface WindowWithCache extends Window {\r\n  // Object URL 관련\r\n  __objectUrls?: Map<string, string>;\r\n  \r\n  // 위젯 캐시 관련\r\n  __widgetCache?: Map<string, unknown>;\r\n  \r\n  // 스타일 캐시 관련\r\n  __styleCache?: Record<string, unknown>;\r\n  \r\n  // 이미지 리사이즈 캐시 관련\r\n  __imageResizeCache?: Record<string, unknown>;\r\n  \r\n  // 메모리 캐시 관련\r\n  __memoryCache?: Map<string, unknown>;\r\n  \r\n  // 버퍼 캐시 관련\r\n  __bufferCache?: Record<string, unknown>;\r\n  \r\n  // 텍스처 캐시 관련\r\n  __textureCache?: Map<string, string>;\r\n  \r\n  // 객체 캐시 관련\r\n  __objectCache?: Map<string, unknown>;\r\n  \r\n  // 동적 모듈 관리\r\n  _dynamicModules?: Map<string, unknown>;\r\n  \r\n  // 가비지 콜렉션\r\n  gc?: () => void;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\types.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'NONE' is defined but never used.","line":42,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":42,"endColumn":7},{"ruleId":"no-unused-vars","severity":2,"message":"'LOW' is defined but never used.","line":43,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":43,"endColumn":6},{"ruleId":"no-unused-vars","severity":2,"message":"'MEDIUM' is defined but never used.","line":44,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":44,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'HIGH' is defined but never used.","line":45,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":45,"endColumn":7},{"ruleId":"no-unused-vars","severity":2,"message":"'EXTREME' is defined but never used.","line":46,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":46,"endColumn":10},{"ruleId":"no-unused-vars","severity":2,"message":"'None' is defined but never used.","line":51,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":51,"endColumn":7},{"ruleId":"no-unused-vars","severity":2,"message":"'Low' is defined but never used.","line":52,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":52,"endColumn":6},{"ruleId":"no-unused-vars","severity":2,"message":"'Medium' is defined but never used.","line":53,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":53,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'High' is defined but never used.","line":54,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":54,"endColumn":7},{"ruleId":"no-unused-vars","severity":2,"message":"'Extreme' is defined but never used.","line":55,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":55,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'EventListener' is not defined.","line":73,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":73,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'AddEventListenerOptions' is not defined.","line":74,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":74,"endColumn":46}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 메모리 관련 타입 정의\r\n */\r\n\r\n// 메모리 정보 인터페이스 - 외부 모듈 대신 직접 정의\r\nexport interface MemoryUsageInfo {\r\n  heapUsed: number;       // 바이트 단위 힙 사용량 \r\n  heapTotal: number;      // 바이트 단위 총 힙 크기\r\n  heapUsedMB: number;     // MB 단위 힙 사용량\r\n  rss: number;            // 바이트 단위 RSS\r\n  rssMB: number;          // MB 단위 RSS\r\n  percentUsed: number;    // 사용량 비율 (%)\r\n  timestamp: number;      // 타임스탬프\r\n}\r\n\r\n// GC 결과 인터페이스 추가\r\nexport interface GCResult {\r\n  success: boolean;       // 성공 여부\r\n  timestamp: number;      // 실행 시간\r\n  freedMemory?: number;   // 해제된 메모리 (바이트)\r\n  freedMB?: number;       // 해제된 메모리 (MB)\r\n  duration?: number;      // 실행 시간 (ms)\r\n  error?: string;         // 오류 메시지\r\n}\r\n\r\n// 메모리 최적화 유틸리티 인터페이스 정의 - 기존 정의와 별도\r\nexport interface MemoryOptimizer {\r\n  optimize(): Promise<boolean>;\r\n  getMemoryInfo(): any;\r\n  cleanup(): void;\r\n}\r\n\r\n// 확장 GC 결과 인터페이스\r\nexport interface ExtendedGCResult extends GCResult {\r\n  heapUsedBefore?: number;  // GC 전 힙 사용량\r\n  heapUsedAfter?: number;   // GC 후 힙 사용량\r\n  percentReduced?: number;  // 감소 비율 (%)\r\n}\r\n\r\n// 최적화 레벨 열거형\r\nexport enum AppOptimizationLevel {\r\n  NONE = 0,     // 최적화 없음\r\n  LOW = 1,      // 낮은 수준 최적화\r\n  MEDIUM = 2,   // 중간 수준 최적화\r\n  HIGH = 3,     // 높은 수준 최적화\r\n  EXTREME = 4   // 극단적 최적화\r\n}\r\n\r\n// 최적화 레벨 열거형\r\nexport enum OptimizationLevel {\r\n  None = 0,\r\n  Low = 1,\r\n  Medium = 2,\r\n  High = 3,\r\n  Extreme = 4\r\n}\r\n\r\n// 최적화 결과 인터페이스\r\nexport interface OptimizationResult {\r\n  success: boolean;\r\n  timestamp: number;\r\n  optimizationLevel?: OptimizationLevel;\r\n  freedMemory?: number;\r\n  freedMB?: number;\r\n  duration?: number;\r\n  error?: string | null;\r\n}\r\n\r\n/**\r\n * 이벤트 리스너 데이터 인터페이스\r\n */\r\nexport interface EventListenerData {\r\n  listener: EventListener;\r\n  options?: boolean | AddEventListenerOptions;\r\n  lastUsed: number;\r\n}\r\n\r\n/**\r\n * 동적 모듈 인터페이스\r\n */\r\nexport interface DynamicModule {\r\n  id: string;\r\n  load: () => Promise<any>; \r\n  unload: () => void;\r\n  lastUsed: number;\r\n}\r\n\r\n/**\r\n * 메모리 최적화 옵션 인터페이스\r\n */\r\nexport interface MemoryOptimizerOptions {\r\n  threshold?: number;\r\n  checkInterval?: number;\r\n  showWarnings?: boolean;\r\n  autoOptimize?: boolean;\r\n  debug?: boolean;\r\n  preferNative?: boolean;\r\n}\r\n\r\n/**\r\n * 제네릭 결과 인터페이스\r\n */\r\nexport interface OperationResult<T = any> {\r\n  success: boolean;\r\n  result?: T;\r\n  error?: string;\r\n  timestamp: number;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\memory\\utils.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":11,"column":41,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":47},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":12,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":18,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":18,"endColumn":18},{"ruleId":"no-unused-vars","severity":2,"message":"'aggressive' is assigned a value but never used.","line":26,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'aggressive' is assigned a value but never used.","line":26,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":31,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":31,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":32,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":32,"endColumn":17},{"ruleId":"no-unused-vars","severity":2,"message":"'interval' is assigned a value but never used.","line":39,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":39,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'interval' is assigned a value but never used.","line":39,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":39,"endColumn":43},{"ruleId":"no-unused-vars","severity":2,"message":"'threshold' is assigned a value but never used.","line":39,"column":53,"nodeType":"Identifier","messageId":"unusedVar","endLine":39,"endColumn":62},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'threshold' is assigned a value but never used.","line":39,"column":53,"nodeType":null,"messageId":"unusedVar","endLine":39,"endColumn":62},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":55,"column":40,"nodeType":"Identifier","messageId":"undef","endLine":55,"endColumn":46},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":56,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":56,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":63,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":63,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":74,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":74,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":74,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":74,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":75,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":75,"endColumn":31}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 메모리 관리를 위한 유틸리티 함수\r\n */\r\n\r\n/**\r\n * 메모리 유틸리티 초기화\r\n * 앱 실행 시 메모리 관리 시스템을 설정합니다.\r\n */\r\nexport function setupMemoryUtils(): void {\r\n  // 글로벌 메모리 최적화 객체가 없는 경우 초기화\r\n  if (typeof window !== 'undefined' && !window.__memoryOptimizer) {\r\n    window.__memoryOptimizer = {\r\n      getMemoryInfo: async () => {\r\n        try {\r\n          const memoryInfo = await getMemoryUsage();\r\n          return memoryInfo;\r\n        } catch (e) {\r\n          console.error('메모리 정보 가져오기 오류:', e);\r\n          return null;\r\n        }\r\n      },\r\n      getMemoryUsagePercentage: async () => {\r\n        const memoryInfo = await getMemoryUsage();\r\n        return memoryInfo ? memoryInfo.percent_used : 0;\r\n      },\r\n      optimizeMemory: async (aggressive = false) => {\r\n        // 최적화 로직 구현\r\n        return { success: true };\r\n      },\r\n      suggestGarbageCollection: () => {\r\n        if (typeof window.gc === 'function') {\r\n          window.gc();\r\n        }\r\n      },\r\n      clearAllCaches: () => {\r\n        // 캐시 정리 로직\r\n        return true;\r\n      },\r\n      setupPeriodicOptimization: (interval = 60000, threshold = 80) => {\r\n        // 주기적 최적화 설정\r\n        return () => {}; // 정리 함수\r\n      },\r\n      cleanupPeriodicOptimization: () => {\r\n        // 정리 로직\r\n      },\r\n      settings: {}\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * 현재 메모리 사용량 백분율 가져오기\r\n */\r\nexport async function getMemoryUsagePercentage(): Promise<number> {\r\n  if (typeof window !== 'undefined' && window.__memoryOptimizer?.getMemoryUsagePercentage) {\r\n    return window.__memoryOptimizer.getMemoryUsagePercentage();\r\n  }\r\n  \r\n  try {\r\n    const memoryInfo = await getMemoryUsage();\r\n    return memoryInfo ? memoryInfo.percent_used : 0;\r\n  } catch (e) {\r\n    console.error('메모리 사용량 가져오기 오류:', e);\r\n    return 0;\r\n  }\r\n}\r\n\r\n/**\r\n * 현재 메모리 사용량 정보 가져오기\r\n */\r\nasync function getMemoryUsage() {\r\n  if (typeof window !== 'undefined') {\r\n    // 브라우저 환경에서는 performance.memory API 사용 시도\r\n    if (performance && (performance as any).memory) {\r\n      const mem = (performance as any).memory;\r\n      return {\r\n        heap_used: mem.usedJSHeapSize,\r\n        heap_total: mem.totalJSHeapSize,\r\n        heap_limit: mem.jsHeapSizeLimit,\r\n        heap_used_mb: mem.usedJSHeapSize / (1024 * 1024),\r\n        percent_used: (mem.usedJSHeapSize / mem.totalJSHeapSize) * 100,\r\n        timestamp: Date.now()\r\n      };\r\n    }\r\n  }\r\n  \r\n  // 기본값 반환\r\n  return {\r\n    heap_used: 0,\r\n    heap_total: 0,\r\n    heap_limit: 0,\r\n    heap_used_mb: 0,\r\n    percent_used: 0,\r\n    timestamp: Date.now()\r\n  };\r\n}\r\n\r\n/**\r\n * 메모리 정보 객체 생성\r\n */\r\nexport function createMemoryInfo(data: Partial<{\r\n  heap_used: number;\r\n  heap_total: number;\r\n  heap_limit: number;\r\n  heap_used_mb: number;\r\n  percent_used: number;\r\n  timestamp: number;\r\n}>) {\r\n  return {\r\n    heap_used: data.heap_used || 0,\r\n    heap_total: data.heap_total || 0,\r\n    heap_limit: data.heap_limit || 0,\r\n    heap_used_mb: data.heap_used_mb || 0,\r\n    percent_used: data.percent_used || 0,\r\n    timestamp: data.timestamp || Date.now()\r\n  };\r\n}\r\n\r\n/**\r\n * 자원 해제 헬퍼 함수\r\n */\r\nexport function cleanupResources(resources: any[]): void {\r\n  for (const resource of resources) {\r\n    if (resource && typeof resource.dispose === 'function') {\r\n      try {\r\n        resource.dispose();\r\n      } catch (e) {\r\n        // 리소스 해제 에러 무시\r\n      }\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\native-gpu-types.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'Small' is defined but never used.","line":26,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":8},{"ruleId":"no-unused-vars","severity":2,"message":"'Medium' is defined but never used.","line":27,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'Large' is defined but never used.","line":28,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":28,"endColumn":8},{"ruleId":"no-unused-vars","severity":2,"message":"'Custom' is defined but never used.","line":29,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":29,"endColumn":9}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GPU 네이티브 모듈 타입 정의\r\n */\r\n\r\nexport interface GpuDeviceInfo {\r\n  vendor: string;\r\n  device: string;\r\n  driver: string;\r\n  device_type: string;\r\n  backend: string;\r\n  timestamp: number;\r\n}\r\n\r\nexport interface GpuCapabilities {\r\n  compute_supported: boolean;\r\n  shading_supported: boolean;\r\n  max_compute_size: number;\r\n  max_memory_size: number;\r\n  device_name: string;\r\n  device_type: string;\r\n  backend_type: string;\r\n  timestamp: number;\r\n}\r\n\r\nexport enum WorkloadSize {\r\n  Small = 'small',\r\n  Medium = 'medium',\r\n  Large = 'large',\r\n  Custom = 'custom'\r\n}\r\n\r\nexport interface GpuComputationOptions {\r\n  workloadSize?: WorkloadSize;\r\n  useAcceleration?: boolean;\r\n  timeout?: number;\r\n}\r\n\r\nexport interface GpuComputationResult {\r\n  success: boolean;\r\n  used_gpu_acceleration: boolean;\r\n  computation_time_ms: number;\r\n  result: any;\r\n  workload_size: string;\r\n  gpu_info?: {\r\n    name: string;\r\n    type: string;\r\n    backend: string;\r\n  };\r\n  timestamp: number;\r\n}\r\n\r\nexport interface PatternDetectionResult extends GpuComputationResult {\r\n  key_count: number;\r\n  average_typing_speed_ms: number;\r\n  typing_speed_variance: number;\r\n  typing_pattern: string;\r\n  consistency_score: number;\r\n}\r\n\r\nexport interface MatrixMultiplicationResult extends GpuComputationResult {\r\n  dimensions: number;\r\n}\r\n\r\nexport interface ArrayProcessingResult extends GpuComputationResult {\r\n  items_processed: number;\r\n}\r\n\r\nexport interface DataAnalysisResult extends GpuComputationResult {\r\n  complexity: string;\r\n  analysis_type: string;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\native-memory-bridge.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'OptimizationLevel' is defined but never used.","line":5,"column":42,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":59},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'OptimizationLevel' is defined but never used.","line":5,"column":42,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":59},{"ruleId":"no-unused-vars","severity":2,"message":"'toNativeOptimizationLevel' is defined but never used.","line":6,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'toNativeOptimizationLevel' is defined but never used.","line":6,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":58},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":19,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":19,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":27,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":27,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":59,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":59,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":72,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":72,"endColumn":12}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 네이티브 모듈과의 통신 브릿지\r\n */\r\n\r\nimport { MemoryInfo, OptimizationResult, OptimizationLevel, GCResult } from '@/types';\r\nimport { safeOptimizationLevel, toNativeOptimizationLevel } from './memory/optimization-utils';\r\n\r\n/**\r\n * 네이티브 메모리 정보 요청\r\n */\r\nexport async function requestNativeMemoryInfo(): Promise<MemoryInfo | null> {\r\n  // 기본적인 브라우저 환경 체크\r\n  if (typeof window === 'undefined') {\r\n    return null;\r\n  }\r\n  \r\n  try {\r\n    // 백엔드 API를 통해 메모리 정보 요청\r\n    const response = await fetch('/api/native/memory/info');\r\n    if (!response.ok) {\r\n      throw new Error(`API 요청 실패: ${response.status}`);\r\n    }\r\n    \r\n    const data = await response.json();\r\n    return data.memoryInfo;\r\n  } catch (error) {\r\n    console.error('네이티브 메모리 정보 요청 오류:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nimport { optimizeMemory, forceGarbageCollection, getMemoryInfo as fetchMemoryInfo } from './nativeModuleClient';\r\n\r\n// 브리지 상태\r\nconst bridgeState = {\r\n  isInitialized: false,\r\n  isAvailable: false,\r\n  lastError: null as Error | null,\r\n  lastCheck: 0,\r\n  errorCount: 0\r\n};\r\n\r\n/**\r\n * 에러 처리 래퍼 함수\r\n */\r\nasync function withErrorHandling<T>(\r\n  operation: () => Promise<T>, // 타입 오류 수정\r\n  fallback: () => Promise<T> | T | null,\r\n  operationName: string\r\n): Promise<T | null> {\r\n  try {\r\n    // 브리지가 초기화되지 않은 경우\r\n    if (!bridgeState.isInitialized) {\r\n      // 브리지 상태 확인\r\n      await checkBridgeAvailability();\r\n    }\r\n    \r\n    if (!bridgeState.isAvailable) {\r\n      console.warn(`Native bridge not available for ${operationName}`);\r\n      return fallback();\r\n    }\r\n    \r\n    // 작업 실행\r\n    return await operation();\r\n  } catch (error) {\r\n    // 오류 기록\r\n    bridgeState.errorCount++;\r\n    bridgeState.lastError = error instanceof Error \r\n      ? error \r\n      : new Error(String(error));\r\n    \r\n    console.error(`Native bridge error in ${operationName}:`, error);\r\n    \r\n    // 폴백 반환\r\n    return fallback();\r\n  }\r\n}\r\n\r\n/**\r\n * 브리지 가용성 확인\r\n */\r\nasync function checkBridgeAvailability(): Promise<boolean> {\r\n  try {\r\n    // 마지막 확인 후 10초 이내면 캐시된 값 반환\r\n    const now = Date.now();\r\n    if (now - bridgeState.lastCheck < 10000 && bridgeState.isInitialized) {\r\n      return bridgeState.isAvailable;\r\n    }\r\n    \r\n    // 메모리 정보 가져오기 시도로 가용성 확인\r\n    const response = await fetchMemoryInfo();\r\n    \r\n    bridgeState.isAvailable = response.success;\r\n    bridgeState.isInitialized = true;\r\n    bridgeState.lastCheck = now;\r\n    \r\n    if (!response.success) {\r\n      bridgeState.lastError = new Error(response.error || 'Unknown error in native bridge');\r\n    } else {\r\n      bridgeState.lastError = null;\r\n    }\r\n    \r\n    return bridgeState.isAvailable;\r\n  } catch (error) {\r\n    bridgeState.isAvailable = false;\r\n    bridgeState.isInitialized = true;\r\n    bridgeState.lastError = error instanceof Error \r\n      ? error \r\n      : new Error(String(error));\r\n    bridgeState.lastCheck = Date.now();\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 네이티브 가비지 컬렉션 요청\r\n */\r\nexport async function requestNativeGarbageCollection(): Promise<GCResult | null> {\r\n  return withErrorHandling(\r\n    async () => {\r\n      const response = await forceGarbageCollection();\r\n      \r\n      if (response.success && response.result) {\r\n        return response.result;\r\n      }\r\n      \r\n      throw new Error(response.error || '가비지 컬렉션을 수행할 수 없습니다');\r\n    },\r\n    () => ({\r\n      success: false,\r\n      timestamp: Date.now(),\r\n      freedMemory: 0,\r\n      freedMB: 0,\r\n      duration: 0,\r\n      error: bridgeState.lastError?.message || '가비지 컬렉션을 사용할 수 없습니다'\r\n    }),\r\n    '가비지 컬렉션'\r\n  );\r\n}\r\n\r\n/**\r\n * 네이티브 메모리 최적화 요청\r\n */\r\nexport async function requestNativeMemoryOptimization(\r\n  level: number,\r\n  emergency = false\r\n): Promise<OptimizationResult | null> {\r\n  // 올바른 레벨 값 확보\r\n  const safeLevel = safeOptimizationLevel(level);\r\n  \r\n  return withErrorHandling(\r\n    async () => {\r\n      const response = await optimizeMemory(safeLevel, emergency);\r\n      \r\n      if (response.success && response.result) {\r\n        return response.result;\r\n      }\r\n      \r\n      throw new Error(response.error || '메모리 최적화를 수행할 수 없습니다');\r\n    },\r\n    () => ({\r\n      success: false,\r\n      optimizationLevel: safeLevel,\r\n      timestamp: Date.now(),\r\n      freedMemory: 0,\r\n      freedMB: 0,\r\n      error: bridgeState.lastError?.message || '메모리 최적화를 사용할 수 없습니다'\r\n    }),\r\n    '메모리 최적화'\r\n  );\r\n}\r\n\r\n/**\r\n * 네이티브 브리지 상태 확인\r\n */\r\nexport async function checkNativeBridgeStatus(): Promise<{\r\n  available: boolean;\r\n  initialized: boolean;\r\n  lastCheck: number;\r\n  errorCount: number;\r\n  lastError: string | null;\r\n}> {\r\n  await checkBridgeAvailability();\r\n  \r\n  return {\r\n    available: bridgeState.isAvailable,\r\n    initialized: bridgeState.isInitialized,\r\n    lastCheck: bridgeState.lastCheck,\r\n    errorCount: bridgeState.errorCount,\r\n    lastError: bridgeState.lastError?.message || null\r\n  };\r\n}\r\n\r\n/**\r\n * 브리지 상태 게터 함수들\r\n */\r\nexport const getNativeBridgeState = () => ({ ...bridgeState });\r\nexport const isNativeBridgeAvailable = () => bridgeState.isAvailable;\r\nexport const getBridgeErrorCount = () => bridgeState.errorCount;\r\nexport const getLastBridgeError = () => bridgeState.lastError;\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\nativeModuleClient.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'MemoryInfo' is defined but never used.","line":8,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MemoryInfo' is defined but never used.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":13},{"ruleId":"no-unused-vars","severity":2,"message":"'OptimizationResult' is defined but never used.","line":9,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'OptimizationResult' is defined but never used.","line":9,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":21},{"ruleId":"no-unused-vars","severity":2,"message":"'GCResult' is defined but never used.","line":10,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GCResult' is defined but never used.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":11},{"ruleId":"no-unused-vars","severity":2,"message":"'GpuInfo' is defined but never used.","line":11,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GpuInfo' is defined but never used.","line":11,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":10},{"ruleId":"no-unused-vars","severity":2,"message":"'GpuComputationResult' is defined but never used.","line":12,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GpuComputationResult' is defined but never used.","line":12,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":23},{"ruleId":"no-unused-vars","severity":2,"message":"'TaskResult' is defined but never used.","line":13,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TaskResult' is defined but never used.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":13},{"ruleId":"no-unused-vars","severity":2,"message":"'OptimizationLevel' is defined but never used.","line":15,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'OptimizationLevel' is defined but never used.","line":15,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'RequestInit' is not defined.","line":28,"column":52,"nodeType":"Identifier","messageId":"undef","endLine":28,"endColumn":63},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":28,"column":79,"nodeType":"Identifier","messageId":"undef","endLine":28,"endColumn":87},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":30,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":30,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":40,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":62,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":62,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":90,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":90,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":116,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":116,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":137,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":137,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":172,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":172,"endColumn":12},{"ruleId":"no-unused-vars","severity":2,"message":"'T' is defined but never used.","line":188,"column":45,"nodeType":"Identifier","messageId":"unusedVar","endLine":188,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'T' is defined but never used.","line":188,"column":45,"nodeType":null,"messageId":"unusedVar","endLine":188,"endColumn":46},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":209,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":209,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":247,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":247,"endColumn":12}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 네이티브 모듈 클라이언트 API\r\n * \r\n * 프론트엔드에서 네이티브 모듈 기능을 사용하기 위한 래퍼 함수들을 제공합니다.\r\n */\r\n\r\nimport type { \r\n  MemoryInfo, \r\n  OptimizationResult, \r\n  GCResult, \r\n  GpuInfo,\r\n  GpuComputationResult,\r\n  TaskResult\r\n} from '@/types';\r\nimport { OptimizationLevel } from '@/types/native-module';\r\n\r\n// 상태 캐시\r\nlet moduleStatusCache: any = null;\r\nlet lastStatusCheck = 0;\r\nconst STATUS_CACHE_TTL = 10000; // 10초\r\n\r\n// 브라우저 환경인지 확인 - 상수로 변경\r\nconst isBrowser = typeof window !== 'undefined';\r\n\r\n/**\r\n * fetch 요청을 래핑하는 함수\r\n */\r\nasync function enhancedFetch(url: string, options: RequestInit = {}): Promise<Response> {\r\n  try {\r\n    const response = await fetch(url, {\r\n      ...options,\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        ...options.headers,\r\n      },\r\n    });\r\n    \r\n    return response;\r\n  } catch (error) {\r\n    console.error(`Fetch 요청 실패 (${url}):`, error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 정보 가져오기\r\n */\r\nexport async function getMemoryInfo() {\r\n  if (!isBrowser) {\r\n    return { success: false, error: 'Server environment', timestamp: Date.now() };\r\n  }\r\n  \r\n  try {\r\n    const response = await enhancedFetch('/api/native/memory');\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`HTTP error! status: ${response.status}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    console.error('메모리 정보 가져오기 실패:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 최적화 수행\r\n */\r\nexport async function optimizeMemory(level = 2, emergency = false) {\r\n  try {\r\n    const response = await enhancedFetch('/api/native/memory', {\r\n      method: 'PUT',\r\n      body: JSON.stringify({\r\n        type: 'optimize',\r\n        level: level.toString(),\r\n        emergency\r\n      }),\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`HTTP error! status: ${response.status}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    console.error('메모리 최적화 실패:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * 가비지 컬렉션 강제 수행\r\n */\r\nexport async function forceGarbageCollection() {\r\n  try {\r\n    const response = await enhancedFetch('/api/native/memory', {\r\n      method: 'PUT',\r\n      body: JSON.stringify({\r\n        type: 'gc'\r\n      }),\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`HTTP error! status: ${response.status}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    console.error('가비지 컬렉션 실패:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 정보 가져오기\r\n */\r\nexport async function getGpuInfo() {\r\n  try {\r\n    const response = await enhancedFetch('/api/native/gpu');\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`GPU 정보 요청 실패: ${response.status}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    console.error('GPU 정보 가져오기 오류:', error);\r\n    return {\r\n      success: false,\r\n      available: false,\r\n      gpuInfo: null,\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\r\n      timestamp: Date.now()\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 가속 활성화/비활성화\r\n * @param enable 활성화 여부\r\n */\r\nexport async function setGpuAcceleration(enable: boolean) {\r\n  try {\r\n    // 요청 데이터 준비\r\n    const requestBody = JSON.stringify({\r\n      enable\r\n    });\r\n    \r\n    // 요청 보내기\r\n    const response = await enhancedFetch('/api/native/gpu/acceleration', {\r\n      method: 'PUT',\r\n      body: requestBody\r\n    });\r\n    \r\n    // 응답 처리\r\n    if (!response.ok) {\r\n      throw new Error(`GPU 가속 설정 요청 실패: ${response.status}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    console.error('GPU 가속 설정 오류:', error);\r\n    return {\r\n      success: false,\r\n      enabled: false,\r\n      result: false,\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\r\n      timestamp: Date.now()\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 계산 수행\r\n * @param data 계산에 사용할 데이터\r\n * @param computationType 계산 유형\r\n */\r\nexport async function performGpuComputation<T = unknown>(data: unknown, computationType: string) {\r\n  try {\r\n    // 요청 데이터 준비\r\n    const requestBody = JSON.stringify({\r\n      data,\r\n      computationType\r\n    });\r\n    \r\n    // 요청 보내기\r\n    const response = await enhancedFetch('/api/native/gpu', {\r\n      method: 'POST',\r\n      body: requestBody\r\n    });\r\n    \r\n    // 응답 처리\r\n    if (!response.ok) {\r\n      throw new Error(`GPU 계산 요청 실패: ${response.status}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    console.error('GPU 계산 오류:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\r\n      timestamp: Date.now()\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * 네이티브 모듈 상태 확인\r\n */\r\nexport async function getNativeModuleStatus() {\r\n  if (!isBrowser) {\r\n    return { success: false, error: 'Server environment', timestamp: Date.now() };\r\n  }\r\n  \r\n  // 캐시된 상태가 있고 TTL 내라면 캐시된 값 반환\r\n  const now = Date.now();\r\n  if (moduleStatusCache && now - lastStatusCheck < STATUS_CACHE_TTL) {\r\n    return moduleStatusCache;\r\n  }\r\n  \r\n  try {\r\n    const response = await enhancedFetch('/api/native/status');\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`네이티브 모듈 상태 요청 실패: ${response.status}`);\r\n    }\r\n    \r\n    const result = await response.json();\r\n    \r\n    // 캐시 업데이트\r\n    moduleStatusCache = result;\r\n    lastStatusCheck = now;\r\n    \r\n    return result;\r\n  } catch (error) {\r\n    console.error('네이티브 모듈 상태 확인 실패:', error);\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\number-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\path-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\performance-cache.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'args' is defined but never used.","line":24,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":15},{"ruleId":"no-unused-vars","severity":2,"message":"'args' is defined but never used.","line":26,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":18},{"ruleId":"no-unused-vars","severity":2,"message":"'args' is defined but never used.","line":27,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":64,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":64,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":67,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":67,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":75,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":75,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":75,"column":63,"nodeType":"Identifier","messageId":"undef","endLine":75,"endColumn":73},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":80,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":80,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":83,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":83,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":89,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":89,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":91,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":91,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":93,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":93,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":94,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":94,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":94,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":94,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2284,2364],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 성능 최적화를 위한 캐시 유틸리티\r\n * \r\n * 초기 렌더링 및 실행 시간 개선을 위한 다양한 캐싱 기법을 제공합니다.\r\n */\r\n\r\n// 전역 메모이제이션 캐시\r\ninterface MemoCache<T> {\r\n  [key: string]: {\r\n    value: T;\r\n    expires: number;\r\n  };\r\n}\r\n\r\nconst memoCache: MemoCache<any> = {};\r\n\r\n/**\r\n * 함수 결과를 메모이제이션하는 고차 함수\r\n * @param fn 캐싱할 함수\r\n * @param ttl 캐시 유효시간 (밀리초)\r\n * @param keyFn 캐시 키 생성 함수 (기본값: 인자를 JSON으로 변환)\r\n */\r\nexport function memoize<T, A extends any[]>(\r\n  fn: (...args: A) => T, \r\n  ttl: number = 60_000, // 기본값: 1분\r\n  keyFn: (...args: A) => string = (...args) => JSON.stringify(args)\r\n): (...args: A) => T {\r\n  return (...args: A): T => {\r\n    const key = keyFn(...args);\r\n    const now = Date.now();\r\n    \r\n    if (memoCache[key] && memoCache[key].expires > now) {\r\n      return memoCache[key].value;\r\n    }\r\n    \r\n    const result = fn(...args);\r\n    memoCache[key] = {\r\n      value: result,\r\n      expires: now + ttl\r\n    };\r\n    \r\n    return result;\r\n  };\r\n}\r\n\r\n/**\r\n * 캐시 정리 (정기적으로 호출하여 메모리 최적화)\r\n */\r\nexport function cleanupCache(): void {\r\n  const now = Date.now();\r\n  const keys = Object.keys(memoCache);\r\n  \r\n  for (const key of keys) {\r\n    if (memoCache[key].expires < now) {\r\n      delete memoCache[key];\r\n    }\r\n  }\r\n}\r\n\r\n// 캐시 정리를 위한 인터벌 설정 (5분마다)\r\nexport function setupAutomaticCacheCleanup(intervalMs: number = 300_000): () => void {\r\n  if (typeof window === 'undefined') return () => {};\r\n  \r\n  const intervalId = setInterval(cleanupCache, intervalMs);\r\n  \r\n  // 클린업 함수 반환\r\n  return () => clearInterval(intervalId);\r\n}\r\n\r\n// 컴포넌트 렌더링 최적화를 위한 코드 분할 헬퍼\r\nexport function setupEagerLoading(): void {\r\n  if (typeof window === 'undefined') return;\r\n  \r\n  // 브라우저 유휴 시간에 주요 컴포넌트 미리 로드\r\n  const idleCallback = window.requestIdleCallback || ((cb) => setTimeout(cb, 1));\r\n  \r\n  idleCallback(() => {\r\n    // 필요한 모듈 미리 로드\r\n    import('../components/MemoryUsageMonitor')\r\n      .catch(e => console.warn('Preload failed:', e));\r\n      \r\n    import('../components/NativeModuleTestPanel')\r\n      .catch(e => console.warn('Preload failed:', e));\r\n  });\r\n}\r\n\r\n// 렌더링 성능 측정 유틸리티\r\nexport function measureRenderTime(componentName: string): () => void {\r\n  if (process.env.NODE_ENV !== 'development') return () => {};\r\n  \r\n  const startTime = performance.now();\r\n  return () => {\r\n    const endTime = performance.now();\r\n    console.log(`[Render] ${componentName}: ${(endTime - startTime).toFixed(2)}ms`);\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\performance-metrics.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'NativeOptimizationLevel' is defined but never used.","line":9,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":54},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NativeOptimizationLevel' is defined but never used.","line":9,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":54},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":64,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":64,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":68,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":68,"endColumn":40},{"ruleId":"no-unused-vars","severity":2,"message":"'memoryMiddle' is assigned a value but never used.","line":83,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":83,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'memoryMiddle' is assigned a value but never used.","line":83,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":83,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":93,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":93,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'performance' is not defined.","line":95,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":95,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":146,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":146,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":146,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":146,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"group"},"fix":{"range":[3993,4022],"text":""},"desc":"Remove the console.group()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":147,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":147,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":147,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":147,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4026,4069],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":148,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":148,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":148,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":148,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4073,4143],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":150,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":150,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":150,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":150,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"group"},"fix":{"range":[4151,4179],"text":""},"desc":"Remove the console.group()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":151,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":151,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":151,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":151,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4183,4263],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":152,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":152,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":152,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":152,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4267,4340],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":154,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":154,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":156,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":156,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":156,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":156,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"groupEnd"},"fix":{"range":[4457,4476],"text":""},"desc":"Remove the console.groupEnd()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":158,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":158,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":158,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":158,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"group"},"fix":{"range":[4484,4518],"text":""},"desc":"Remove the console.group()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":159,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":159,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":159,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":159,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4522,4598],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":160,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":160,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":160,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":160,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4602,4671],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":162,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":162,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":164,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":164,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":164,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":164,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"groupEnd"},"fix":{"range":[4780,4799],"text":""},"desc":"Remove the console.groupEnd()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":167,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":167,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":167,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":167,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4844,4964],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":170,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":170,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":170,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":170,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4977,5088],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":171,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":171,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":171,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":171,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"groupEnd"},"fix":{"range":[5092,5111],"text":""},"desc":"Remove the console.groupEnd()."}]},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":193,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":193,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":200,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":200,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":200,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":200,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"group"},"fix":{"range":[5869,5900],"text":""},"desc":"Remove the console.group()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":201,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":201,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":201,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":201,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5904,5948],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":204,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":204,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":204,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":204,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6049,6100],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":206,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":206,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":206,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":206,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6108,6195],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":207,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":207,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":207,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":207,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6199,6297],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":208,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":208,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":208,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":208,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"groupEnd"},"fix":{"range":[6301,6320],"text":""},"desc":"Remove the console.groupEnd()."}]}],"suppressedMessages":[],"errorCount":29,"fatalErrorCount":0,"warningCount":22,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 성능 측정 유틸리티\r\n * \r\n * 이 모듈은 네이티브 모듈과 JavaScript 구현 간의 성능을 비교하기 위한\r\n * 도구를 제공합니다. 측정 결과는 로그와 대시보드에 표시될 수 있습니다.\r\n */\r\n\r\nimport { OptimizationLevel as AppOptimizationLevel } from '@/types';\r\nimport { OptimizationLevel as NativeOptimizationLevel } from '@/types/native-module';\r\nimport { toNativeOptimizationLevel } from './enum-converters';\r\nimport { requestNativeMemoryOptimization } from './native-memory-bridge';\r\nimport { internalOptimizeMemory } from './memory/optimizer';\r\nimport { getMemoryInfo } from './memory/memory-info';\r\nimport { getNativeModuleStatus } from './nativeModuleClient';\r\n\r\n// 성능 측정 결과 인터페이스\r\nexport interface PerformanceResult {\r\n  operationName: string;\r\n  nativeImplementation: {\r\n    executionTime: number;\r\n    success: boolean;\r\n    error?: string;\r\n  };\r\n  jsImplementation: {\r\n    executionTime: number;\r\n    success: boolean;\r\n    error?: string;\r\n  };\r\n  speedupFactor: number;\r\n  timestamp: number;\r\n  memoryBefore: any;\r\n  memoryAfter: any;\r\n  memoryDifference: number;\r\n}\r\n\r\n// 성능 측정 이력\r\nconst performanceHistory: PerformanceResult[] = [];\r\n\r\n/**\r\n * 메모리 최적화 성능 비교 실행\r\n * @param level 최적화 레벨\r\n * @param emergency 긴급 모드 여부\r\n * @returns Promise<PerformanceResult> 성능 측정 결과\r\n */\r\nexport async function benchmarkMemoryOptimization(\r\n  level: AppOptimizationLevel = AppOptimizationLevel.MEDIUM,\r\n  emergency: boolean = false\r\n): Promise<PerformanceResult> {\r\n  // 초기 메모리 상태 기록\r\n  const memoryBefore = await getMemoryInfo() || { heapUsedMB: 0 };\r\n  \r\n  // 네이티브 구현 테스트\r\n  let nativeResult = {\r\n    executionTime: 0,\r\n    success: false,\r\n    error: undefined as string | undefined\r\n  };\r\n  \r\n  // 네이티브 모듈 사용 가능 여부 확인\r\n  const { available } = await getNativeModuleStatus();\r\n  \r\n  if (available) {\r\n    try {\r\n      const nativeStartTime = performance.now();\r\n      // 명시적 변환 함수 사용\r\n      const nativeLevel = toNativeOptimizationLevel(level);\r\n      await requestNativeMemoryOptimization(nativeLevel, emergency);\r\n      const nativeEndTime = performance.now();\r\n      \r\n      nativeResult = {\r\n        executionTime: nativeEndTime - nativeStartTime,\r\n        success: true,\r\n        error: undefined\r\n      };\r\n    } catch (error) {\r\n      nativeResult.error = error instanceof Error ? error.message : '알 수 없는 오류';\r\n    }\r\n  } else {\r\n    nativeResult.error = '네이티브 모듈을 사용할 수 없습니다';\r\n  }\r\n  \r\n  // 자바스크립트 구현 테스트 전 중간 메모리 상태\r\n  const memoryMiddle = await getMemoryInfo();\r\n  \r\n  // 자바스크립트 구현 테스트\r\n  let jsResult = {\r\n    executionTime: 0,\r\n    success: false,\r\n    error: undefined as string | undefined\r\n  };\r\n  \r\n  try {\r\n    const jsStartTime = performance.now();\r\n    await internalOptimizeMemory(emergency);\r\n    const jsEndTime = performance.now();\r\n    \r\n    jsResult = {\r\n      executionTime: jsEndTime - jsStartTime,\r\n      success: true,\r\n      error: undefined\r\n    };\r\n  } catch (error) {\r\n    jsResult.error = error instanceof Error ? error.message : '알 수 없는 오류';\r\n  }\r\n  \r\n  // 최종 메모리 상태 기록\r\n  const memoryAfter = await getMemoryInfo() || { heapUsedMB: 0 };\r\n  \r\n  // 성능 비교 결과 계산\r\n  const speedupFactor = jsResult.success && nativeResult.success && nativeResult.executionTime > 0\r\n    ? jsResult.executionTime / nativeResult.executionTime\r\n    : 0;\r\n  \r\n  // 메모리 차이 계산 (MB 단위)\r\n  const memoryDifference = (memoryBefore?.heapUsedMB ?? 0) - (memoryAfter?.heapUsedMB ?? 0);\r\n  \r\n  // 결과 객체 생성\r\n  const result: PerformanceResult = {\r\n    operationName: `Memory Optimization (Level ${level}, Emergency: ${emergency})`,\r\n    nativeImplementation: nativeResult,\r\n    jsImplementation: jsResult,\r\n    speedupFactor,\r\n    timestamp: Date.now(),\r\n    memoryBefore,\r\n    memoryAfter,\r\n    memoryDifference\r\n  };\r\n  \r\n  // 이력에 추가\r\n  performanceHistory.push(result);\r\n  if (performanceHistory.length > 50) {\r\n    performanceHistory.shift(); // 최대 50개 항목 유지\r\n  }\r\n  \r\n  // 결과 로깅\r\n  logPerformanceResult(result);\r\n  \r\n  return result;\r\n}\r\n\r\n/**\r\n * 성능 측정 결과 로깅\r\n * @param result 성능 측정 결과\r\n */\r\nfunction logPerformanceResult(result: PerformanceResult): void {\r\n  console.group('🔍 성능 비교 결과');\r\n  console.log(`작업: ${result.operationName}`);\r\n  console.log(`시간: ${new Date(result.timestamp).toLocaleTimeString()}`);\r\n  \r\n  console.group('⚙️ 네이티브 구현');\r\n  console.log(`실행 시간: ${result.nativeImplementation.executionTime.toFixed(2)}ms`);\r\n  console.log(`성공 여부: ${result.nativeImplementation.success ? '✅' : '❌'}`);\r\n  if (result.nativeImplementation.error) {\r\n    console.error(`오류: ${result.nativeImplementation.error}`);\r\n  }\r\n  console.groupEnd();\r\n  \r\n  console.group('🔧 JavaScript 구현');\r\n  console.log(`실행 시간: ${result.jsImplementation.executionTime.toFixed(2)}ms`);\r\n  console.log(`성공 여부: ${result.jsImplementation.success ? '✅' : '❌'}`);\r\n  if (result.jsImplementation.error) {\r\n    console.error(`오류: ${result.jsImplementation.error}`);\r\n  }\r\n  console.groupEnd();\r\n  \r\n  if (result.speedupFactor > 0) {\r\n    console.log(`⚡ 속도 향상: ${result.speedupFactor.toFixed(2)}x ${result.speedupFactor > 1 ? '(네이티브가 더 빠름)' : '(JS가 더 빠름)'}`);\r\n  }\r\n  \r\n  console.log(`💾 메모리 차이: ${result.memoryDifference.toFixed(2)}MB ${result.memoryDifference > 0 ? '감소' : '증가'}`);\r\n  console.groupEnd();\r\n}\r\n\r\n/**\r\n * 성능 측정 이력 가져오기\r\n * @returns 성능 측정 이력 배열\r\n */\r\nexport function getPerformanceHistory(): PerformanceResult[] {\r\n  return [...performanceHistory];\r\n}\r\n\r\n/**\r\n * 메모리 최적화 작업에 대한 벤치마크 실행\r\n * 모든 최적화 레벨에 대해 성능 측정을 실행합니다.\r\n */\r\nexport async function runComprehensiveBenchmark(): Promise<PerformanceResult[]> {\r\n  const results: PerformanceResult[] = [];\r\n  \r\n  // 모든 최적화 레벨에 대해 테스트\r\n  for (let level = 0; level <= 4; level++) {\r\n    results.push(await benchmarkMemoryOptimization(level as AppOptimizationLevel, false));\r\n    // 테스트 간 간격을 두어 이전 테스트의 영향 최소화\r\n    await new Promise(resolve => setTimeout(resolve, 1000));\r\n  }\r\n  \r\n  // 긴급 모드 테스트\r\n  results.push(await benchmarkMemoryOptimization(AppOptimizationLevel.EXTREME, true));\r\n  \r\n  // 종합 결과 로깅\r\n  console.group('📊 종합 벤치마크 결과');\r\n  console.log(`총 ${results.length}개 테스트 실행됨`);\r\n  \r\n  const avgSpeedup = results.reduce((sum, r) => sum + r.speedupFactor, 0) / results.length;\r\n  console.log(`평균 속도 향상: ${avgSpeedup.toFixed(2)}x`);\r\n  \r\n  console.log(`최고 속도 향상: ${Math.max(...results.map(r => r.speedupFactor)).toFixed(2)}x`);\r\n  console.log(`총 해제된 메모리: ${results.reduce((sum, r) => sum + r.memoryDifference, 0).toFixed(2)}MB`);\r\n  console.groupEnd();\r\n  \r\n  return results;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\performance-optimizer.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":80,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":80,"endColumn":16},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":80,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":80,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2148,2218],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":101,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":101,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":130,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":130,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":131,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":131,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":135,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":135,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":136,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":136,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":137,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":137,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":145,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":145,"endColumn":12},{"ruleId":"no-unused-vars","severity":2,"message":"'item' is defined but never used.","line":158,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":158,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":193,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":193,"endColumn":48},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":207,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":207,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":207,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":207,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5507,5540],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":217,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":217,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":232,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":232,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":232,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":232,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6043,6101],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":237,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":237,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":237,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":237,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6183,6208],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":240,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":240,"endColumn":12}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 성능 최적화 유틸리티\r\n * \r\n * 애플리케이션 성능 최적화 기능을 제공합니다.\r\n */\r\n\r\nimport { getSystemStatus } from './system-monitor';\r\nimport { optimizeMemory } from './nativeModuleClient';\r\nimport { setGpuAcceleration } from './gpu-acceleration';\r\nimport { MemoryUsageLevel, ProcessingMode, OptimizationLevel } from '@/types';\r\n\r\n// 최적화 설정\r\ninterface OptimizationSettings {\r\n  autoOptimize: boolean;\r\n  memoryThreshold: number;\r\n  aggressiveMode: boolean;\r\n  switchToGpuIfAvailable: boolean;\r\n}\r\n\r\n// 기본 설정\r\nconst defaultSettings: OptimizationSettings = {\r\n  autoOptimize: true,\r\n  memoryThreshold: 70, // 70% 이상 사용시 최적화\r\n  aggressiveMode: false,\r\n  switchToGpuIfAvailable: true\r\n};\r\n\r\n// 현재 설정\r\nlet currentSettings: OptimizationSettings = { ...defaultSettings };\r\n\r\n/**\r\n * 설정 업데이트\r\n * @param settings 부분 설정 객체\r\n */\r\nexport function updateSettings(settings: Partial<OptimizationSettings>) {\r\n  currentSettings = { ...currentSettings, ...settings };\r\n}\r\n\r\n/**\r\n * 성능 분석 및 최적화 수행\r\n * @param forced 강제 최적화 여부\r\n */\r\nexport async function analyzeAndOptimize(forced = false): Promise<boolean> {\r\n  try {\r\n    // 자동 최적화가 비활성화되고 강제 모드가 아니면 중단\r\n    if (!currentSettings.autoOptimize && !forced) {\r\n      return false;\r\n    }\r\n    \r\n    // 시스템 상태 확인\r\n    const status = await getSystemStatus(true);\r\n    \r\n    // 메모리 사용량이 임계치 이상이거나 강제 모드인 경우에만 최적화\r\n    if (status.memory.percentUsed >= currentSettings.memoryThreshold || forced) {\r\n      // 메모리 레벨에 따른 최적화 수준 결정\r\n      let optimizationLevel = 0;\r\n      let emergency = false;\r\n      \r\n      switch (status.memory.level) {\r\n        case MemoryUsageLevel.CRITICAL:\r\n          optimizationLevel = 4;\r\n          emergency = true;\r\n          break;\r\n        case MemoryUsageLevel.HIGH:\r\n          optimizationLevel = 3;\r\n          emergency = currentSettings.aggressiveMode;\r\n          break;\r\n        case MemoryUsageLevel.MEDIUM:\r\n          optimizationLevel = 2;\r\n          emergency = false;\r\n          break;\r\n        case MemoryUsageLevel.LOW:\r\n        default:\r\n          optimizationLevel = forced ? 1 : 0;\r\n          emergency = false;\r\n      }\r\n      \r\n      // 최적화 필요한 경우 수행\r\n      if (optimizationLevel > 0) {\r\n        console.log(`성능 최적화 수행 (레벨: ${optimizationLevel}, 긴급: ${emergency})`);\r\n        \r\n        const result = await optimizeMemory(optimizationLevel, emergency);\r\n        return result.success;\r\n      }\r\n    }\r\n    \r\n    // GPU 가속 여부 결정\r\n    if (currentSettings.switchToGpuIfAvailable) {\r\n      const shouldUseGpu = \r\n        status.memory.level !== MemoryUsageLevel.CRITICAL && \r\n        status.memory.level !== MemoryUsageLevel.HIGH;\r\n      \r\n      // 현재 GPU 상태와 다른 경우에만 변경\r\n      if (shouldUseGpu !== status.processing.gpuEnabled) {\r\n        await setGpuAcceleration(shouldUseGpu);\r\n      }\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('성능 최적화 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 특정 처리 모드로 전환\r\n * @param mode 처리 모드\r\n */\r\nexport async function switchProcessingMode(mode: ProcessingMode): Promise<boolean> {\r\n  try {\r\n    // GPU 활성화 여부 결정\r\n    const enableGpu = mode === 'gpu-intensive';\r\n    \r\n    // GPU 가속 설정 변경\r\n    if (enableGpu) {\r\n      await setGpuAcceleration(true);\r\n    } else if (mode === 'cpu-intensive' || mode === 'memory-saving') {\r\n      await setGpuAcceleration(false);\r\n      \r\n      // 메모리 절약 모드면 추가 최적화 수행\r\n      if (mode === 'memory-saving') {\r\n        await optimizeMemory(3, true);\r\n      }\r\n    }\r\n    \r\n    // 현재 설정 및 모드 저장 (브라우저 환경인 경우)\r\n    if (typeof window !== 'undefined') {\r\n      // 타입 안전하게 접근\r\n      if (!window.__memoryManager) {\r\n        window.__memoryManager = { settings: {} };\r\n      }\r\n      \r\n      // 설정 업데이트\r\n      if (window.__memoryManager) {\r\n        window.__memoryManager.settings = {\r\n          ...window.__memoryManager.settings,\r\n          processingMode: mode\r\n        };\r\n      }\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('처리 모드 전환 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 일괄 작업 최적화\r\n * @param items 처리할 항목 배열\r\n * @param processFn 항목 처리 함수\r\n * @param batchSize 배치 크기\r\n */\r\nexport async function processBatched<T, R>(\r\n  items: T[],\r\n  processFn: (item: T) => Promise<R>,\r\n  batchSize = 50\r\n): Promise<R[]> {\r\n  const results: R[] = [];\r\n  \r\n  // 항목이 없으면 빈 배열 반환\r\n  if (!items.length) return results;\r\n  \r\n  // 처리 전 시스템 상태 확인\r\n  const status = await getSystemStatus();\r\n  \r\n  // 메모리 사용량이 높으면 배치 크기 줄이기\r\n  if (status.memory.level === MemoryUsageLevel.HIGH) {\r\n    batchSize = Math.max(10, Math.floor(batchSize / 2));\r\n  } else if (status.memory.level === MemoryUsageLevel.CRITICAL) {\r\n    batchSize = Math.max(5, Math.floor(batchSize / 4));\r\n  }\r\n  \r\n  // 배치로 처리\r\n  for (let i = 0; i < items.length; i += batchSize) {\r\n    const batch = items.slice(i, i + batchSize);\r\n    \r\n    // 병렬 처리\r\n    const batchResults = await Promise.all(batch.map(processFn));\r\n    results.push(...batchResults);\r\n    \r\n    // 배치 처리 후 메모리 사용량이 높으면 최적화 수행\r\n    if (i + batchSize < items.length) {\r\n      const currentStatus = await getSystemStatus(true);\r\n      \r\n      if (currentStatus.memory.level === MemoryUsageLevel.HIGH || \r\n          currentStatus.memory.level === MemoryUsageLevel.CRITICAL) {\r\n        await analyzeAndOptimize(true);\r\n        \r\n        // 잠시 딜레이를 주어 GC가 실행될 시간 제공\r\n        await new Promise(resolve => setTimeout(resolve, 200));\r\n      }\r\n    }\r\n  }\r\n  \r\n  return results;\r\n}\r\n\r\n/**\r\n * 백그라운드 모드를 위한 성능 최적화\r\n */\r\nexport async function optimizeForBackground(): Promise<boolean> {\r\n  try {\r\n    // 백그라운드에서는 메모리 사용량 최소화에 집중\r\n    console.log('백그라운드 모드에서 성능 최적화');\r\n    \r\n    // GPU 가속 비활성화\r\n    await setGpuAcceleration(false);\r\n    \r\n    // 메모리 최적화 수행 (레벨 3, 긴급 모드)\r\n    await optimizeMemory(3, true);\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('백그라운드 최적화 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 성능 최적화 수행\r\n * @param level 최적화 레벨\r\n * @param emergency 긴급 모드 여부\r\n */\r\nexport async function optimizePerformance(\r\n  level: OptimizationLevel = OptimizationLevel.MEDIUM,\r\n  emergency: boolean = false\r\n): Promise<boolean> {\r\n  try {\r\n    console.log(`성능 최적화 시작 (레벨: ${level}, 긴급: ${emergency})`);\r\n    \r\n    // 메모리 최적화 실행\r\n    await optimizeMemory(level, emergency);\r\n    \r\n    console.log('성능 최적화 완료');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('성능 최적화 중 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\request-utils.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":66,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'RequestInit' is not defined.","line":78,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":78,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":80,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":80,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":82,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":82,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":91,"column":53,"nodeType":"Identifier","messageId":"undef","endLine":91,"endColumn":61},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":91,"column":72,"nodeType":"Identifier","messageId":"undef","endLine":91,"endColumn":80},{"ruleId":"no-undef","severity":2,"message":"'RequestInit' is not defined.","line":118,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":118,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":145,"column":39,"nodeType":"Identifier","messageId":"undef","endLine":145,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":149,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":149,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":152,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":152,"endColumn":36}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 요청 관련 유틸리티 함수들\r\n */\r\n\r\n// 기본 요청 타임아웃 (30초)\r\nconst DEFAULT_TIMEOUT = 30000;\r\n\r\n// 요청 상태 유형\r\ntype RequestState = 'idle' | 'loading' | 'success' | 'error';\r\n\r\n/**\r\n * 요청 상태 클래스\r\n */\r\nexport class RequestStateManager<T> {\r\n  state: RequestState = 'idle';\r\n  data: T | null = null;\r\n  error: Error | null = null;\r\n  timestamp: number | null = null;\r\n  \r\n  constructor(initialData: T | null = null) {\r\n    this.data = initialData;\r\n  }\r\n  \r\n  setLoading(): void {\r\n    this.state = 'loading';\r\n    this.error = null;\r\n  }\r\n  \r\n  setSuccess(data: T): void {\r\n    this.state = 'success';\r\n    this.data = data;\r\n    this.error = null;\r\n    this.timestamp = Date.now();\r\n  }\r\n  \r\n  setError(error: Error): void {\r\n    this.state = 'error';\r\n    this.error = error;\r\n    this.timestamp = Date.now();\r\n  }\r\n  \r\n  isLoading(): boolean {\r\n    return this.state === 'loading';\r\n  }\r\n  \r\n  isSuccess(): boolean {\r\n    return this.state === 'success';\r\n  }\r\n  \r\n  isError(): boolean {\r\n    return this.state === 'error';\r\n  }\r\n  \r\n  reset(): void {\r\n    this.state = 'idle';\r\n    this.error = null;\r\n  }\r\n}\r\n\r\n/**\r\n * 타임아웃 프로미스 생성 함수\r\n * @param ms 타임아웃 시간(ms)\r\n */\r\nexport function timeoutPromise(ms: number): Promise<never> {\r\n  return new Promise((_, reject) => {\r\n    setTimeout(() => reject(new Error(`Request timed out after ${ms}ms`)), ms);\r\n  });\r\n}\r\n\r\n/**\r\n * 타임아웃이 있는 fetch 요청 함수\r\n * @param url 요청 URL\r\n * @param options fetch 옵션\r\n * @param timeout 타임아웃 시간(ms)\r\n */\r\nexport async function fetchWithTimeout(\r\n  url: string,\r\n  options: RequestInit = {},\r\n  timeout: number = DEFAULT_TIMEOUT\r\n): Promise<Response> {\r\n  return Promise.race([\r\n    fetch(url, options),\r\n    timeoutPromise(timeout)\r\n  ]);\r\n}\r\n\r\n/**\r\n * 에러 응답 처리 함수\r\n * @param response fetch 응답 객체\r\n */\r\nexport async function handleErrorResponse(response: Response): Promise<Response> {\r\n  if (!response.ok) {\r\n    let errorMessage = `HTTP error! status: ${response.status}`;\r\n    \r\n    try {\r\n      const data = await response.json();\r\n      if (data.message || data.error) {\r\n        errorMessage = data.message || data.error;\r\n      }\r\n    } catch (e) {\r\n      // JSON 파싱 오류 무시\r\n    }\r\n    \r\n    throw new Error(errorMessage);\r\n  }\r\n  \r\n  return response;\r\n}\r\n\r\n/**\r\n * JSON 데이터를 가져오는 함수\r\n * @param url 요청 URL\r\n * @param options fetch 옵션\r\n * @param timeout 타임아웃 시간(ms)\r\n */\r\nexport async function fetchJson<T = any>(\r\n  url: string,\r\n  options: RequestInit = {},\r\n  timeout: number = DEFAULT_TIMEOUT\r\n): Promise<T> {\r\n  const response = await fetchWithTimeout(url, {\r\n    ...options,\r\n    headers: {\r\n      ...options.headers,\r\n      'Content-Type': 'application/json',\r\n      'Accept': 'application/json'\r\n    }\r\n  }, timeout);\r\n  \r\n  await handleErrorResponse(response);\r\n  return response.json();\r\n}\r\n\r\n/**\r\n * 요청 디바운스 함수\r\n * @param key 요청 식별자\r\n * @param callback 실행할 콜백 함수\r\n * @param delay 디바운스 지연 시간(ms)\r\n */\r\nexport function debounceRequest<T>(\r\n  key: string,\r\n  callback: () => Promise<T>,\r\n  delay: number = 300\r\n): Promise<T> {\r\n  const requestTimers: Record<string, NodeJS.Timeout> = {};\r\n  \r\n  return new Promise((resolve, reject) => {\r\n    if (requestTimers[key]) {\r\n      clearTimeout(requestTimers[key]);\r\n    }\r\n    \r\n    requestTimers[key] = setTimeout(async () => {\r\n      try {\r\n        const result = await callback();\r\n        resolve(result);\r\n      } catch (error) {\r\n        reject(error);\r\n      } finally {\r\n        delete requestTimers[key];\r\n      }\r\n    }, delay);\r\n  });\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\storage-utils.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":12,"column":41,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":47},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":15,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":15,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":19,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":19,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":31,"column":41,"nodeType":"Identifier","messageId":"undef","endLine":31,"endColumn":47},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":34,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":37,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":37,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":48,"column":41,"nodeType":"Identifier","messageId":"undef","endLine":48,"endColumn":47},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":51,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":51,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":54,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":54,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":64,"column":41,"nodeType":"Identifier","messageId":"undef","endLine":64,"endColumn":47},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":67,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":67,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":70,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":12}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 로컬 스토리지 유틸리티 함수\r\n * 비동기 인터페이스를 제공하여 일관성 있는 사용을 지원합니다.\r\n */\r\n\r\n/**\r\n * 로컬 스토리지에서 데이터 가져오기\r\n * @param key 스토리지 키\r\n * @returns Promise<T | null> 저장된 데이터 또는 null\r\n */\r\nexport async function getLocalStorage<T>(key: string): Promise<T | null> {\r\n  if (typeof window === 'undefined' || !window.localStorage) return null;\r\n  \r\n  try {\r\n    const item = localStorage.getItem(key);\r\n    if (!item) return null;\r\n    return JSON.parse(item) as T;\r\n  } catch (error) {\r\n    console.error(`로컬 스토리지에서 ${key} 가져오기 오류:`, error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * 로컬 스토리지에 데이터 저장\r\n * @param key 스토리지 키\r\n * @param value 저장할 데이터\r\n * @returns Promise<boolean> 저장 성공 여부\r\n */\r\nexport async function setLocalStorage(key: string, value: any): Promise<boolean> {\r\n  if (typeof window === 'undefined' || !window.localStorage) return false;\r\n  \r\n  try {\r\n    localStorage.setItem(key, JSON.stringify(value));\r\n    return true;\r\n  } catch (error) {\r\n    console.error(`로컬 스토리지에 ${key} 저장 오류:`, error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 로컬 스토리지에서 데이터 삭제\r\n * @param key 스토리지 키\r\n * @returns Promise<boolean> 삭제 성공 여부\r\n */\r\nexport async function removeLocalStorage(key: string): Promise<boolean> {\r\n  if (typeof window === 'undefined' || !window.localStorage) return false;\r\n  \r\n  try {\r\n    localStorage.removeItem(key);\r\n    return true;\r\n  } catch (error) {\r\n    console.error(`로컬 스토리지에서 ${key} 삭제 오류:`, error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 로컬 스토리지 비우기\r\n * @returns Promise<boolean> 성공 여부\r\n */\r\nexport async function clearLocalStorage(): Promise<boolean> {\r\n  if (typeof window === 'undefined' || !window.localStorage) return false;\r\n  \r\n  try {\r\n    localStorage.clear();\r\n    return true;\r\n  } catch (error) {\r\n    console.error('로컬 스토리지 비우기 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\string-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\system-monitor.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":14,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":14,"endColumn":28},{"ruleId":"no-unused-vars","severity":2,"message":"'status' is defined but never used.","line":23,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":38,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":38,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":40,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":40,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":40,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[982,1029],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":52,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":52,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":56,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":56,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":56,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":56,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1270,1297],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":68,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":68,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":117,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":117,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":118,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":118,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":120,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":120,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":121,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":121,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":125,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":125,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":137,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":137,"endColumn":14},{"ruleId":"no-unused-vars","severity":2,"message":"'status' is defined but never used.","line":147,"column":52,"nodeType":"Identifier","messageId":"unusedVar","endLine":147,"endColumn":72},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":205,"column":44,"nodeType":"Identifier","messageId":"undef","endLine":205,"endColumn":53},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":211,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":211,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":224,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":224,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":238,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":238,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":240,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":240,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":244,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":244,"endColumn":22}],"suppressedMessages":[],"errorCount":20,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 시스템 모니터링 유틸리티\r\n * \r\n * 메모리, CPU, GPU 등 시스템 리소스 상태를 모니터링합니다.\r\n */\r\n\r\nimport { getMemoryInfo } from './nativeModuleClient';\r\nimport { getGpuInformation } from './gpu-acceleration';\r\nimport { SystemStatus, MemoryUsageLevel, ProcessingMode } from '@/types';\r\nimport { getMemoryUsageLevel } from './enum-converters';\r\n\r\n// 모니터링 상태\r\nlet isMonitoring = false;\r\nlet monitorInterval: NodeJS.Timeout | null = null;\r\nconst CHECK_INTERVAL = 5000; // 5초\r\n\r\n// 시스템 상태 캐시\r\nlet cachedStatus: SystemStatus | null = null;\r\nlet statusUpdateTime = 0;\r\nconst STATUS_TTL = 3000; // 3초\r\n\r\n// 모니터링 이벤트 리스너\r\nconst listeners: Array<(status: SystemStatus) => void> = [];\r\n\r\n/**\r\n * 시스템 모니터링 시작\r\n * @param interval 체크 간격 (ms)\r\n */\r\nexport function startSystemMonitoring(interval: number = CHECK_INTERVAL) {\r\n  if (isMonitoring) return;\r\n  \r\n  isMonitoring = true;\r\n  \r\n  // 즉시 첫 번째 체크 수행\r\n  checkSystemStatus();\r\n  \r\n  // 주기적 체크 설정\r\n  monitorInterval = setInterval(checkSystemStatus, interval);\r\n  \r\n  console.log(`시스템 모니터링 시작 (간격: ${interval}ms)`);\r\n}\r\n\r\n/**\r\n * 시스템 모니터링 중지\r\n */\r\nexport function stopSystemMonitoring() {\r\n  if (!isMonitoring) return;\r\n  \r\n  isMonitoring = false;\r\n  \r\n  if (monitorInterval) {\r\n    clearInterval(monitorInterval);\r\n    monitorInterval = null;\r\n  }\r\n  \r\n  console.log('시스템 모니터링 중지');\r\n}\r\n\r\n/**\r\n * 시스템 상태 확인 및 업데이트\r\n */\r\nasync function checkSystemStatus() {\r\n  try {\r\n    const memoryResponse = await getMemoryInfo();\r\n    const gpuInfo = await getGpuInformation();\r\n    \r\n    if (!memoryResponse.success) {\r\n      console.error('메모리 정보를 가져오는 데 실패했습니다:', memoryResponse.error);\r\n      return;\r\n    }\r\n    \r\n    const memoryInfo = memoryResponse.memoryInfo;\r\n    const percentUsed = memoryInfo.percentUsed;\r\n    const memoryLevel = getMemoryUsageLevel(percentUsed);\r\n    \r\n    // 처리 모드 결정\r\n    let processingMode: ProcessingMode = 'normal';\r\n    \r\n    if (memoryLevel === MemoryUsageLevel.CRITICAL) {\r\n      processingMode = 'memory-saving';\r\n    } else if (memoryLevel === MemoryUsageLevel.HIGH) {\r\n      processingMode = 'cpu-intensive';\r\n    } else if (gpuInfo?.available && gpuInfo?.accelerationEnabled) {\r\n      processingMode = 'gpu-intensive';\r\n    }\r\n    \r\n    // 시스템 상태 업데이트\r\n    const status: SystemStatus = {\r\n      memory: {\r\n        percentUsed,\r\n        level: memoryLevel,\r\n        heapUsedMB: memoryInfo.heapUsedMB,\r\n        rssMB: memoryInfo.rssMB\r\n      },\r\n      processing: {\r\n        mode: processingMode,\r\n        gpuEnabled: Boolean(gpuInfo?.accelerationEnabled)\r\n      },\r\n      optimizations: {\r\n        count: 0, // 이 정보는 현재 API에서 제공하지 않음\r\n        lastTimestamp: 0,\r\n        freedMemoryMB: 0\r\n      },\r\n      timestamp: Date.now()\r\n    };\r\n    \r\n    // 캐시 업데이트\r\n    cachedStatus = status;\r\n    statusUpdateTime = Date.now();\r\n    \r\n    // 리스너에게 알림\r\n    notifyListeners(status);\r\n    \r\n    // 전역 객체에 상태 저장 (브라우저 환경인 경우)\r\n    if (typeof window !== 'undefined') {\r\n      // 타입 안전하게 접근\r\n      if (!window.__memoryManager) {\r\n        window.__memoryManager = { settings: {} };\r\n      }\r\n      if (window.__memoryManager) {\r\n        window.__memoryManager.memoryInfo = memoryInfo;\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('시스템 상태 확인 오류:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * 모든 리스너에게 상태 업데이트 알림\r\n */\r\nfunction notifyListeners(status: SystemStatus) {\r\n  listeners.forEach(listener => {\r\n    try {\r\n      listener(status);\r\n    } catch (error) {\r\n      console.error('시스템 상태 리스너 오류:', error);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * 시스템 상태 업데이트 리스너 등록\r\n * @param listener 상태 업데이트 리스너 함수\r\n * @returns 구독 해제 함수\r\n */\r\nexport function subscribeToSystemStatus(listener: (status: SystemStatus) => void): () => void {\r\n  listeners.push(listener);\r\n  \r\n  // 이미 캐시된 상태가 있다면 즉시 전달\r\n  if (cachedStatus) {\r\n    listener(cachedStatus);\r\n  }\r\n  \r\n  // 리스너 제거 함수 반환\r\n  return () => {\r\n    const index = listeners.indexOf(listener);\r\n    if (index !== -1) {\r\n      listeners.splice(index, 1);\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * 현재 시스템 상태 가져오기\r\n * @param forceRefresh 강제 갱신 여부\r\n */\r\nexport async function getSystemStatus(forceRefresh = false): Promise<SystemStatus> {\r\n  const now = Date.now();\r\n  \r\n  // 캐시가 유효하고 강제 갱신이 아닌 경우 캐시된 상태 반환\r\n  if (cachedStatus && now - statusUpdateTime < STATUS_TTL && !forceRefresh) {\r\n    return cachedStatus;\r\n  }\r\n  \r\n  // 새로운 상태 확인\r\n  await checkSystemStatus();\r\n  \r\n  // 캐시된 상태가 있으면 반환, 없으면 기본값 반환\r\n  return cachedStatus || {\r\n    memory: {\r\n      percentUsed: 0,\r\n      level: MemoryUsageLevel.LOW,\r\n      heapUsedMB: 0,\r\n      rssMB: 0\r\n    },\r\n    processing: {\r\n      mode: 'normal',\r\n      gpuEnabled: false\r\n    },\r\n    optimizations: {\r\n      count: 0,\r\n      lastTimestamp: 0,\r\n      freedMemoryMB: 0\r\n    },\r\n    timestamp: now\r\n  };\r\n}\r\n\r\n/**\r\n * 배터리 상태 확인 (브라우저 환경에서만 작동)\r\n * @returns 배터리 정보 또는 null\r\n */\r\nexport async function getBatteryStatus(): Promise<any> {\r\n  if (typeof navigator === 'undefined' || !navigator.getBattery) {\r\n    return null;\r\n  }\r\n  \r\n  try {\r\n    // 타입 안전하게 접근\r\n    const getBattery = navigator.getBattery;\r\n    if (getBattery) {\r\n      const battery = await getBattery();\r\n      \r\n      return {\r\n        charging: battery.charging,\r\n        level: battery.level,\r\n        chargingTime: battery.chargingTime,\r\n        dischargingTime: battery.dischargingTime\r\n      };\r\n    }\r\n    return null;\r\n  } catch (error) {\r\n    console.error('배터리 상태 확인 오류:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * 네트워크 상태 확인 (브라우저 환경에서만 작동)\r\n */\r\nexport function getNetworkStatus(): any {\r\n  if (typeof navigator === 'undefined') {\r\n    return null;\r\n  }\r\n  \r\n  // 타입 안전하게 접근\r\n  const connection = (navigator as any).connection;\r\n  if (!connection) {\r\n    return { online: navigator.onLine };\r\n  }\r\n  \r\n  return {\r\n    online: navigator.onLine,\r\n    effectiveType: connection.effectiveType,\r\n    downlink: connection.downlink,\r\n    rtt: connection.rtt,\r\n    saveData: connection.saveData\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\type-converters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\types-declarations.d.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'this' is defined but never used.","line":18,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":43},{"ruleId":"no-unused-vars","severity":2,"message":"'ev' is defined but never used.","line":18,"column":45,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":54},{"ruleId":"no-undef","severity":2,"message":"'Event' is not defined.","line":18,"column":49,"nodeType":"Identifier","messageId":"undef","endLine":18,"endColumn":54},{"ruleId":"no-unused-vars","severity":2,"message":"'this' is defined but never used.","line":19,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":47},{"ruleId":"no-unused-vars","severity":2,"message":"'ev' is defined but never used.","line":19,"column":49,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":58},{"ruleId":"no-undef","severity":2,"message":"'Event' is not defined.","line":19,"column":53,"nodeType":"Identifier","messageId":"undef","endLine":19,"endColumn":58},{"ruleId":"no-unused-vars","severity":2,"message":"'this' is defined but never used.","line":20,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":50},{"ruleId":"no-unused-vars","severity":2,"message":"'ev' is defined but never used.","line":20,"column":52,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":61},{"ruleId":"no-undef","severity":2,"message":"'Event' is not defined.","line":20,"column":56,"nodeType":"Identifier","messageId":"undef","endLine":20,"endColumn":61},{"ruleId":"no-unused-vars","severity":2,"message":"'this' is defined but never used.","line":21,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":40},{"ruleId":"no-unused-vars","severity":2,"message":"'ev' is defined but never used.","line":21,"column":42,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":51},{"ruleId":"no-undef","severity":2,"message":"'Event' is not defined.","line":21,"column":46,"nodeType":"Identifier","messageId":"undef","endLine":21,"endColumn":51},{"ruleId":"no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":29,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":29,"endColumn":32},{"ruleId":"no-unused-vars","severity":2,"message":"'settings' is defined but never used.","line":35,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":42},{"ruleId":"no-unused-vars","severity":2,"message":"'interval' is defined but never used.","line":39,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":39,"endColumn":41},{"ruleId":"no-unused-vars","severity":2,"message":"'emergency' is defined but never used.","line":49,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":49,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'MemoryInfo' is not defined.","line":55,"column":42,"nodeType":"Identifier","messageId":"undef","endLine":55,"endColumn":52},{"ruleId":"no-unused-vars","severity":2,"message":"'aggressive' is defined but never used.","line":56,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":56,"endColumn":42}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 추가 타입 선언\r\n * \r\n * 이 파일은 외부 라이브러리나 웹 API에 대한 타입 확장을 정의합니다.\r\n */\r\n\r\n// Navigator.getBattery() API 정의\r\ninterface Navigator {\r\n  getBattery?: () => Promise<BatteryManager>;\r\n  connection?: any;\r\n}\r\n\r\ninterface BatteryManager {\r\n  charging: boolean;\r\n  chargingTime: number;\r\n  dischargingTime: number;\r\n  level: number;\r\n  onchargingchange: ((this: BatteryManager, ev: Event) => any) | null;\r\n  onchargingtimechange: ((this: BatteryManager, ev: Event) => any) | null;\r\n  ondischargingtimechange: ((this: BatteryManager, ev: Event) => any) | null;\r\n  onlevelchange: ((this: BatteryManager, ev: Event) => any) | null;\r\n}\r\n\r\n/**\r\n * 글로벌 타입 확장\r\n */\r\ninterface Window {\r\n  electronAPI?: {\r\n    saveStats: (data: StatsData) => Promise<boolean>;\r\n    loadStats: () => Promise<StatsData[] | null>;\r\n    resetStats: () => Promise<boolean>;\r\n    startTracking: () => Promise<boolean>;\r\n    stopTracking: () => Promise<boolean>;\r\n    getActiveWindow: () => Promise<ActiveWindowInfo | null>;\r\n    saveSettings: (settings: UserSettings) => Promise<boolean>;\r\n    loadSettings: () => Promise<UserSettings | null>;\r\n    getCurrentBrowserInfo: () => Promise<BrowserInfo | null>;\r\n    getDebugInfo: () => Promise<Record<string, unknown>>;\r\n    setUpdateInterval: (interval: number) => Promise<boolean>;\r\n    getSystemInfo: () => Promise<SystemInfo>;\r\n  };\r\n  \r\n  // 가비지 컬렉션 관련\r\n  gc?: () => void;\r\n  \r\n  // 전역 메모리 관리 상태\r\n  __memoryOptimizer?: {\r\n    suggestGarbageCollection: () => void;\r\n    requestGC: (emergency?: boolean) => Promise<any>;\r\n    clearBrowserCaches: () => Promise<boolean>;\r\n    clearStorageCaches: () => boolean;\r\n    checkMemoryUsage: () => Record<string, number> | null;\r\n    forceGC: () => boolean;\r\n    getMemoryUsagePercentage: () => Promise<number>;\r\n    getMemoryInfo: () => Promise<Partial<MemoryInfo>>;\r\n    optimizeMemory: (aggressive?: boolean) => Promise<any>;\r\n  };\r\n  \r\n  // 이미지 캐시 저장소\r\n  __imageResizeCache?: Map<string, any>;\r\n  \r\n  // 오브젝트 URL 저장소\r\n  __objectUrls?: Map<string, string>;\r\n  \r\n  // 스타일 캐시 저장소\r\n  __styleCache?: Record<string, any> | Map<string, any>;\r\n  \r\n  // 메모리 캐시 저장소\r\n  __memoryCache?: Map<string, any>;\r\n  \r\n  // 위젯 캐시 저장소\r\n  __widgetCache?: Map<string, any>;\r\n  \r\n  // 애니메이션 프레임 ID 저장소\r\n  __animationFrameIds?: number[];\r\n  \r\n  // 인터벌 ID 저장소\r\n  __intervalIds?: number[];\r\n  \r\n  // 타임아웃 ID 저장소\r\n  __timeoutIds?: number[];\r\n  \r\n  // 동적 모듈 저장소\r\n  _dynamicModules?: Map<string, any>;\r\n}\r\n\r\n/**\r\n * 시스템 정보 타입\r\n */\r\ninterface SystemInfo {\r\n  platform: string;\r\n  arch: string;\r\n  version: string;\r\n  cpuCount: number;\r\n  memoryTotal: number;\r\n  memoryFree: number;\r\n  uptime: number;\r\n}\r\n\r\n/**\r\n * 활성 창 정보\r\n */\r\ninterface ActiveWindowInfo {\r\n  title: string | null;\r\n  execPath: string | null;\r\n  pid: number;\r\n  appName: string | null;\r\n}\r\n\r\n/**\r\n * 브라우저 정보\r\n */\r\ninterface BrowserInfo {\r\n  name: string | null;\r\n  isGoogleDocs: boolean;\r\n  title: string | null;\r\n}\r\n\r\n/**\r\n * 사용자 설정\r\n */\r\ninterface UserSettings {\r\n  enabledCategories?: {\r\n    docs: boolean;\r\n    office: boolean;\r\n    coding: boolean;\r\n    sns: boolean;\r\n  };\r\n  autoStartMonitoring?: boolean;\r\n  resumeAfterIdle?: boolean;\r\n  darkMode?: boolean;\r\n  windowMode?: 'windowed' | 'fullscreen' | 'fullscreen-auto-hide';\r\n  minimizeToTray?: boolean;\r\n  showTrayNotifications?: boolean;\r\n  reduceMemoryInBackground?: boolean;\r\n  enableMiniView?: boolean;\r\n  useHardwareAcceleration?: boolean;\r\n  processingMode?: string;\r\n  maxMemoryThreshold?: number;\r\n}\r\n\r\n/**\r\n * 통계 데이터\r\n */\r\ninterface StatsData {\r\n  id?: number;\r\n  timestamp: number;\r\n  keyCount: number;\r\n  typingTime: number;\r\n  windowTitle: string | null;\r\n  application: string | null;\r\n  browser: string | null;\r\n  appCategory: string | null;\r\n  totalChars: number;\r\n  wordCount: number;\r\n  accuracy: number;\r\n  wpm: number;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\types.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'NONE' is defined but never used.","line":17,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":7},{"ruleId":"no-unused-vars","severity":2,"message":"'LOW' is defined but never used.","line":18,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":6},{"ruleId":"no-unused-vars","severity":2,"message":"'MEDIUM' is defined but never used.","line":19,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'HIGH' is defined but never used.","line":20,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":7},{"ruleId":"no-unused-vars","severity":2,"message":"'EXTREME' is defined but never used.","line":21,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":10}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 애플리케이션 공통 타입 정의\r\n */\r\n\r\nexport interface MemoryInfo {\r\n  timestamp: number;\r\n  heap_used: number;\r\n  heap_total: number;\r\n  heap_used_mb: number;\r\n  rss?: number;\r\n  rss_mb?: number;\r\n  percent_used: number;\r\n  heap_limit?: number;\r\n}\r\n\r\nexport enum OptimizationLevel {\r\n  NONE = 0,\r\n  LOW = 1,\r\n  MEDIUM = 2,\r\n  HIGH = 3,\r\n  EXTREME = 4\r\n}\r\n\r\nexport interface GCResult {\r\n  success: boolean;\r\n  timestamp: number;\r\n  freedMemory: number;\r\n  freedMB: number;\r\n  error?: string;\r\n}\r\n\r\nexport interface MemoryUsageInfo {\r\n  heapUsed: number;\r\n  heapTotal: number;\r\n  heapUsedMB: number;\r\n  rssMB?: number;\r\n  percentUsed: number;\r\n  timestamp: number;\r\n  heapLimit?: number;\r\n  rss?: number;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\typing-performance.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":70,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":159,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":159,"endColumn":12}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { performGpuComputation } from './nativeModuleClient';\r\n\r\n/**\r\n * 타이핑 데이터 인터페이스\r\n */\r\nexport interface TypingData {\r\n  keyCount: number;\r\n  errors: number;\r\n  typingTime: number;\r\n  content?: string;\r\n  keyIntervals?: number[];\r\n}\r\n\r\n/**\r\n * 타이핑 통계 인터페이스\r\n */\r\nexport interface TypingStatistics {\r\n  wpm: number;\r\n  accuracy: number;\r\n  keyCount: number;\r\n  typingTime: number;\r\n  charCount: number;\r\n  wordCount: number;\r\n  performanceIndex: number;\r\n  consistencyScore: number;\r\n  fatigueAnalysis: {\r\n    score: number;\r\n    timeFactor: number;\r\n    intensityFactor: number;\r\n    recommendation: string;\r\n  };\r\n  accelerated: boolean;\r\n}\r\n\r\n/**\r\n * 타이핑 통계 계산 (GPU 가속화 사용)\r\n * @param data 타이핑 데이터\r\n * @returns Promise<TypingStatistics>\r\n */\r\nexport async function calculateTypingStatistics(data: TypingData): Promise<TypingStatistics> {\r\n  try {\r\n    // GPU 계산 호출\r\n    const response = await performGpuComputation(data, 'typing');\r\n    \r\n    if (!response.success || !response.result) {\r\n      return calculateTypingStatisticsFallback(data);\r\n    }\r\n    \r\n    // 결과 추출\r\n    const result = response.result;\r\n    \r\n    return {\r\n      wpm: result.wpm || 0,\r\n      accuracy: result.accuracy || 100,\r\n      keyCount: data.keyCount,\r\n      typingTime: data.typingTime,\r\n      charCount: result.char_count || 0,\r\n      wordCount: result.word_count || 0,\r\n      performanceIndex: result.performance_index || 0,\r\n      consistencyScore: result.consistency_score || 0,\r\n      fatigueAnalysis: {\r\n        score: result.fatigue_analysis?.score || 0,\r\n        timeFactor: result.fatigue_analysis?.time_factor || 0,\r\n        intensityFactor: result.fatigue_analysis?.intensity_factor || 0,\r\n        recommendation: result.fatigue_analysis?.recommendation || '데이터가 부족합니다',\r\n      },\r\n      accelerated: result.accelerated || false\r\n    };\r\n  } catch (error) {\r\n    console.error('GPU 가속 타이핑 통계 계산 오류:', error);\r\n    return calculateTypingStatisticsFallback(data);\r\n  }\r\n}\r\n\r\n/**\r\n * 타이핑 통계 계산 폴백 버전 (JavaScript로 직접 계산)\r\n * @param data 타이핑 데이터\r\n * @returns TypingStatistics\r\n */\r\nfunction calculateTypingStatisticsFallback(data: TypingData): TypingStatistics {\r\n  const { keyCount, errors, typingTime, content } = data;\r\n  \r\n  // WPM 계산\r\n  const minutes = typingTime / 60000;\r\n  const wpm = minutes > 0 ? Math.round((keyCount / 5) / minutes * 10) / 10 : 0;\r\n  \r\n  // 정확도 계산\r\n  const totalKeystrokes = keyCount + errors;\r\n  const accuracy = totalKeystrokes > 0 \r\n    ? Math.round((keyCount / totalKeystrokes) * 1000) / 10 \r\n    : 100;\r\n  \r\n  // 텍스트 분석\r\n  const charCount = content?.length || 0;\r\n  const wordCount = content?.split(/\\s+/).filter(w => w.length > 0).length || 0;\r\n  \r\n  // 성능 지표\r\n  const performanceIndex = Math.round((wpm * accuracy / 100) * 10) / 10;\r\n  \r\n  // 일관성 점수 계산 (기본값)\r\n  const consistencyScore = 70;\r\n  \r\n  // 피로도 계산\r\n  const timeFactor = Math.round(minutes * 10) / 10;\r\n  const intensityFactor = Math.min(wpm / 40, 3);\r\n  const fatigueScore = Math.min(Math.round(minutes * 5 * (1 + intensityFactor * 0.2)), 100);\r\n  \r\n  return {\r\n    wpm,\r\n    accuracy,\r\n    keyCount,\r\n    typingTime,\r\n    charCount,\r\n    wordCount,\r\n    performanceIndex,\r\n    consistencyScore,\r\n    fatigueAnalysis: {\r\n      score: fatigueScore,\r\n      timeFactor,\r\n      intensityFactor,\r\n      recommendation: getFatigueRecommendation(fatigueScore)\r\n    },\r\n    accelerated: false\r\n  };\r\n}\r\n\r\n/**\r\n * 피로도 권장 사항 생성\r\n */\r\nfunction getFatigueRecommendation(score: number): string {\r\n  if (score > 70) {\r\n    return '휴식이 필요합니다';\r\n  } else if (score > 40) {\r\n    return '짧은 휴식을 고려하세요';\r\n  } else {\r\n    return '좋은 상태입니다';\r\n  }\r\n}\r\n\r\n/**\r\n * 고급 타이핑 패턴 분석 (GPU 가속화 사용)\r\n * @param keyIntervals 키 간격 배열\r\n * @returns Promise<any> 패턴 분석 결과\r\n */\r\nexport async function analyzeTypingPattern(keyIntervals: number[]): Promise<any> {\r\n  try {\r\n    // GPU 계산 호출\r\n    const response = await performGpuComputation({\r\n      keyIntervals,\r\n      size: 'medium'\r\n    }, 'pattern');\r\n    \r\n    if (!response.success || !response.result) {\r\n      return analyzeTypingPatternFallback(keyIntervals);\r\n    }\r\n    \r\n    return response.result;\r\n  } catch (error) {\r\n    console.error('GPU 가속 타이핑 패턴 분석 오류:', error);\r\n    return analyzeTypingPatternFallback(keyIntervals);\r\n  }\r\n}\r\n\r\n/**\r\n * 타이핑 패턴 분석 폴백 버전\r\n * @param keyIntervals 키 간격 배열\r\n * @returns 패턴 분석 결과\r\n */\r\nfunction analyzeTypingPatternFallback(keyIntervals: number[]): any {\r\n  if (!keyIntervals || keyIntervals.length === 0) {\r\n    return {\r\n      avgInterval: 0,\r\n      stdDev: 0,\r\n      consistencyScore: 0,\r\n      fatigueIndicator: false,\r\n      accelerated: false\r\n    };\r\n  }\r\n  \r\n  // 평균 계산\r\n  const sum = keyIntervals.reduce((a, b) => a + b, 0);\r\n  const avg = sum / keyIntervals.length;\r\n  \r\n  // 표준 편차 계산\r\n  const sqDiffs = keyIntervals.map(value => {\r\n    const diff = value - avg;\r\n    return diff * diff;\r\n  });\r\n  const variance = sqDiffs.reduce((a, b) => a + b, 0) / keyIntervals.length;\r\n  const stdDev = Math.sqrt(variance);\r\n  \r\n  // 일관성 점수 계산\r\n  const consistencyScore = 100 / (1 + stdDev / 10);\r\n  \r\n  return {\r\n    avgInterval: Math.round(avg * 100) / 100,\r\n    stdDev: Math.round(stdDev * 100) / 100,\r\n    consistencyScore: Math.round(consistencyScore * 10) / 10,\r\n    fatigueIndicator: avg > 200,\r\n    accelerated: false\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\app\\utils\\validation-utils.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":20,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":20,"endColumn":12}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 데이터 검증 유틸리티 함수들\r\n */\r\n\r\n/**\r\n * 이메일 유효성 검증\r\n * @param email 검증할 이메일 주소\r\n */\r\nexport function isValidEmail(email: string): boolean {\r\n  const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n  return regex.test(email);\r\n}\r\n\r\n/**\r\n * URL 유효성 검증\r\n * @param url 검증할 URL\r\n */\r\nexport function isValidUrl(url: string): boolean {\r\n  try {\r\n    new URL(url);\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 문자열 길이 검증\r\n * @param str 검증할 문자열\r\n * @param min 최소 길이\r\n * @param max 최대 길이\r\n */\r\nexport function isValidLength(str: string, min: number, max: number): boolean {\r\n  const length = str.trim().length;\r\n  return length >= min && length <= max;\r\n}\r\n\r\n/**\r\n * 비밀번호 강도 검증\r\n * @param password 검증할 비밀번호\r\n */\r\nexport function getPasswordStrength(password: string): 'weak' | 'medium' | 'strong' {\r\n  let score = 0;\r\n  \r\n  // 길이 점수\r\n  if (password.length >= 8) score++;\r\n  if (password.length >= 12) score++;\r\n  \r\n  // 복잡성 점수\r\n  if (/[a-z]/.test(password) && /[A-Z]/.test(password)) score++;\r\n  if (/[0-9]/.test(password)) score++;\r\n  if (/[^a-zA-Z0-9]/.test(password)) score++;\r\n  \r\n  // 점수에 따른 강도 반환\r\n  if (score >= 4) return 'strong';\r\n  if (score >= 2) return 'medium';\r\n  return 'weak';\r\n}\r\n\r\n/**\r\n * 숫자 범위 검증\r\n * @param value 검증할 값\r\n * @param min 최소값\r\n * @param max 최대값\r\n */\r\nexport function isInRange(value: number, min: number, max: number): boolean {\r\n  return value >= min && value <= max;\r\n}\r\n\r\n/**\r\n * 필수 필드 검증\r\n * @param obj 검증할 객체\r\n * @param fields 필수 필드 배열\r\n */\r\nexport function hasRequiredFields(obj: Record<string, unknown>, fields: string[]): boolean {\r\n  return fields.every(field => {\r\n    const value = obj[field];\r\n    \r\n    if (value === undefined || value === null) return false;\r\n    if (typeof value === 'string') return value.trim() !== '';\r\n    \r\n    return true;\r\n  });\r\n}\r\n\r\n/**\r\n * 정규식 패턴 검증\r\n * @param value 검증할 값\r\n * @param pattern 정규식 패턴\r\n */\r\nexport function matchesPattern(value: string, pattern: RegExp): boolean {\r\n  return pattern.test(value);\r\n}\r\n\r\n/**\r\n * 한글 문자열 검증\r\n * @param value 검증할 문자열\r\n */\r\nexport function isKorean(value: string): boolean {\r\n  const koreanRegex = /^[가-힣]+$/;\r\n  return koreanRegex.test(value);\r\n}\r\n\r\n/**\r\n * 영문자 문자열 검증\r\n * @param value 검증할 문자열\r\n */\r\nexport function isAlphabetic(value: string): boolean {\r\n  const alphaRegex = /^[a-zA-Z]+$/;\r\n  return alphaRegex.test(value);\r\n}\r\n\r\n/**\r\n * 알파벳과 숫자만 포함하는 문자열 검증\r\n * @param value 검증할 문자열\r\n */\r\nexport function isAlphanumeric(value: string): boolean {\r\n  const alphanumericRegex = /^[a-zA-Z0-9]+$/;\r\n  return alphanumericRegex.test(value);\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\lib\\mysql.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":9,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":10,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":10,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":11,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":12,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":33,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":33,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":35,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":35,"endColumn":12}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import mysql from 'mysql2/promise';\r\nimport dotenv from 'dotenv';\r\n\r\ndotenv.config();\r\n\r\n\r\n// 연결 풀 생성\r\nconst pool = mysql.createPool({\r\n  host: process.env.DB_HOST || 'localhost',\r\n  user: process.env.DB_USER || 'root',\r\n  password: process.env.DB_PASSWORD || '',\r\n  database: process.env.DB_NAME || 'typing_stats', // 데이터베이스 이름 지정\r\n  waitForConnections: true,\r\n  connectionLimit: 10,\r\n  queueLimit: 0\r\n});\r\n\r\n// 테이블 생성을 위한 초기화 함수\r\nexport async function initializeDatabase() {\r\n  try {\r\n    // TypingLog 테이블 생성\r\n    await pool.query(`\r\n      CREATE TABLE IF NOT EXISTS typing_logs (\r\n        id INT AUTO_INCREMENT PRIMARY KEY,\r\n        content TEXT NOT NULL,\r\n        key_count INT NOT NULL,\r\n        typing_time INT NOT NULL,\r\n        timestamp DATETIME NOT NULL,\r\n        window_title VARCHAR(255),\r\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\r\n      );\r\n    `);\r\n    console.error('데이터베이스 초기화 완료');\r\n  } catch (error) {\r\n    console.error('데이터베이스 초기화 오류:', error);\r\n  }\r\n}\r\n\r\n// DB 연결 풀 내보내기\r\nexport default pool;","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\lib\\prisma.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'global' is not defined.","line":4,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":4,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":11,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":12}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PrismaClient } from '@prisma/client';\r\n\r\n// PrismaClient를 싱글톤으로 구현\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\n\r\nexport const prisma = globalForPrisma.prisma || \r\n  new PrismaClient({\r\n    log: ['query', 'error', 'warn'],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\main\\memory-manager.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'__dirname' is not defined.","line":29,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'__dirname' is not defined.","line":30,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":30,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":32,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":32,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":33,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":33,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'__dirname' is not defined.","line":57,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":57,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'__dirname' is not defined.","line":58,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":58,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":59,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":59,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":60,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":60,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":120,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":120,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":132,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":132,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":147,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":147,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'global' is not defined.","line":199,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":199,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'global' is not defined.","line":200,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":200,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":344,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":344,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'global' is not defined.","line":347,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":347,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'global' is not defined.","line":348,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":348,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":352,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":352,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":355,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":355,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":428,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":428,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'global' is not defined.","line":431,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":431,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'global' is not defined.","line":432,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":432,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":446,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":446,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":464,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":464,"endColumn":32}],"suppressedMessages":[],"errorCount":23,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { app } from 'electron';\r\nimport { appState, MEMORY_CHECK_INTERVAL, HIGH_MEMORY_THRESHOLD } from './constants.js';\r\nimport { debugLog } from './utils.js';\r\nimport path from 'path';\r\nimport fs from 'fs';\r\n\r\n// 메모리 관리 상태\r\nlet lastMemoryCheck = 0;\r\nlet memoryCheckInterval = null;\r\nlet optimizeOnIdle = true;\r\nlet lastOptimizationTime = 0;\r\n\r\n// 네이티브 모듈 로딩 상태\r\nlet nativeModulePromise = null;\r\nlet nativeModule = null;\r\n\r\n// 네이티브 모듈 로드 함수\r\nasync function loadNativeModule() {\r\n  if (nativeModulePromise) return nativeModulePromise;\r\n\r\n  nativeModulePromise = (async () => {\r\n    // 다양한 경로 시도\r\n    const possiblePaths = [\r\n      path.join(app.getAppPath(), 'native-modules', 'target', 'release', 'typing_stats_native.node'),\r\n      path.join(app.getAppPath(), 'native-modules', 'target', 'debug', 'typing_stats_native.node'),\r\n      path.join(app.getAppPath(), '..', 'native-modules', 'target', 'release', 'typing_stats_native.node'),\r\n      path.join(app.getAppPath(), '..', 'native-modules', 'target', 'debug', 'typing_stats_native.node'),\r\n      // __dirname으로부터의 상대 경로\r\n      path.join(__dirname, '..', '..', 'native-modules', 'target', 'release', 'typing_stats_native.node'),\r\n      path.join(__dirname, '..', '..', 'native-modules', 'target', 'debug', 'typing_stats_native.node'),\r\n      // 추가 경로\r\n      path.join(process.cwd(), 'native-modules', 'target', 'release', 'typing_stats_native.node'),\r\n      path.join(process.cwd(), 'native-modules', 'target', 'debug', 'typing_stats_native.node')\r\n    ];\r\n    \r\n    // 존재하는 모듈 파일 찾기\r\n    for (const modulePath of possiblePaths) {\r\n      if (fs.existsSync(modulePath)) {\r\n        debugLog(`네이티브 모듈 발견: ${modulePath}`);\r\n        try {\r\n          // ESM에서는 .node 파일을 직접 import할 수 없음\r\n          // Electron/Node.js 환경에서는 createRequire를 사용하여 CommonJS 모듈 로드\r\n          const { createRequire } = await import('module');\r\n          const require = createRequire(import.meta.url);\r\n          nativeModule = require(modulePath);\r\n          debugLog('네이티브 모듈 로드 성공');\r\n          return nativeModule;\r\n        } catch (moduleLoadError) {\r\n          debugLog(`발견된 모듈 로드 실패: ${moduleLoadError.message}`);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // 폴백 모듈 로드 시도\r\n    const possibleFallbackPaths = [\r\n      path.join(app.getAppPath(), 'src', 'server', 'native', 'fallback', 'index.js'),\r\n      path.join(__dirname, '..', 'server', 'native', 'fallback', 'index.js'),\r\n      path.join(__dirname, '..', 'server', 'native', 'fallback.js'),\r\n      path.join(process.cwd(), 'src', 'server', 'native', 'fallback', 'index.js'),\r\n      path.join(process.cwd(), 'src', 'server', 'native', 'fallback.js')\r\n    ];\r\n    \r\n    for (const fallbackPath of possibleFallbackPaths) {\r\n      if (fs.existsSync(fallbackPath)) {\r\n        try {\r\n          const fallbackModule = await import(fallbackPath);\r\n          nativeModule = fallbackModule.default || fallbackModule;\r\n          debugLog(`폴백 모듈 로드 성공: ${fallbackPath}`);\r\n          return nativeModule;\r\n        } catch (fallbackError) {\r\n          debugLog(`폴백 모듈 로드 실패: ${fallbackError.message}`);\r\n        }\r\n      }\r\n    }\r\n    \r\n    debugLog('네이티브 또는 폴백 모듈을 찾을 수 없음');\r\n    return null;\r\n  })();\r\n\r\n  return nativeModulePromise;\r\n}\r\n\r\n/**\r\n * 네이티브 모듈 사용 가능 여부 확인\r\n * @returns {Promise<boolean>} 네이티브 모듈 사용 가능 여부\r\n */\r\nasync function isNativeModuleAvailable() {\r\n  await loadNativeModule();\r\n  return nativeModule !== null;\r\n}\r\n\r\n/**\r\n * 메모리 관리자 초기화\r\n * @param {Object} options 초기화 옵션\r\n */\r\nfunction initializeMemoryManager(options = {}) {\r\n  const {\r\n    checkInterval = MEMORY_CHECK_INTERVAL, \r\n    optimizeIdle = true\r\n  } = options;\r\n  \r\n  debugLog('메모리 관리자 초기화');\r\n  \r\n  optimizeOnIdle = optimizeIdle;\r\n  \r\n  // 주기적 메모리 체크 시작\r\n  startMemoryMonitoring(checkInterval);\r\n  \r\n  // 초기 메모리 사용량 체크\r\n  checkMemoryUsage();\r\n}\r\n\r\n/**\r\n * 메모리 모니터링 시작\r\n * @param {number} interval 체크 간격 (ms)\r\n */\r\nfunction startMemoryMonitoring(interval = MEMORY_CHECK_INTERVAL) {\r\n  stopMemoryMonitoring(); // 기존 인터벌 정리\r\n  \r\n  memoryCheckInterval = setInterval(() => {\r\n    checkMemoryUsage();\r\n  }, interval);\r\n  \r\n  debugLog(`메모리 모니터링 시작 (간격: ${interval}ms)`);\r\n}\r\n\r\n/**\r\n * 메모리 모니터링 중지\r\n */\r\nfunction stopMemoryMonitoring() {\r\n  if (memoryCheckInterval) {\r\n    clearInterval(memoryCheckInterval);\r\n    memoryCheckInterval = null;\r\n    debugLog('메모리 모니터링 중지됨');\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 사용량 확인 및 필요시 최적화\r\n * @returns {Object} 메모리 사용량 정보\r\n */\r\nfunction checkMemoryUsage() {\r\n  try {\r\n    lastMemoryCheck = Date.now();\r\n    \r\n    // 현재 메모리 사용량 가져오기\r\n    const memoryUsage = process.memoryUsage();\r\n    const heapUsed = memoryUsage.heapUsed;\r\n    const heapTotal = memoryUsage.heapTotal;\r\n    const rss = memoryUsage.rss;\r\n    \r\n    // MB 단위로 변환\r\n    const heapUsedMB = Math.round(heapUsed / (1024 * 1024) * 100) / 100;\r\n    const heapTotalMB = Math.round(heapTotal / (1024 * 1024) * 100) / 100;\r\n    const rssMB = Math.round(rss / (1024 * 1024) * 100) / 100;\r\n    \r\n    // 메모리 사용량 상태 업데이트\r\n    appState.memoryUsage = {\r\n      lastCheck: lastMemoryCheck,\r\n      heapUsed,\r\n      heapTotal,\r\n      rss,\r\n      heapUsedMB,\r\n      heapTotalMB,\r\n      rssMB,\r\n      percentUsed: Math.round((heapUsed / heapTotal) * 100)\r\n    };\r\n    \r\n    // 메모리 임계치 초과 시 최적화 실행\r\n    if (heapUsed > HIGH_MEMORY_THRESHOLD) {\r\n      // 마지막 최적화로부터 일정 시간 경과한 경우에만 실행\r\n      const now = Date.now();\r\n      if (now - lastOptimizationTime > 60000) { // 1분에 최대 1회\r\n        debugLog(`메모리 사용량 높음 (${heapUsedMB}MB), 최적화 실행`);\r\n        forceMemoryOptimization(2, heapUsed > HIGH_MEMORY_THRESHOLD * 1.5);\r\n        lastOptimizationTime = now;\r\n      }\r\n    }\r\n    \r\n    return appState.memoryUsage;\r\n  } catch (error) {\r\n    debugLog(`메모리 사용량 확인 중 오류: ${error.message}`);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * 백그라운드 모드를 위한 메모리 최적화\r\n * 백그라운드에서 실행 중일 때 메모리 사용량 최소화\r\n */\r\nfunction optimizeMemoryForBackground() {\r\n  try {\r\n    debugLog('백그라운드 메모리 최적화 실행');\r\n    \r\n    // 주요 리소스 정리 및 메모리 최적화\r\n    forceMemoryOptimization(3, false);\r\n    \r\n    // 가비지 컬렉션 권장\r\n    if (global.gc) {\r\n      global.gc();\r\n      debugLog('GC 강제 수행 완료');\r\n    }\r\n    \r\n    // 네이티브 모듈 메모리 최적화 실행\r\n    if (isNativeModuleAvailable() && typeof nativeModule.optimize_memory === 'function') {\r\n      try {\r\n        nativeModule.optimize_memory('high', true);\r\n        debugLog('네이티브 메모리 최적화 완료');\r\n      } catch (nativeError) {\r\n        debugLog(`네이티브 메모리 최적화 실패: ${nativeError.message}`);\r\n      }\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    debugLog(`백그라운드 메모리 최적화 중 오류: ${error.message}`);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 리소스 정리\r\n * 불필요한 메모리 리소스 정리 및 최적화\r\n * @param {boolean} aggressive 적극적 정리 여부\r\n */\r\nfunction freeUpMemoryResources(aggressive = false) {\r\n  try {\r\n    debugLog(`메모리 리소스 정리 ${aggressive ? '(적극적 모드)' : ''}`);\r\n    \r\n    // 가비지 컬렉션 수행\r\n    performGarbageCollection(aggressive);\r\n    \r\n    // 네이티브 모듈 메모리 최적화\r\n    if (isNativeModuleAvailable() && typeof nativeModule.release_unused_resources === 'function') {\r\n      try {\r\n        nativeModule.release_unused_resources();\r\n        debugLog('네이티브 리소스 정리 완료');\r\n      } catch (nativeError) {\r\n        debugLog(`네이티브 리소스 정리 실패: ${nativeError.message}`);\r\n      }\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    debugLog(`메모리 리소스 정리 중 오류: ${error.message}`);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 주기적인 메모리 최적화 설정\r\n * 설정에 따라 주기적으로 메모리 최적화 수행\r\n * @param {Object} settings 메모리 최적화 설정\r\n */\r\nfunction setupMemoryMonitoring(settings = {}) {\r\n  const {\r\n    interval = MEMORY_CHECK_INTERVAL,\r\n    enableAutoOptimize = true,\r\n    threshold = HIGH_MEMORY_THRESHOLD\r\n  } = settings;\r\n  \r\n  debugLog(`메모리 모니터링 설정 (간격: ${interval}ms, 자동 최적화: ${enableAutoOptimize}, 임계치: ${threshold / (1024 * 1024)}MB)`);\r\n  \r\n  // 기존 모니터링 중지 및 재설정\r\n  stopMemoryMonitoring();\r\n  \r\n  if (enableAutoOptimize) {\r\n    startMemoryMonitoring(interval);\r\n  }\r\n  \r\n  return true;\r\n}\r\n\r\n/**\r\n * 강제 메모리 최적화 수행\r\n * @param {number} level 최적화 수준 (1-3)\r\n * @param {boolean} emergency 긴급 상황 여부\r\n * @returns {Promise<Object>} 최적화 결과\r\n */\r\nasync function forceMemoryOptimization(level = 2, emergency = false) {\r\n  try {\r\n    debugLog(`강제 메모리 최적화 수행 (레벨: ${level}, 긴급: ${emergency})`);\r\n    \r\n    let result;\r\n    \r\n    // 네이티브 모듈 사용 가능한 경우\r\n    if (await isNativeModuleAvailable() && nativeModule) {\r\n      // 네이티브 최적화 수준 매핑\r\n      const nativeLevel = ['normal', 'low', 'medium', 'high', 'critical'][level] || 'medium';\r\n      \r\n      try {\r\n        // 함수 이름 확인 (다양한 가능성 대비)\r\n        const optimizeFuncNames = [\r\n          'optimize_memory',\r\n          'optimize_memory_async',\r\n          'performMemoryOptimization'\r\n        ];\r\n        \r\n        let optimizeFunc = null;\r\n        for (const funcName of optimizeFuncNames) {\r\n          if (typeof nativeModule[funcName] === 'function') {\r\n            optimizeFunc = nativeModule[funcName];\r\n            break;\r\n          }\r\n        }\r\n        \r\n        if (optimizeFunc) {\r\n          const jsonResult = optimizeFunc(nativeLevel, emergency);\r\n          result = typeof jsonResult === 'string' ? JSON.parse(jsonResult) : jsonResult;\r\n          debugLog(`네이티브 메모리 최적화 완료: ${result.freed_mb || 0}MB 정리됨`);\r\n        } else {\r\n          throw new Error('메모리 최적화 함수를 찾을 수 없음');\r\n        }\r\n      } catch (nativeError) {\r\n        debugLog(`네이티브 메모리 최적화 실패, JS 구현으로 폴백: ${nativeError.message}`);\r\n        result = await optimizeMemoryWithJS(level, emergency);\r\n      }\r\n    } else {\r\n      // JS 기반 메모리 최적화 수행\r\n      result = await optimizeMemoryWithJS(level, emergency);\r\n    }\r\n    \r\n    return result;\r\n  } catch (error) {\r\n    debugLog(`메모리 최적화 중 오류: ${error.message}`);\r\n    return {\r\n      success: false,\r\n      error: error.message,\r\n      timestamp: Date.now()\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * JS 기반 메모리 최적화 수행\r\n * 네이티브 모듈 사용 불가능한 경우 폴백 구현\r\n * @param {number} level 최적화 수준 (1-3)\r\n * @param {boolean} emergency 긴급 상황 여부\r\n * @returns {Promise<Object>} 최적화 결과\r\n */\r\nasync function optimizeMemoryWithJS(level, emergency) {\r\n  debugLog(`JS 기반 메모리 최적화 실행 (레벨: ${level}, 긴급: ${emergency})`);\r\n  \r\n  const memoryBefore = process.memoryUsage();\r\n  \r\n  // 가비지 컬렉션 수행\r\n  if (global.gc) {\r\n    global.gc(emergency);\r\n  }\r\n  \r\n  // 메모리 사용량에 따른 대기 시간 적용\r\n  await new Promise(resolve => setTimeout(resolve, 100));\r\n  \r\n  // 메모리 최적화 후 사용량 확인\r\n  const memoryAfter = process.memoryUsage();\r\n  const freedMemory = Math.max(0, memoryBefore.heapUsed - memoryAfter.heapUsed);\r\n  const freedMB = Math.round(freedMemory / (1024 * 1024) * 100) / 100;\r\n  \r\n  debugLog(`JS 메모리 최적화 완료: ${freedMB}MB 정리됨`);\r\n  \r\n  return {\r\n    success: true,\r\n    optimization_level: level,\r\n    memory_before: {\r\n      heap_used: memoryBefore.heapUsed,\r\n      heap_total: memoryBefore.heapTotal,\r\n      rss: memoryBefore.rss,\r\n      heap_used_mb: Math.round(memoryBefore.heapUsed / (1024 * 1024) * 100) / 100,\r\n      percent_used: Math.round((memoryBefore.heapUsed / memoryBefore.heapTotal) * 100)\r\n    },\r\n    memory_after: {\r\n      heap_used: memoryAfter.heapUsed,\r\n      heap_total: memoryAfter.heapTotal,\r\n      rss: memoryAfter.rss,\r\n      heap_used_mb: Math.round(memoryAfter.heapUsed / (1024 * 1024) * 100) / 100,\r\n      percent_used: Math.round((memoryAfter.heapUsed / memoryAfter.heapTotal) * 100)\r\n    },\r\n    freed_memory: freedMemory,\r\n    freed_mb: freedMB,\r\n    timestamp: Date.now()\r\n  };\r\n}\r\n\r\n/**\r\n * 강제 가비지 컬렉션 수행\r\n * @param {boolean} emergency 긴급 상황 여부\r\n * @returns {Promise<Object>} GC 결과\r\n */\r\nasync function performGarbageCollection(emergency = false) {\r\n  try {\r\n    debugLog(`강제 가비지 컬렉션 수행 (긴급: ${emergency})`);\r\n    \r\n    let result;\r\n    \r\n    if (await isNativeModuleAvailable()) {\r\n      // 네이티브 GC 수행\r\n      try {\r\n        const jsonResult = nativeModule.force_garbage_collection();\r\n        result = typeof jsonResult === 'string' ? JSON.parse(jsonResult) : jsonResult;\r\n        debugLog(`네이티브 GC 완료: ${result.freed_mb || 0}MB 정리됨`);\r\n      } catch (nativeError) {\r\n        debugLog(`네이티브 GC 실패, JS 구현으로 폴백: ${nativeError.message}`);\r\n        // JavaScript 기반 GC 수행\r\n        result = performJsGarbageCollection(emergency);\r\n      }\r\n    } else {\r\n      // JavaScript 기반 GC 수행\r\n      result = performJsGarbageCollection(emergency);\r\n    }\r\n    \r\n    return result;\r\n  } catch (error) {\r\n    debugLog(`가비지 컬렉션 중 오류: ${error.message}`);\r\n    return {\r\n      success: false,\r\n      error: error.message,\r\n      timestamp: Date.now()\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * JavaScript 기반 가비지 컬렉션 수행\r\n * @param {boolean} emergency 긴급 상황 여부\r\n * @returns {Object} GC 결과\r\n */\r\nfunction performJsGarbageCollection(emergency) {\r\n  const memoryBefore = process.memoryUsage();\r\n  \r\n  // JavaScript GC 수행\r\n  if (global.gc) {\r\n    global.gc(emergency);\r\n    debugLog('JavaScript GC 강제 수행 완료');\r\n  } else {\r\n    // GC 유도를 위한 대용량 객체 생성 및 해제\r\n    // 사용되지 않는 변수는 선언 자체 제외\r\n    const tmpArrays = [];\r\n    for (let i = 0; i < 10; i++) {\r\n      tmpArrays.push(new Array(100000).fill(0));\r\n    }\r\n    // 배열 비우기\r\n    tmpArrays.length = 0;\r\n    debugLog('JavaScript GC 유도 완료');\r\n  }\r\n  \r\n  const memoryAfter = process.memoryUsage();\r\n  const freedMemory = Math.max(0, memoryBefore.heapUsed - memoryAfter.heapUsed);\r\n  const freedMB = Math.round(freedMemory / (1024 * 1024) * 100) / 100;\r\n  \r\n  return {\r\n    success: true,\r\n    freed_memory: freedMemory,\r\n    freed_mb: freedMB,\r\n    timestamp: Date.now()\r\n  };\r\n}\r\n\r\n/**\r\n * 현재 메모리 사용량 가져오기\r\n * @returns {Promise<Object>} 메모리 정보\r\n */\r\nasync function getCurrentMemoryUsage() {\r\n  try {\r\n    const memoryUsage = process.memoryUsage();\r\n    const heapUsed = memoryUsage.heapUsed;\r\n    const heapTotal = memoryUsage.heapTotal;\r\n    const rss = memoryUsage.rss;\r\n    \r\n    // MB 단위로 변환\r\n    const heapUsedMB = Math.round(heapUsed / (1024 * 1024) * 100) / 100;\r\n    const heapTotalMB = Math.round(heapTotal / (1024 * 1024) * 100) / 100;\r\n    const rssMB = Math.round(rss / (1024 * 1024) * 100) / 100;\r\n    \r\n    // 네이티브 모듈에서 추가 정보 가져오기\r\n    let additionalInfo = {};\r\n    if (await isNativeModuleAvailable() && typeof nativeModule.get_memory_info === 'function') {\r\n      try {\r\n        const jsonResult = nativeModule.get_memory_info();\r\n        const nativeInfo = typeof jsonResult === 'string' ? JSON.parse(jsonResult) : jsonResult;\r\n        additionalInfo = {\r\n          percent_used: nativeInfo.percent_used,\r\n          heap_limit: nativeInfo.heap_limit\r\n        };\r\n      } catch (nativeError) {\r\n        debugLog(`네이티브 메모리 정보 가져오기 실패: ${nativeError.message}`);\r\n      }\r\n    }\r\n    \r\n    return {\r\n      timestamp: Date.now(),\r\n      heap_used: heapUsed,\r\n      heap_total: heapTotal,\r\n      rss: rss,\r\n      heap_used_mb: heapUsedMB,\r\n      heap_total_mb: heapTotalMB,\r\n      rss_mb: rssMB,\r\n      percent_used: additionalInfo.percent_used || Math.round((heapUsed / heapTotal) * 100),\r\n      heap_limit: additionalInfo.heap_limit || null\r\n    };\r\n  } catch (error) {\r\n    debugLog(`메모리 정보 가져오기 오류: ${error.message}`);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 관리자 상태 가져오기\r\n * @returns {Object} 메모리 관리자 상태\r\n */\r\nfunction getMemoryManagerStats() {\r\n  return {\r\n    lastMemoryCheck,\r\n    isMonitoring: memoryCheckInterval !== null,\r\n    optimizeOnIdle,\r\n    lastOptimizationTime,\r\n    nativeModuleAvailable: isNativeModuleAvailable(),\r\n    memoryUsage: appState.memoryUsage\r\n  };\r\n}\r\n\r\n// 모듈 내보내기 - ESM 스타일\r\nexport {\r\n  initializeMemoryManager,\r\n  startMemoryMonitoring,\r\n  stopMemoryMonitoring,\r\n  checkMemoryUsage,\r\n  forceMemoryOptimization,\r\n  performGarbageCollection,\r\n  getCurrentMemoryUsage,\r\n  getMemoryManagerStats,\r\n  freeUpMemoryResources,\r\n  optimizeMemoryForBackground,\r\n  setupMemoryMonitoring,\r\n  isNativeModuleAvailable\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\native-modules\\index.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'require' is not defined.","line":2,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":2,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'require' is not defined.","line":3,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":3,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":7,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":7,"endColumn":10},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":7,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":7,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[117,156],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":11,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":19,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":19,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":22,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'__dirname' is not defined.","line":27,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":27,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'__dirname' is not defined.","line":29,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'__dirname' is not defined.","line":31,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":31,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'__dirname' is not defined.","line":32,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":32,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'__dirname' is not defined.","line":34,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'__dirname' is not defined.","line":35,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":35,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'__dirname' is not defined.","line":36,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":36,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'__dirname' is not defined.","line":37,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":37,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'require' is not defined.","line":56,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":56,"endColumn":29},{"ruleId":"no-unused-vars","severity":2,"message":"'moduleError' is assigned a value but never used.","line":63,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":63,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'moduleError' is assigned a value but never used.","line":63,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":63,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":74,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":74,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'global' is not defined.","line":93,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":93,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'global' is not defined.","line":94,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":94,"endColumn":15},{"ruleId":"no-unused-vars","severity":2,"message":"'emergency' is defined but never used.","line":100,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":100,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'emergency' is defined but never used. Allowed unused args must match /^_/u.","line":100,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":100,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'global' is not defined.","line":110,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":110,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":112,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":112,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'global' is not defined.","line":113,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":113,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":114,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":114,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'module' is not defined.","line":138,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":138,"endColumn":7}],"suppressedMessages":[],"errorCount":25,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// 네이티브 모듈 로더 - 강화된 버전\nconst path = require('path');\nconst fs = require('fs');\n\n// 디버깅용 로그\nfunction log(message) {\n  console.log(`[네이티브 모듈 로더] ${message}`);\n}\n\nfunction logError(message) {\n  console.error(`[네이티브 모듈 로더 오류] ${message}`);\n}\n\n// 플랫폼별 파일 확장자\nconst extension = {\n  'win32': '.dll',\n  'darwin': '.dylib',\n  'linux': '.so'\n}[process.platform];\n\n// 플랫폼별 접두사\nconst prefix = process.platform === 'win32' ? '' : 'lib';\n\n// 가능한 모듈 경로 탐색\nconst possiblePaths = [\n  // 기본 .node 파일\n  path.join(__dirname, 'typing_stats_native.node'),\n  // OS 특정 라이브러리 파일\n  path.join(__dirname, `${prefix}typing_stats_native${extension}`),\n  // 대체 경로\n  path.join(__dirname, '..', '..', 'native-modules', 'typing_stats_native.node'),\n  path.join(__dirname, '..', '..', 'native-modules', `${prefix}typing_stats_native${extension}`),\n  // 빌드 디렉토리 경로\n  path.join(__dirname, '..', '..', 'native-modules', 'target', 'release', 'typing_stats_native.node'),\n  path.join(__dirname, '..', '..', 'native-modules', 'target', 'release', `${prefix}typing_stats_native${extension}`),\n  path.join(__dirname, '..', '..', 'native-modules', 'target', 'debug', 'typing_stats_native.node'),\n  path.join(__dirname, '..', '..', 'native-modules', 'target', 'debug', `${prefix}typing_stats_native${extension}`)\n];\n\n// 네이티브 모듈 로드\nlet nativeModule = null;\nlet moduleError = null;\nlet loadedPath = null;\n\nlog('네이티브 모듈 로드 시도 중...');\n\n// 존재하는 모든 파일 경로 출력\nconst existingPaths = possiblePaths.filter(p => fs.existsSync(p));\nlog(`존재하는 파일 경로: ${existingPaths.join(', ') || '없음'}`);\n\n// 모든 가능한 경로 시도\nfor (const modulePath of possiblePaths) {\n  try {\n    if (fs.existsSync(modulePath)) {\n      log(`발견된 모듈 경로: ${modulePath}`);\n      nativeModule = require(modulePath);\n      loadedPath = modulePath;\n      log(`네이티브 모듈 로드 성공: ${modulePath}`);\n      break;\n    }\n  } catch (err) {\n    logError(`${modulePath} 로드 실패: ${err.message}`);\n    moduleError = err;\n  }\n}\n\n// 폴백 구현\nif (!nativeModule) {\n  logError('네이티브 모듈을 로드할 수 없어 자바스크립트 폴백 구현을 사용합니다');\n  \n  // 간단한 폴백 구현\n  nativeModule = {\n    get_memory_info: () => {\n      const memInfo = process.memoryUsage();\n      const heapUsedMB = Math.round(memInfo.heapUsed / 1024 / 1024 * 100) / 100;\n      const heapTotalMB = Math.round(memInfo.heapTotal / 1024 / 1024 * 100) / 100;\n      const rssMB = Math.round(memInfo.rss / 1024 / 1024 * 100) / 100;\n      \n      return JSON.stringify({\n        heap_used: memInfo.heapUsed,\n        heap_total: memInfo.heapTotal,\n        heap_used_mb: heapUsedMB,\n        heap_total_mb: heapTotalMB,\n        rss: memInfo.rss,\n        rss_mb: rssMB,\n        percent_used: Math.round(memInfo.heapUsed / memInfo.heapTotal * 100),\n        external: memInfo.external || 0,\n        timestamp: Date.now()\n      });\n    },\n    \n    force_garbage_collection: () => {\n      if (global.gc) {\n        global.gc();\n        return true;\n      }\n      return false;\n    },\n    \n    optimize_memory: (level, emergency) => {\n      const result = {\n        success: true,\n        optimization_level: level,\n        freed_memory: 0,\n        duration: 0,\n        error: null,\n        timestamp: Date.now()\n      };\n      \n      if (global.gc) {\n        const startTime = Date.now();\n        const memBefore = process.memoryUsage();\n        global.gc();\n        const memAfter = process.memoryUsage();\n        const duration = Date.now() - startTime;\n        \n        result.freed_memory = memBefore.heapUsed - memAfter.heapUsed;\n        result.freed_mb = Math.round((result.freed_memory / 1024 / 1024) * 100) / 100;\n        result.duration = duration;\n      }\n      \n      return JSON.stringify(result);\n    },\n    \n    is_using_fallback: () => true\n  };\n}\n\n// 모듈을 동적으로 확장하여 폴백 확인 메서드 추가\nif (nativeModule && !nativeModule.is_using_fallback) {\n  nativeModule.is_using_fallback = () => false;\n}\n\nif (nativeModule && !nativeModule.get_loaded_path) {\n  nativeModule.get_loaded_path = () => loadedPath || 'fallback-implementation';\n}\n\nmodule.exports = nativeModule;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\preload.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'require' is not defined.","line":1,"column":40,"nodeType":"Identifier","messageId":"undef","endLine":1,"endColumn":47},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":11,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":17,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":17,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":17,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":17,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[461,498],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":34,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":34,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":34,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[816,842],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":42,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":42,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":42,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":42,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[954,980],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":51,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":51,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":51,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":51,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1131,1165],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":60,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":60,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":60,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":60,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1358,1387],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":69,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":69,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":69,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":69,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1577,1602],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":78,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":78,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":78,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":78,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1761,1796],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":87,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":87,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":87,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":87,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1949,1973],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":96,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":96,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":96,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":96,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2160,2205],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":107,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":107,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":112,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":112,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":112,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":112,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2630,2669],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":128,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":128,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":128,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":128,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2995,3030],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":137,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":137,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":137,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":137,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3198,3235],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":152,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":152,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":157,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":157,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":161,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":161,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":161,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":161,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3914,3947],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":185,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":185,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":185,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":185,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4557,4598],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":215,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":215,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":220,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":220,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":220,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":220,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5392,5434],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":236,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":236,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":264,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":264,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":269,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":269,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":269,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":269,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6617,6653],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":273,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":273,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":292,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":292,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":297,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":297,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":297,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":297,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7307,7343],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":315,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":315,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":315,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":315,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7694,7724],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":323,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":323,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":323,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":323,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7834,7858],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":331,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":331,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":331,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":331,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7974,8004],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":339,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":339,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":339,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":339,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8133,8160],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":348,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":348,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":348,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":348,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8342,8369],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":359,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":359,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":364,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":364,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":364,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":364,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8771,8812],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":382,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":382,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":387,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":387,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":387,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":387,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9351,9385],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":403,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":403,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":403,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":403,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9669,9697],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":414,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":414,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":419,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":419,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":419,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":419,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10109,10146],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":434,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":434,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":434,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":434,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10403,10428],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":448,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":448,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":448,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":448,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10818,10850],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":452,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":452,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":452,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":452,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10936,10963],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":456,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":456,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":456,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":456,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11073,11100],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":462,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":462,"endColumn":8},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":462,"column":1,"nodeType":"MemberExpression","messageId":"unexpected","endLine":462,"endColumn":12,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11175,11222],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":463,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":463,"endColumn":8},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":463,"column":1,"nodeType":"MemberExpression","messageId":"unexpected","endLine":463,"endColumn":12,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11224,11288],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":45,"fatalErrorCount":0,"warningCount":32,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const { contextBridge, ipcRenderer } = require('electron');\r\n\r\nconst electronAPI = {\r\n  /**\r\n   * 타이핑 통계 업데이트 이벤트 수신\r\n   * @param {Function} callback - 타이핑 통계를 받아서 처리할 콜백 함수\r\n   * @returns {Function} - 이벤트 리스너 제거 함수\r\n   */\r\n  onTypingStatsUpdate: (callback) => {\r\n    if (!callback || typeof callback !== 'function') {\r\n      console.error('유효한 콜백 함수가 필요합니다');\r\n      return () => {};\r\n    }\r\n\r\n    // 이벤트 핸들러 정의\r\n    const handler = (_event, data) => {\r\n      console.log('타이핑 통계 업데이트 수신:', data);\r\n      callback(data);\r\n    };\r\n\r\n    // 이벤트 리스너 등록\r\n    ipcRenderer.on('typing-stats-update', handler);\r\n\r\n    // 이벤트 리스너 제거 함수 반환 (메모리 누수 방지를 위해 필요)\r\n    return () => {\r\n      ipcRenderer.removeListener('typing-stats-update', handler);\r\n    };\r\n  },\r\n\r\n  /**\r\n   * 타이핑 모니터링 시작\r\n   */\r\n  startTracking: () => {\r\n    console.log('모니터링 시작 요청');\r\n    ipcRenderer.send('start-tracking');\r\n  },\r\n\r\n  /**\r\n   * 타이핑 모니터링 중지\r\n   */\r\n  stopTracking: () => {\r\n    console.log('모니터링 중지 요청');\r\n    ipcRenderer.send('stop-tracking');\r\n  },\r\n\r\n  /**\r\n   * 통계 저장\r\n   * @param {string} content - 저장할 내용 설명\r\n   */\r\n  saveStats: (content) => {\r\n    console.log('통계 저장 요청:', content);\r\n    ipcRenderer.send('save-stats', content);\r\n  },\r\n\r\n  /**\r\n   * 현재 브라우저 정보 요청\r\n   * @returns {Promise<any>} - 브라우저 정보 (이름, Google Docs 여부, 제목)\r\n   */\r\n  getCurrentBrowserInfo: () => {\r\n    console.log('현재 브라우저 정보 요청');\r\n    return ipcRenderer.invoke('get-current-browser-info');\r\n  },\r\n\r\n  /**\r\n   * 디버그 정보 요청\r\n   * @returns {Promise<any>} - 디버그 정보 (추적 상태, 현재 통계, 플랫폼 등)\r\n   */\r\n  getDebugInfo: () => {\r\n    console.log('디버그 정보 요청');\r\n    return ipcRenderer.invoke('get-debug-info');\r\n  },\r\n\r\n  /**\r\n   * 설정 저장\r\n   * @param {any} settings - 설정 객체\r\n   */\r\n  saveSettings: (settings) => {\r\n    console.log('설정 저장 요청:', settings);\r\n    ipcRenderer.send('save-settings', settings);\r\n  },\r\n\r\n  /**\r\n   * 설정 로드\r\n   * @returns {Promise<any>} - 설정 객체\r\n   */\r\n  loadSettings: () => {\r\n    console.log('설정 로드 요청');\r\n    return ipcRenderer.invoke('load-settings');\r\n  },\r\n\r\n  /**\r\n   * 자동 시작 설정 확인\r\n   * @param {boolean} shouldAutoStart - 자동 시작 여부\r\n   */\r\n  checkAutoStart: (shouldAutoStart) => {\r\n    console.log('자동 시작 설정 확인:', shouldAutoStart);\r\n    ipcRenderer.send('check-auto-start', shouldAutoStart);\r\n  },\r\n\r\n  /**\r\n   * 자동 모니터링 시작 이벤트 수신\r\n   * @param {Function} callback - 자동 모니터링 시작 알림 콜백 함수\r\n   * @returns {Function} - 이벤트 리스너 제거 함수\r\n   */\r\n  onAutoTrackingStarted: (callback) => {\r\n    if (!callback || typeof callback !== 'function') {\r\n      console.error('유효한 콜백 함수가 필요합니다');\r\n      return () => {};\r\n    }\r\n\r\n    const handler = (_event, data) => {\r\n      console.log('자동 모니터링 시작 알림 수신:', data);\r\n      callback(data);\r\n    };\r\n\r\n    ipcRenderer.on('auto-tracking-started', handler);\r\n\r\n    return () => {\r\n      ipcRenderer.removeListener('auto-tracking-started', handler);\r\n    };\r\n  },\r\n\r\n  /**\r\n   * 윈도우 모드 변경\r\n   * @param {string} mode - 윈도우 모드 ('windowed' 또는 'fullscreen')\r\n   */\r\n  setWindowMode: (mode) => {\r\n    console.log('윈도우 모드 변경 요청:', mode);\r\n    ipcRenderer.send('set-window-mode', mode);\r\n  },\r\n\r\n  /**\r\n   * 다크 모드 설정\r\n   * @param {boolean} enabled - 다크 모드 활성화 여부\r\n   */\r\n  setDarkMode: (enabled) => {\r\n    console.log('다크 모드 변경 요청:', enabled);\r\n    ipcRenderer.send('set-dark-mode', enabled);\r\n  },\r\n\r\n  /**\r\n   * 윈도우 컨트롤 함수\r\n   * @param {string} command - 창 제어 명령 (minimize, maximize, close)\r\n   */\r\n  windowControl: (command) => {\r\n    // 지원하는 명령 명시적으로 검증\r\n    const validCommands = ['minimize', 'maximize', 'close', 'setTitle'];\r\n    \r\n    if (!validCommands.includes(command)) {\r\n      // showHeader와 hideHeader 명령에 대한 특수 처리\r\n      if (command === 'showHeader' || command === 'hideHeader') {\r\n        console.warn(`'${command}' 명령은 더 이상 사용되지 않습니다. 자동 숨김 처리는 설정에서 구성하세요.`);\r\n        return;\r\n      }\r\n      \r\n      // 그 외 유효하지 않은 명령\r\n      console.error(`유효하지 않은 창 제어 명령: ${command}`);\r\n      return;\r\n    }\r\n    \r\n    console.log('창 제어 요청:', command);\r\n    ipcRenderer.send('window-control', command);\r\n  },\r\n\r\n  /**\r\n   * 윈도우 모드 변경\r\n   * @param {string} mode - 윈도우 모드 ('windowed' 또는 'fullscreen')\r\n   * @returns {Promise<any>} - 윈도우 모드 변경 결과\r\n   */\r\n  changeWindowMode: (mode) => {\r\n    return new Promise((resolve) => {\r\n      ipcRenderer.send('change-window-mode', mode);\r\n      ipcRenderer.once('window-mode-change-result', (_, result) => {\r\n        resolve(result);\r\n      });\r\n    });\r\n  },\r\n\r\n  /**\r\n   * 트레이 설정 업데이트\r\n   * @param {Object} settings - 트레이 관련 설정\r\n   * @returns {Promise<any>} - 설정 업데이트 결과\r\n   */\r\n  updateTraySettings: (settings) => {\r\n    console.log('트레이 설정 업데이트 요청:', settings);\r\n    return new Promise((resolve) => {\r\n      ipcRenderer.once('tray-settings-updated', (_event, result) => {\r\n        resolve(result);\r\n      });\r\n      ipcRenderer.send('update-tray-settings', settings);\r\n    });\r\n  },\r\n\r\n  /**\r\n   * 앱 종료 요청 (트레이에서 종료할 때 사용)\r\n   */\r\n  quitApp: () => {\r\n    ipcRenderer.send('quit-app');\r\n  },\r\n\r\n  /**\r\n   * 창 표시/숨김 토글\r\n   */\r\n  toggleWindow: () => {\r\n    ipcRenderer.send('toggle-window');\r\n  },\r\n\r\n  /**\r\n   * 백그라운드 모드 변경 이벤트\r\n   * @param {Function} callback - 백그라운드 모드 변경 콜백\r\n   * @returns {Function} - 이벤트 리스너 제거 함수\r\n   */\r\n  onBackgroundModeChange: (callback) => {\r\n    if (!callback || typeof callback !== 'function') {\r\n      console.error('유효한 콜백 함수가 필요합니다');\r\n      return () => {};\r\n    }\r\n\r\n    const handler = (_event, isBackground) => {\r\n      console.log('백그라운드 모드 변경:', isBackground);\r\n      callback(isBackground);\r\n    };\r\n\r\n    ipcRenderer.on('background-mode', handler);\r\n\r\n    return () => {\r\n      ipcRenderer.removeListener('background-mode', handler);\r\n    };\r\n  },\r\n\r\n  /**\r\n   * 트레이에서 명령 이벤트 수신\r\n   */\r\n  onTrayCommand: (callback) => {\r\n    if (!callback || typeof callback !== 'function') {\r\n      console.error('유효한 콜백 함수가 필요합니다');\r\n      return () => {};\r\n    }\r\n\r\n    const startHandler = () => {\r\n      callback('start');\r\n    };\r\n\r\n    const stopHandler = () => {\r\n      callback('stop');\r\n    };\r\n\r\n    ipcRenderer.on('start-tracking-from-tray', startHandler);\r\n    ipcRenderer.on('stop-tracking-from-tray', stopHandler);\r\n\r\n    return () => {\r\n      ipcRenderer.removeListener('start-tracking-from-tray', startHandler);\r\n      ipcRenderer.removeListener('stop-tracking-from-tray', stopHandler);\r\n    };\r\n  },\r\n\r\n  /**\r\n   * 트레이에서 특정 탭으로 이동\r\n   * @param {Function} callback - 탭 전환 콜백 함수\r\n   * @returns {Function} - 이벤트 리스너 제거 함수\r\n   */\r\n  onSwitchTab: (callback) => {\r\n    if (!callback || typeof callback !== 'function') {\r\n      console.error('유효한 콜백 함수가 필요합니다');\r\n      return () => {};\r\n    }\r\n\r\n    const handler = (_event, tabName) => {\r\n      console.log('탭 전환 요청 수신:', tabName);\r\n      callback(tabName);\r\n      \r\n      // 탭 전환 완료 알림\r\n      setTimeout(() => {\r\n        ipcRenderer.send('switch-to-tab-handled', tabName);\r\n      }, 100);\r\n    };\r\n\r\n    ipcRenderer.on('switch-to-tab', handler);\r\n\r\n    return () => {\r\n      ipcRenderer.removeListener('switch-to-tab', handler);\r\n    };\r\n  },\r\n\r\n  /**\r\n   * 통계 저장 다이얼로그 열기 요청\r\n   * @param {Function} callback - 저장 다이얼로그 열기 콜백\r\n   * @returns {Function} - 이벤트 리스너 제거 함수\r\n   */\r\n  onOpenSaveStatsDialog: (callback) => {\r\n    if (!callback || typeof callback !== 'function') {\r\n      console.error('유효한 콜백 함수가 필요합니다');\r\n      return () => {};\r\n    }\r\n\r\n    const handler = () => {\r\n      console.log('통계 저장 다이얼로그 열기 요청 수신');\r\n      callback();\r\n      \r\n      // 다이얼로그가 열렸음을 알림\r\n      ipcRenderer.send('save-stats-dialog-opened');\r\n    };\r\n\r\n    ipcRenderer.on('open-save-stats-dialog', handler);\r\n\r\n    return () => {\r\n      ipcRenderer.removeListener('open-save-stats-dialog', handler);\r\n    };\r\n  },\r\n\r\n  /**\r\n   * 트레이 통계 업데이트 요청\r\n   */\r\n  requestStatsUpdate: () => {\r\n    console.log('트레이 통계 업데이트 요청');\r\n    ipcRenderer.send('request-stats-update');\r\n  },\r\n\r\n  /**\r\n   * 앱 재시작\r\n   */\r\n  restartApp: () => {\r\n    console.log('앱 재시작 요청');\r\n    ipcRenderer.send('restart-app');\r\n  },\r\n  \r\n  /**\r\n   * 재시작 안내 창 표시\r\n   */\r\n  showRestartPrompt: () => {\r\n    console.log('재시작 안내 창 표시 요청');\r\n    ipcRenderer.send('show-restart-prompt');\r\n  },\r\n\r\n  /**\r\n   * 재시작 창 닫기 (restart.html용)\r\n   */\r\n  closeWindow: () => {\r\n    console.log('재시작 창 닫기 요청');\r\n    ipcRenderer.send('close-restart-window');\r\n  },\r\n\r\n  /**\r\n   * 다크 모드 설정 가져오기 (restart.html용)\r\n   * @returns {Promise<boolean>} 다크 모드 활성화 상태\r\n   */\r\n  getDarkMode: () => {\r\n    console.log('다크 모드 설정 요청');\r\n    return ipcRenderer.invoke('get-dark-mode');\r\n  },\r\n\r\n  /**\r\n   * 재시작 로딩 이벤트 수신\r\n   * @param {Function} callback - 재시작 로딩 표시 콜백\r\n   * @returns {Function} - 이벤트 리스너 제거 함수\r\n   */\r\n  onShowRestartLoading: (callback) => {\r\n    if (!callback || typeof callback !== 'function') {\r\n      console.error('유효한 콜백 함수가 필요합니다');\r\n      return () => {};\r\n    }\r\n\r\n    const handler = (_event, data) => {\r\n      console.log('재시작 로딩 화면 표시 요청 수신:', data);\r\n      callback(data);\r\n    };\r\n\r\n    ipcRenderer.on('show-restart-loading', handler);\r\n\r\n    return () => {\r\n      ipcRenderer.removeListener('show-restart-loading', handler);\r\n    };\r\n  },\r\n\r\n  /**\r\n   * 통계 저장 결과 이벤트 수신\r\n   * @param {Function} callback - 통계 저장 결과를 처리할 콜백 함수\r\n   * @returns {Function} - 이벤트 리스너 제거 함수\r\n   */\r\n  onStatsSaved: (callback) => {\r\n    if (!callback || typeof callback !== 'function') {\r\n      console.error('유효한 콜백 함수가 필요합니다');\r\n      return () => {};\r\n    }\r\n\r\n    const handler = (_event, data) => {\r\n      console.log('통계 저장 결과 수신:', data);\r\n      callback(data);\r\n    };\r\n\r\n    ipcRenderer.on('stats-saved', handler);\r\n\r\n    return () => {\r\n      ipcRenderer.removeListener('stats-saved', handler);\r\n    };\r\n  },\r\n\r\n  /**\r\n   * 윈도우 모드 가져오기\r\n   * @returns {Promise<string>} - 현재 윈도우 모드\r\n   */\r\n  getWindowMode: () => {\r\n    console.log('현재 윈도우 모드 요청');\r\n    return ipcRenderer.invoke('get-window-mode');\r\n  },\r\n\r\n  /**\r\n   * 미니뷰 통계 업데이트 이벤트 수신\r\n   * @param {Function} callback - 미니뷰 통계 업데이트 콜백\r\n   * @returns {Function} - 이벤트 리스너 제거 함수\r\n   */\r\n  onMiniViewStatsUpdate: (callback) => {\r\n    if (!callback || typeof callback !== 'function') {\r\n      console.error('유효한 콜백 함수가 필요합니다');\r\n      return () => {};\r\n    }\r\n\r\n    const handler = (_event, data) => {\r\n      console.log('미니뷰 통계 업데이트 수신:', data);\r\n      callback(data);\r\n    };\r\n\r\n    ipcRenderer.on('mini-view-stats-update', handler);\r\n\r\n    return () => {\r\n      ipcRenderer.removeListener('mini-view-stats-update', handler);\r\n    };\r\n  },\r\n\r\n  /**\r\n   * 미니뷰 토글\r\n   */\r\n  toggleMiniView: () => {\r\n    console.log('미니뷰 토글 요청');\r\n    ipcRenderer.send('toggle-mini-view');\r\n  }\r\n};\r\n\r\n// electronAPI 객체를 window.electronAPI로 노출\r\ncontextBridge.exposeInMainWorld('electronAPI', electronAPI);\r\n\r\n// 동일한 API를 window.electron으로도 노출 (하위 호환성을 위해)\r\ncontextBridge.exposeInMainWorld('electron', electronAPI);\r\n\r\n// 재시작 창을 위한 별도의 API (restart.html에서 사용)\r\ncontextBridge.exposeInMainWorld('restartAPI', {\r\n  restartApp: () => {\r\n    console.log('재시작 창에서 앱 재시작 요청');\r\n    ipcRenderer.send('restart-app-from-dialog');\r\n  },\r\n  closeWindow: () => {\r\n    console.log('재시작 창 닫기 요청');\r\n    ipcRenderer.send('close-restart-window-from-dialog'); // 채널 이름 확인 완료\r\n  },\r\n  getDarkMode: () => {\r\n    console.log('다크 모드 설정 요청');\r\n    return ipcRenderer.invoke('get-dark-mode');\r\n  }\r\n});\r\n\r\n// 디버그용 로그\r\nconsole.log('Electron preload 스크립트가 로드되었습니다.');\r\nconsole.log('노출된 API 함수:', Object.keys(electronAPI).join(', '));","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\renderer\\preload-restart.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'require' is not defined.","line":1,"column":40,"nodeType":"Identifier","messageId":"undef","endLine":1,"endColumn":47},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":10,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":10,"endColumn":8},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":10,"column":1,"nodeType":"MemberExpression","messageId":"unexpected","endLine":10,"endColumn":12,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[315,373],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const { contextBridge, ipcRenderer } = require('electron');\r\n\r\n// 재시작 창 전용 API 노출\r\ncontextBridge.exposeInMainWorld('restartAPI', {\r\n  getDarkMode: () => ipcRenderer.invoke('get-dark-mode'),\r\n  restartApp: () => ipcRenderer.send('restart-app'),\r\n  closeWindow: () => ipcRenderer.send('close-restart-window')\r\n});\r\n\r\nconsole.log('Restart preload script loaded successfully');","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\renderer\\restart.tsx","messages":[{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":40,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":41,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":41,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":45,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":45,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":57,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":57,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":59,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":59,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":61,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":61,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":63,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":63,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":66,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":68,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":68,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":70,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":72,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":72,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":76,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":76,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":79,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":79,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":85,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":85,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":86,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":86,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":88,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":88,"endColumn":14}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useEffect, useState } from 'react';\r\n\r\n/**\r\n * RestartAPI 인터페이스 정의\r\n */\r\ninterface RestartAPI {\r\n  getDarkMode: () => Promise<boolean>;\r\n  restartApp: () => void;\r\n  closeWindow: () => void;\r\n}\r\n\r\n/**\r\n * Window 인터페이스 확장\r\n */\r\ndeclare global {\r\n  interface Window {\r\n    restartAPI?: RestartAPI;\r\n  }\r\n}\r\n\r\ninterface RestartPromptProps {\r\n  reason?: string;\r\n}\r\n\r\n/**\r\n * 재시작 안내 컴포넌트\r\n */\r\nconst RestartPrompt: React.FC<RestartPromptProps> = ({ \r\n  reason = 'GPU 가속 설정이 변경되었습니다.' \r\n}) => {\r\n  const [isDarkMode, setIsDarkMode] = useState(false);\r\n  const [isRestarting, setIsRestarting] = useState(false);\r\n  \r\n  useEffect(() => {\r\n    // 테마 설정 가져오기\r\n    async function fetchTheme() {\r\n      try {\r\n        if (window.restartAPI?.getDarkMode) {\r\n          const darkMode = await window.restartAPI.getDarkMode();\r\n          setIsDarkMode(darkMode);\r\n        }\r\n      } catch (error) {\r\n        console.error('테마 불러오기 중 오류:', error);\r\n      }\r\n    }\r\n    \r\n    fetchTheme();\r\n  }, []);\r\n  \r\n  // 앱 재시작 함수\r\n  const handleRestart = () => {\r\n    setIsRestarting(true);\r\n    \r\n    try {\r\n      if (window.restartAPI?.restartApp) {\r\n        // 애니메이션을 보여주기 위한 지연\r\n        setTimeout(() => {\r\n          try {\r\n            window.restartAPI?.restartApp();\r\n          } catch (error) {\r\n            console.error('재시작 실행 중 오류:', error);\r\n          }\r\n        }, 800);\r\n      } else if (window.electronAPI?.restartApp) {\r\n        // restartAPI 객체가 없는 경우 electronAPI로 대체 시도\r\n        setTimeout(() => {\r\n          try {\r\n            window.electronAPI?.restartApp();\r\n          } catch (error) {\r\n            console.error('재시작 실행 중 오류 (electronAPI):', error);\r\n          }\r\n        }, 800);\r\n      } else {\r\n        console.error('restartApp 함수가 정의되지 않았습니다. preload-restart.js 파일을 확인하세요.');\r\n      }\r\n    } catch (error) {\r\n      console.error('재시작 처리 중 오류:', error);\r\n    }\r\n  };\r\n  \r\n  // 창 닫기 함수\r\n  const handleClose = () => {\r\n    if (window.restartAPI?.closeWindow) {\r\n      window.restartAPI.closeWindow();\r\n    } else {\r\n      console.error('closeWindow 함수가 정의되지 않았습니다.');\r\n    }\r\n  };\r\n  \r\n  return (\r\n    <div className={`restart-container ${isDarkMode ? 'dark-mode' : 'light-mode'}`}>\r\n      <div className=\"header\">\r\n        <h1>앱 재시작</h1>\r\n        <button \r\n          className=\"close-button\" \r\n          onClick={handleClose}\r\n          disabled={isRestarting}\r\n          aria-label=\"닫기\"\r\n        >\r\n          ×\r\n        </button>\r\n      </div>\r\n      \r\n      <div className=\"content\">\r\n        {isRestarting ? (\r\n          <>\r\n            <div className=\"loading-icon\">\r\n              <svg className=\"spinner\" viewBox=\"0 0 50 50\">\r\n                <circle className=\"path\" cx=\"25\" cy=\"25\" r=\"20\" fill=\"none\" strokeWidth=\"5\"></circle>\r\n              </svg>\r\n            </div>\r\n            <p className=\"message\">\r\n              재시작 중입니다...<br />\r\n              잠시만 기다려주세요.\r\n            </p>\r\n          </>\r\n        ) : (\r\n          <>\r\n            <div className=\"icon\">🔄</div>\r\n            <p className=\"message\">\r\n              {reason}<br />\r\n              변경된 설정을 적용하려면 앱을 재시작해야 합니다.\r\n            </p>\r\n            <div className=\"buttons\">\r\n              <button \r\n                className=\"button primary\" \r\n                onClick={handleRestart}\r\n                disabled={isRestarting}\r\n              >\r\n                지금 재시작\r\n              </button>\r\n              <button \r\n                className=\"button secondary\" \r\n                onClick={handleClose}\r\n                disabled={isRestarting}\r\n              >\r\n                나중에 하기\r\n              </button>\r\n            </div>\r\n          </>\r\n        )}\r\n      </div>\r\n      \r\n      <style jsx>{`\r\n        .restart-container {\r\n          width: 100%;\r\n          height: 100vh;\r\n          display: flex;\r\n          flex-direction: column;\r\n          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;\r\n          user-select: none;\r\n          transition: all 0.3s ease;\r\n          overflow: hidden;\r\n        }\r\n        \r\n        .light-mode {\r\n          --bg-color: #f8f9fa;\r\n          --header-bg: #4d7cfe;\r\n          --header-text: #ffffff;\r\n          --text-color: #333333;\r\n          --text-secondary: #555555;\r\n          --border-color: #e0e0e0;\r\n          --button-primary-bg: #4d7cfe;\r\n          --button-primary-text: #ffffff;\r\n          --button-primary-hover: #3a6de9;\r\n          --button-secondary-bg: #f0f0f0;\r\n          --button-secondary-text: #333333;\r\n          --button-secondary-hover: #e0e0e0;\r\n          --shadow-color: rgba(0, 0, 0, 0.1);\r\n          --spinner-color: #4d7cfe;\r\n          color-scheme: light;\r\n          background-color: var(--bg-color);\r\n          color: var(--text-color);\r\n        }\r\n        \r\n        .dark-mode {\r\n          --bg-color: #1e1e1e;\r\n          --header-bg: #2d5bd3;\r\n          --header-text: #ffffff;\r\n          --text-color: #e0e0e0;\r\n          --text-secondary: #b0b0b0;\r\n          --border-color: #444444;\r\n          --button-primary-bg: #3968e0;\r\n          --button-primary-text: #ffffff;\r\n          --button-primary-hover: #2d5bd3;\r\n          --button-secondary-bg: #333333;\r\n          --button-secondary-text: #e0e0e0;\r\n          --button-secondary-hover: #444444;\r\n          --shadow-color: rgba(0, 0, 0, 0.3);\r\n          --spinner-color: #5e8efe;\r\n          color-scheme: dark;\r\n          background-color: var(--bg-color);\r\n          color: var(--text-color);\r\n        }\r\n        \r\n        .header {\r\n          height: 40px;\r\n          background-color: var(--header-bg);\r\n          color: var(--header-text);\r\n          display: flex;\r\n          align-items: center;\r\n          justify-content: space-between;\r\n          padding: 0 15px;\r\n          -webkit-app-region: drag;\r\n          box-shadow: 0 2px 4px var(--shadow-color);\r\n        }\r\n        \r\n        .header h1 {\r\n          font-size: 16px;\r\n          font-weight: 500;\r\n          margin: 0;\r\n        }\r\n        \r\n        .close-button {\r\n          background: none;\r\n          border: none;\r\n          color: var(--header-text);\r\n          font-size: 22px;\r\n          font-weight: bold;\r\n          cursor: pointer;\r\n          -webkit-app-region: no-drag;\r\n          display: flex;\r\n          align-items: center;\r\n          justify-content: center;\r\n          width: 28px;\r\n          height: 28px;\r\n          border-radius: 4px;\r\n          transition: background-color 0.2s;\r\n        }\r\n        \r\n        .close-button:hover {\r\n          background-color: rgba(255, 255, 255, 0.2);\r\n        }\r\n        \r\n        .close-button:disabled {\r\n          opacity: 0.5;\r\n          cursor: not-allowed;\r\n        }\r\n        \r\n        .content {\r\n          flex: 1;\r\n          padding: 25px;\r\n          display: flex;\r\n          flex-direction: column;\r\n          justify-content: center;\r\n          align-items: center;\r\n          text-align: center;\r\n        }\r\n        \r\n        .icon {\r\n          font-size: 36px;\r\n          margin-bottom: 20px;\r\n          color: var(--button-primary-bg);\r\n          animation: pulse 2s infinite;\r\n        }\r\n        \r\n        .message {\r\n          margin-bottom: 25px;\r\n          font-size: 16px;\r\n          line-height: 1.6;\r\n          color: var(--text-color);\r\n          max-width: 320px;\r\n        }\r\n        \r\n        .buttons {\r\n          display: flex;\r\n          gap: 12px;\r\n        }\r\n        \r\n        .button {\r\n          padding: 10px 20px;\r\n          border-radius: 6px;\r\n          cursor: pointer;\r\n          font-size: 14px;\r\n          font-weight: 500;\r\n          transition: all 0.2s;\r\n          border: none;\r\n          outline: none;\r\n          box-shadow: 0 2px 4px var(--shadow-color);\r\n        }\r\n        \r\n        .button:disabled {\r\n          opacity: 0.5;\r\n          cursor: not-allowed;\r\n          transform: none !important;\r\n          box-shadow: none !important;\r\n        }\r\n        \r\n        .primary {\r\n          background-color: var(--button-primary-bg);\r\n          color: var(--button-primary-text);\r\n        }\r\n        \r\n        .primary:hover:not(:disabled) {\r\n          background-color: var(--button-primary-hover);\r\n          transform: translateY(-2px);\r\n          box-shadow: 0 4px 8px var(--shadow-color);\r\n        }\r\n        \r\n        .secondary {\r\n          background-color: var(--button-secondary-bg);\r\n          color: var(--button-secondary-text);\r\n        }\r\n        \r\n        .secondary:hover:not(:disabled) {\r\n          background-color: var(--button-secondary-hover);\r\n          transform: translateY(-2px);\r\n          box-shadow: 0 4px 8px var(--shadow-color);\r\n        }\r\n        \r\n        /* 로딩 아이콘 스타일 */\r\n        .loading-icon {\r\n          width: 50px;\r\n          height: 50px;\r\n          margin-bottom: 20px;\r\n        }\r\n        \r\n        .spinner {\r\n          animation: rotate 2s linear infinite;\r\n          z-index: 2;\r\n          width: 50px;\r\n          height: 50px;\r\n        }\r\n        \r\n        .spinner .path {\r\n          stroke: var(--spinner-color);\r\n          stroke-linecap: round;\r\n          animation: dash 1.5s ease-in-out infinite;\r\n        }\r\n        \r\n        @keyframes rotate {\r\n          100% {\r\n            transform: rotate(360deg);\r\n          }\r\n        }\r\n        \r\n        @keyframes dash {\r\n          0% {\r\n            stroke-dasharray: 1, 150;\r\n            stroke-dashoffset: 0;\r\n          }\r\n          50% {\r\n            stroke-dasharray: 90, 150;\r\n            stroke-dashoffset: -35;\r\n          }\r\n          100% {\r\n            stroke-dasharray: 90, 150;\r\n            stroke-dashoffset: -124;\r\n          }\r\n        }\r\n        \r\n        @keyframes pulse {\r\n          0% {\r\n            transform: scale(1);\r\n            opacity: 1;\r\n          }\r\n          50% {\r\n            transform: scale(1.1);\r\n            opacity: 0.8;\r\n          }\r\n          100% {\r\n            transform: scale(1);\r\n            opacity: 1;\r\n          }\r\n        }\r\n      `}</style>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default RestartPrompt;","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\server\\native\\index.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":49,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":49,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":55,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":55,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":57,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":57,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":64,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":64,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":66,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":124,"column":55,"nodeType":"Identifier","messageId":"undef","endLine":124,"endColumn":58},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":161,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":161,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":162,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":162,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":164,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":164,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":166,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":166,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":168,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":168,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":170,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":170,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":173,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":173,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":277,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":277,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":278,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":278,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":279,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":279,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":280,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":280,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":281,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":281,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":282,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":282,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":283,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":283,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":284,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":284,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":284,"column":53,"nodeType":"Identifier","messageId":"undef","endLine":284,"endColumn":60},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":289,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":289,"endColumn":29},{"ruleId":"no-unused-vars","severity":2,"message":"'emergency' is assigned a value but never used.","line":299,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":299,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'emergency' is assigned a value but never used.","line":299,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":299,"endColumn":46},{"ruleId":"no-undef","severity":2,"message":"'global' is not defined.","line":300,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":300,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'global' is not defined.","line":301,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":301,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":304,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":304,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":307,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":307,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":309,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":309,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":342,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":342,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'global' is not defined.","line":344,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":344,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'global' is not defined.","line":345,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":345,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":346,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":346,"endColumn":31},{"ruleId":"no-unused-vars","severity":2,"message":"'threadCount' is assigned a value but never used.","line":392,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":392,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'threadCount' is assigned a value but never used.","line":392,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":392,"endColumn":37},{"ruleId":"no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":402,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":402,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'data' is defined but never used. Allowed unused args must match /^_/u.","line":402,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":402,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":435,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":435,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":436,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":436,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":438,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":438,"endColumn":28},{"ruleId":"no-unused-vars","severity":2,"message":"'initializeWorkerPool' is defined but never used.","line":816,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":816,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'initializeWorkerPool' is defined but never used.","line":816,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":816,"endColumn":30},{"ruleId":"no-unused-vars","severity":2,"message":"'submitTask' is defined but never used.","line":827,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":827,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'submitTask' is defined but never used.","line":827,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":827,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":887,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":887,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":888,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":888,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":890,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":890,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":891,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":891,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":892,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":892,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":927,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":927,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":928,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":928,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'__dirname' is not defined.","line":929,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":929,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":930,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":930,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":931,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":931,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":932,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":932,"endColumn":22},{"ruleId":"no-dupe-keys","severity":2,"message":"Duplicate key 'getMemoryInfo'.","line":1148,"column":3,"nodeType":"ObjectExpression","messageId":"unexpected","endLine":1148,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'getMemoryInfo' is not defined.","line":1148,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":1148,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'determineOptimizationLevel' is not defined.","line":1149,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":1149,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'requestGarbageCollection' is not defined.","line":1150,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":1150,"endColumn":27},{"ruleId":"no-dupe-keys","severity":2,"message":"Duplicate key 'optimizeMemory'.","line":1151,"column":3,"nodeType":"ObjectExpression","messageId":"unexpected","endLine":1151,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'isGpuAccelerationAvailable' is not defined.","line":1152,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":1152,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'enableGpuAcceleration' is not defined.","line":1153,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":1153,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'disableGpuAcceleration' is not defined.","line":1154,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":1154,"endColumn":25},{"ruleId":"no-dupe-keys","severity":2,"message":"Duplicate key 'getGpuInfo'.","line":1155,"column":3,"nodeType":"ObjectExpression","messageId":"unexpected","endLine":1155,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'getGpuInfo' is not defined.","line":1155,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":1155,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'performGpuComputation' is not defined.","line":1156,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":1156,"endColumn":24},{"ruleId":"no-dupe-keys","severity":2,"message":"Duplicate key 'getNativeModuleInfo'.","line":1157,"column":3,"nodeType":"ObjectExpression","messageId":"unexpected","endLine":1157,"endColumn":22}],"suppressedMessages":[],"errorCount":63,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 네이티브 모듈 래퍼\r\n * \r\n * 이 파일은 Rust 네이티브 모듈과 JavaScript 애플리케이션 간의 인터페이스를 제공합니다.\r\n * 성능 지표 수집, 오류 처리, 폴백 메커니즘을 포함하여 안정적인 운영을 보장합니다.\r\n * \r\n * @module NativeModuleWrapper\r\n */\r\n\r\nimport path from 'path';\r\nimport fs from 'fs';\r\nimport { performance } from 'perf_hooks';\r\nimport { createLogger } from './utils/logger.js';\r\nimport { createRequire } from 'module';\r\n\r\n// node require 생성 (필요시 네이티브 모듈 로드용)\r\nconst require = createRequire(import.meta.url);\r\n\r\n// 로거 인스턴스 생성\r\nconst logger = createLogger('native-module');\r\n\r\n// 로거 함수 직접 참조\r\nconst { info: logInfo, error: logError, warning: logWarning } = logger;\r\n\r\n// 모듈 캐시 및 상태\r\nconst moduleState = {\r\n  nativeModule: null,\r\n  isAvailable: false,\r\n  isFallback: true,\r\n  lastError: null,\r\n  metrics: {\r\n    calls: 0,\r\n    errors: 0,\r\n    avgExecutionTime: 0,\r\n    lastGcTime: 0,\r\n    totalExecutionTime: 0\r\n  },\r\n  initialization: {\r\n    attempted: false,\r\n    timestamp: null,\r\n    success: false\r\n  }\r\n};\r\n\r\n/**\r\n * 네이티브 모듈 경로 결정 (환경에 따라)\r\n */\r\nfunction resolveNativeModulePath() {\r\n  const isDev = process.env.NODE_ENV === 'development';\r\n  \r\n  // 개발 환경에서는 빌드 디렉토리에서 직접 로드\r\n  if (isDev) {\r\n    return [\r\n      // 개발 환경 - 디버그 빌드\r\n      path.join(process.cwd(), 'native-modules', 'target', 'debug', 'typing_stats_native.node'),\r\n      // 개발 환경 - 릴리스 빌드\r\n      path.join(process.cwd(), 'native-modules', 'target', 'release', 'typing_stats_native.node')\r\n    ];\r\n  }\r\n  \r\n  // 프로덕션 환경에서는 배포된 위치에서 로드\r\n  return [\r\n    // 현재 디렉토리 내 네이티브 모듈\r\n    path.join(path.dirname(new URL(import.meta.url).pathname), 'typing_stats_native.node'),\r\n    // 대체 위치 - Node.js 확장 디렉토리\r\n    path.join(process.cwd(), 'node_modules', '.native-modules', 'typing_stats_native.node')\r\n  ];\r\n}\r\n\r\n/**\r\n * 네이티브 모듈 로드 시도\r\n * @returns {Promise<boolean>} 로드 성공 여부\r\n */\r\nasync function loadNativeModule() {\r\n  if (moduleState.initialization.attempted) {\r\n    return moduleState.isAvailable;\r\n  }\r\n  \r\n  moduleState.initialization.attempted = true;\r\n  moduleState.initialization.timestamp = Date.now();\r\n  \r\n  const potentialPaths = resolveNativeModulePath();\r\n  logger.info('네이티브 모듈 로드 시도', { paths: potentialPaths });\r\n  \r\n  // 모든 가능한 경로에서 모듈 로드 시도\r\n  for (const modulePath of potentialPaths) {\r\n    if (fs.existsSync(modulePath)) {\r\n      try {\r\n        logger.info(`네이티브 모듈 발견: ${modulePath}`);\r\n        // .node 파일은 require로 로드 (ESM에서는 직접 import 불가)\r\n        moduleState.nativeModule = require(modulePath);\r\n        moduleState.isAvailable = true;\r\n        moduleState.isFallback = false;\r\n        \r\n        // 모듈 초기화 수행\r\n        if (typeof moduleState.nativeModule.initialize_native_modules === 'function') {\r\n          const initSuccess = moduleState.nativeModule.initialize_native_modules();\r\n          logger.info(`네이티브 모듈 초기화 ${initSuccess ? '성공' : '실패'}`);\r\n          \r\n          // 초기화 실패 시 모듈 사용 불가 처리\r\n          if (!initSuccess) {\r\n            moduleState.isAvailable = false;\r\n            moduleState.lastError = new Error('네이티브 모듈 초기화 실패');\r\n            continue;\r\n          }\r\n        }\r\n        \r\n        // 종료 시 정리 함수 등록\r\n        setupCleanupHandlers();\r\n        \r\n        moduleState.initialization.success = true;\r\n        logger.info('네이티브 모듈 로드 성공');\r\n        return true;\r\n      } catch (error) {\r\n        logger.error('네이티브 모듈 로드 오류', { error: error.message, stack: error.stack });\r\n        moduleState.lastError = error;\r\n      }\r\n    }\r\n  }\r\n  \r\n  // 네이티브 모듈 로드 실패 시 폴백 모듈 로드\r\n  if (!moduleState.isAvailable) {\r\n    try {\r\n      const fallbackPath = path.join(path.dirname(new URL(import.meta.url).pathname), 'fallback', 'index.js');\r\n      if (fs.existsSync(fallbackPath)) {\r\n        logger.info(`폴백 모듈 로드: ${fallbackPath}`);\r\n        const fallbackModule = await import(fallbackPath);\r\n        moduleState.nativeModule = fallbackModule.default || fallbackModule;\r\n        moduleState.isAvailable = true;\r\n        moduleState.isFallback = true;\r\n      } else {\r\n        logger.error('폴백 모듈을 찾을 수 없음', { path: fallbackPath });\r\n      }\r\n    } catch (fallbackError) {\r\n      logger.error('폴백 모듈 로드 오류', { error: fallbackError.message });\r\n      moduleState.lastError = fallbackError;\r\n    }\r\n  }\r\n  \r\n  return moduleState.isAvailable;\r\n}\r\n\r\n/**\r\n * 프로세스 종료 시 정리 함수 설정\r\n */\r\nfunction setupCleanupHandlers() {\r\n  if (!moduleState.isAvailable || moduleState.isFallback) return;\r\n  \r\n  const cleanup = () => {\r\n    try {\r\n      if (moduleState.nativeModule && typeof moduleState.nativeModule.cleanup_native_modules === 'function') {\r\n        logger.info('네이티브 모듈 정리 수행');\r\n        moduleState.nativeModule.cleanup_native_modules();\r\n      }\r\n    } catch (error) {\r\n      logger.error('네이티브 모듈 정리 오류', { error: error.message });\r\n    }\r\n  };\r\n  \r\n  // 다양한 종료 이벤트에 정리 함수 등록\r\n  process.on('exit', cleanup);\r\n  process.on('SIGINT', () => {\r\n    cleanup();\r\n    process.exit(0);\r\n  });\r\n  process.on('SIGTERM', () => {\r\n    cleanup();\r\n    process.exit(0);\r\n  });\r\n  process.on('uncaughtException', (error) => {\r\n    logger.error('처리되지 않은 예외', { error: error.message, stack: error.stack });\r\n    cleanup();\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\n/**\r\n * 네이티브 함수 호출 래퍼 (성능 측정, 오류 처리 포함)\r\n * @param {Function} nativeFunction 네이티브 모듈 함수\r\n * @param {Function} fallbackFunction 폴백 함수\r\n * @param {any} defaultValue 기본 반환값\r\n * @param {boolean} isAsync 비동기 함수 여부\r\n * @returns {Function} 래핑된 함수\r\n */\r\nfunction createFunctionWrapper(nativeFunction, fallbackFunction, defaultValue, isAsync = false) {\r\n  // 네이티브 모듈이 로드되지 않았다면 로드 시도\r\n  if (!moduleState.initialization.attempted) {\r\n    loadNativeModule();\r\n  }\r\n  \r\n  return function(...args) {\r\n    // 모듈 사용 불가 시 폴백 사용\r\n    if (!moduleState.isAvailable) {\r\n      return fallbackFunction ? fallbackFunction(...args) : defaultValue;\r\n    }\r\n    \r\n    const funcName = nativeFunction.name || 'unknown';\r\n    const startTime = performance.now();\r\n    moduleState.metrics.calls++;\r\n    \r\n    try {\r\n      let result;\r\n      \r\n      // 네이티브 모듈 함수 호출\r\n      if (moduleState.isFallback) {\r\n        // 폴백 모듈 사용 중이면 폴백 함수 호출\r\n        result = fallbackFunction ? fallbackFunction(...args) : defaultValue;\r\n      } else {\r\n        // 진짜 네이티브 모듈 함수 호출\r\n        const nativeFn = moduleState.nativeModule[nativeFunction];\r\n        if (typeof nativeFn !== 'function') {\r\n          throw new Error(`네이티브 함수 ${funcName}을(를) 찾을 수 없습니다`);\r\n        }\r\n        \r\n        result = nativeFn.apply(moduleState.nativeModule, args);\r\n      }\r\n      \r\n      // 성능 지표 업데이트\r\n      const executionTime = performance.now() - startTime;\r\n      updatePerformanceMetrics(funcName, executionTime);\r\n      \r\n      // 비동기 함수인 경우 Promise 래핑\r\n      if (isAsync && result && typeof result.then === 'function') {\r\n        return result.catch(error => {\r\n          moduleState.metrics.errors++;\r\n          logger.error(`비동기 네이티브 함수 ${funcName} 오류`, { \r\n            error: error.message, \r\n            args: JSON.stringify(args)\r\n          });\r\n          \r\n          // 폴백 함수가 있으면 호출\r\n          if (fallbackFunction) {\r\n            return fallbackFunction(...args);\r\n          }\r\n          throw error;\r\n        });\r\n      }\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      moduleState.metrics.errors++;\r\n      logger.error(`네이티브 함수 ${funcName} 오류`, { \r\n        error: error.message, \r\n        stack: error.stack,\r\n        args: JSON.stringify(args)\r\n      });\r\n      \r\n      // 오류 발생 시 폴백 사용\r\n      return fallbackFunction ? fallbackFunction(...args) : defaultValue;\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * 성능 지표 업데이트\r\n * @param {string} funcName 함수 이름\r\n * @param {number} executionTime 실행 시간 (ms)\r\n */\r\nfunction updatePerformanceMetrics(funcName, executionTime) {\r\n  const { metrics } = moduleState;\r\n  \r\n  // 총 실행 시간 업데이트\r\n  metrics.totalExecutionTime += executionTime;\r\n  \r\n  // 평균 실행 시간 계산\r\n  metrics.avgExecutionTime = metrics.totalExecutionTime / metrics.calls;\r\n  \r\n  // 함수별 성능 기록 (미구현)\r\n}\r\n\r\n/**\r\n * 기본 폴백 구현\r\n */\r\nconst fallbacks = {\r\n  // 메모리 관련 폴백\r\n  getMemoryInfo: () => ({\r\n    heap_used: process.memoryUsage().heapUsed,\r\n    heap_total: process.memoryUsage().heapTotal,\r\n    heap_limit: process.memoryUsage().rss * 2,\r\n    rss: process.memoryUsage().rss,\r\n    external: process.memoryUsage().external,\r\n    heap_used_mb: process.memoryUsage().heapUsed / (1024 * 1024),\r\n    rss_mb: process.memoryUsage().rss / (1024 * 1024),\r\n    percent_used: (process.memoryUsage().heapUsed / process.memoryUsage().heapTotal) * 100,\r\n    timestamp: Date.now()\r\n  }),\r\n  \r\n  determineOptimizationLevel: () => {\r\n    const memUsage = process.memoryUsage();\r\n    const usedRatio = memUsage.heapUsed / memUsage.heapTotal;\r\n    \r\n    if (usedRatio > 0.9) return 4; // Critical\r\n    if (usedRatio > 0.8) return 3; // High\r\n    if (usedRatio > 0.7) return 2; // Medium\r\n    if (usedRatio > 0.5) return 1; // Low\r\n    return 0; // Normal\r\n  },\r\n  \r\n  optimizeMemory: async (level = 2, emergency = false) => {\r\n    if (global.gc) {\r\n      global.gc();\r\n    }\r\n    \r\n    const memBefore = process.memoryUsage();\r\n    \r\n    // 인위적인 지연 추가\r\n    await new Promise(resolve => setTimeout(resolve, 100));\r\n    \r\n    const memAfter = process.memoryUsage();\r\n    const freedMemory = memBefore.heapUsed - memAfter.heapUsed;\r\n    \r\n    return {\r\n      success: true,\r\n      optimization_level: level,\r\n      memory_before: {\r\n        heap_used: memBefore.heapUsed,\r\n        heap_total: memBefore.heapTotal,\r\n        rss: memBefore.rss,\r\n        heap_used_mb: memBefore.heapUsed / (1024 * 1024),\r\n        rss_mb: memBefore.rss / (1024 * 1024),\r\n        percent_used: (memBefore.heapUsed / memBefore.heapTotal) * 100,\r\n        timestamp: Date.now()\r\n      },\r\n      memory_after: {\r\n        heap_used: memAfter.heapUsed,\r\n        heap_total: memAfter.heapTotal,\r\n        rss: memAfter.rss,\r\n        heap_used_mb: memAfter.heapUsed / (1024 * 1024),\r\n        rss_mb: memAfter.rss / (1024 * 1024),\r\n        percent_used: (memAfter.heapUsed / (1024 * 1024)) * 100,\r\n        timestamp: Date.now()\r\n      },\r\n      freed_memory: Math.max(0, freedMemory),\r\n      freed_mb: Math.max(0, freedMemory) / (1024 * 1024),\r\n      duration: 100,\r\n      timestamp: Date.now(),\r\n      error: null\r\n    };\r\n  },\r\n  \r\n  forceGarbageCollection: () => {\r\n    const memBefore = process.memoryUsage();\r\n    \r\n    if (global.gc) {\r\n      global.gc();\r\n      const memAfter = process.memoryUsage();\r\n      const freedMemory = memBefore.heapUsed - memAfter.heapUsed;\r\n      \r\n      return {\r\n        success: true,\r\n        timestamp: Date.now(),\r\n        freed_memory: Math.max(0, freedMemory),\r\n        freed_mb: Math.max(0, freedMemory) / (1024 * 1024),\r\n        duration: 10,\r\n        error: null\r\n      };\r\n    }\r\n    \r\n    return {\r\n      success: false,\r\n      timestamp: Date.now(),\r\n      error: 'JavaScript 가비지 컬렉션에 직접 접근할 수 없습니다. --expose-gc 플래그를 사용하세요.'\r\n    };\r\n  },\r\n  \r\n  // GPU 관련 폴백\r\n  isGpuAccelerationAvailable: () => false,\r\n  \r\n  enableGpuAcceleration: () => false,\r\n  \r\n  disableGpuAcceleration: () => true,\r\n  \r\n  getGpuInfo: () => ({\r\n    name: 'JavaScript Fallback GPU',\r\n    vendor: 'Node.js',\r\n    driver_info: 'JavaScript 폴백 구현',\r\n    device_type: 'CPU',\r\n    backend: 'JavaScript',\r\n    available: false\r\n  }),\r\n  \r\n  performGpuComputation: async (data, computationType) => ({\r\n    success: false,\r\n    task_type: computationType,\r\n    duration_ms: 0,\r\n    result: null,\r\n    error: '네이티브 GPU 구현을 사용할 수 없습니다',\r\n    timestamp: Date.now()\r\n  }),\r\n  \r\n  // 워커 관련 폴백\r\n  initializeWorkerPool: (threadCount = 0) => {\r\n    logger.info('JavaScript 폴백 워커 풀 초기화');\r\n    return true;\r\n  },\r\n  \r\n  shutdownWorkerPool: () => {\r\n    logger.info('JavaScript 폴백 워커 풀 종료');\r\n    return true;\r\n  },\r\n  \r\n  submitTask: async (taskType, data) => ({\r\n    success: false,\r\n    task_type: taskType,\r\n    duration_ms: 0,\r\n    result: null,\r\n    error: '네이티브 워커 풀을 사용할 수 없습니다',\r\n    timestamp: Date.now()\r\n  }),\r\n  \r\n  getWorkerPoolStats: () => ({\r\n    thread_count: 1,\r\n    active_tasks: 0,\r\n    completed_tasks: 0,\r\n    active_workers: 0,\r\n    idle_workers: 1,\r\n    pending_tasks: 0,\r\n    failed_tasks: 0,\r\n    total_tasks: 0,\r\n    uptime_ms: 0,\r\n    timestamp: Date.now()\r\n  }),\r\n  \r\n  // 모듈 정보 관련 폴백\r\n  getModuleInfo: () => ({\r\n    name: 'typing-stats-native',\r\n    version: '0.1.0-js-fallback',\r\n    description: 'JavaScript fallback for typing-stats-native',\r\n    features: {\r\n      memory_optimization: true,\r\n      gpu_acceleration: false,\r\n      worker_threads: true\r\n    },\r\n    system: {\r\n      os: process.platform,\r\n      arch: process.arch,\r\n      cpu_cores: require('os').cpus().length,\r\n      node_version: process.version\r\n    }\r\n  }),\r\n  \r\n  getNativeModuleVersion: () => '0.1.0-js-fallback'\r\n};\r\n\r\n// 모듈 API 정의\r\nconst nativeModuleApi = {\r\n  // =========== 네이티브 모듈 상태 관련 함수 ===========\r\n  /**\r\n   * 네이티브 모듈 사용 가능 여부 확인\r\n   * @returns {boolean} 네이티브 모듈 사용 가능 여부\r\n   */\r\n  isNativeModuleAvailable: () => {\r\n    if (!moduleState.initialization.attempted) {\r\n      loadNativeModule();\r\n    }\r\n    return moduleState.isAvailable && !moduleState.isFallback;\r\n  },\r\n  \r\n  /**\r\n   * 폴백 모드 사용 중인지 확인\r\n   * @returns {boolean} 폴백 모드 사용 여부\r\n   */\r\n  isFallbackMode: () => {\r\n    if (!moduleState.initialization.attempted) {\r\n      loadNativeModule();\r\n    }\r\n    return moduleState.isFallback;\r\n  },\r\n  \r\n  /**\r\n   * 네이티브 모듈 버전 가져오기\r\n   * @returns {string|null} 네이티브 모듈 버전\r\n   */\r\n  getNativeModuleVersion: createFunctionWrapper(\r\n    'get_native_module_version',\r\n    fallbacks.getNativeModuleVersion,\r\n    null\r\n  ),\r\n  \r\n  /**\r\n   * 네이티브 모듈 정보 가져오기\r\n   * @returns {Object|null} 네이티브 모듈 정보\r\n   */\r\n  getNativeModuleInfo: createFunctionWrapper(\r\n    'get_native_module_info',\r\n    fallbacks.getModuleInfo,\r\n    null\r\n  ),\r\n  \r\n  // =========== 메모리 관련 함수 ===========\r\n  /**\r\n   * 메모리 정보 가져오기\r\n   * @returns {Object} 메모리 정보\r\n   */\r\n  getMemoryInfo: () => {\r\n    const memoryInfoFunc = createFunctionWrapper(\r\n      'get_memory_info',\r\n      fallbacks.getMemoryInfo,\r\n      null\r\n    );\r\n    \r\n    try {\r\n      const result = memoryInfoFunc();\r\n      if (typeof result === 'string') {\r\n        return JSON.parse(result);\r\n      }\r\n      return result;\r\n    } catch (error) {\r\n      logger.error('메모리 정보 파싱 오류', { error: error.message });\r\n      return fallbacks.getMemoryInfo();\r\n    }\r\n  },\r\n  \r\n  /**\r\n   * 최적화 수준 결정\r\n   * @returns {number} 최적화 수준 (0-4)\r\n   */\r\n  determineOptimizationLevel: createFunctionWrapper(\r\n    'determine_optimization_level',\r\n    fallbacks.determineOptimizationLevel,\r\n    2\r\n  ),\r\n  \r\n  /**\r\n   * 메모리 최적화 수행\r\n   * @param {number} level 최적화 수준 (0-4)\r\n   * @param {boolean} emergency 긴급 최적화 여부\r\n   * @returns {Promise<Object>} 최적화 결과\r\n   */\r\n  optimizeMemory: async (level = 2, emergency = false) => {\r\n    // u32와 boolean 타입으로 변환\r\n    const levelU32 = Math.min(Math.max(0, Math.floor(level)), 4);\r\n    const emergencyBool = Boolean(emergency);\r\n    \r\n    const optimizeFunc = createFunctionWrapper(\r\n      'optimize_memory',\r\n      () => fallbacks.optimizeMemory(levelU32, emergencyBool),\r\n      null,\r\n      true\r\n    );\r\n    \r\n    try {\r\n      moduleState.metrics.lastGcTime = Date.now();\r\n      const result = await optimizeFunc(levelU32, emergencyBool);\r\n      \r\n      // 문자열 결과 파싱\r\n      if (typeof result === 'string') {\r\n        return JSON.parse(result);\r\n      }\r\n      return result;\r\n    } catch (error) {\r\n      logger.error('메모리 최적화 오류', { \r\n        error: error.message, \r\n        level: levelU32, \r\n        emergency: emergencyBool \r\n      });\r\n      return fallbacks.optimizeMemory(levelU32, emergencyBool);\r\n    }\r\n  },\r\n  \r\n  /**\r\n   * 가비지 컬렉션 강제 수행\r\n   * @returns {Object} GC 결과\r\n   */\r\n  forceGarbageCollection: () => {\r\n    const gcFunc = createFunctionWrapper(\r\n      'force_garbage_collection',\r\n      fallbacks.forceGarbageCollection,\r\n      null\r\n    );\r\n    \r\n    try {\r\n      moduleState.metrics.lastGcTime = Date.now();\r\n      const result = gcFunc();\r\n      \r\n      // 문자열 결과 파싱\r\n      if (typeof result === 'string') {\r\n        return JSON.parse(result);\r\n      }\r\n      return result;\r\n    } catch (error) {\r\n      logger.error('가비지 컬렉션 오류', { error: error.message });\r\n      return fallbacks.forceGarbageCollection();\r\n    }\r\n  },\r\n  \r\n  // =========== GPU 관련 함수 ===========\r\n  /**\r\n   * GPU 가속 가능 여부 확인\r\n   * @returns {boolean} GPU 가속 가능 여부\r\n   */\r\n  isGpuAccelerationAvailable: createFunctionWrapper(\r\n    'is_gpu_acceleration_available',\r\n    fallbacks.isGpuAccelerationAvailable,\r\n    false\r\n  ),\r\n  \r\n  /**\r\n   * GPU 가속 활성화\r\n   * @returns {boolean} 성공 여부\r\n   */\r\n  enableGpuAcceleration: createFunctionWrapper(\r\n    'enable_gpu_acceleration',\r\n    fallbacks.enableGpuAcceleration,\r\n    false\r\n  ),\r\n  \r\n  /**\r\n   * GPU 가속 비활성화\r\n   * @returns {boolean} 성공 여부\r\n   */\r\n  disableGpuAcceleration: createFunctionWrapper(\r\n    'disable_gpu_acceleration',\r\n    fallbacks.disableGpuAcceleration,\r\n    true\r\n  ),\r\n  \r\n  /**\r\n   * GPU 정보 가져오기\r\n   * @returns {Object} GPU 정보\r\n   */\r\n  getGpuInfo: () => {\r\n    const gpuInfoFunc = createFunctionWrapper(\r\n      'get_gpu_info',\r\n      fallbacks.getGpuInfo,\r\n      null\r\n    );\r\n    \r\n    try {\r\n      const result = gpuInfoFunc();\r\n      if (typeof result === 'string') {\r\n        return JSON.parse(result);\r\n      }\r\n      return result;\r\n    } catch (error) {\r\n      logger.error('GPU 정보 파싱 오류', { error: error.message });\r\n      return fallbacks.getGpuInfo();\r\n    }\r\n  },\r\n  \r\n  /**\r\n   * GPU 계산 수행\r\n   * @param {string} dataJson JSON 데이터\r\n   * @param {string} computationType 계산 유형\r\n   * @returns {Promise<Object>} 계산 결과\r\n   */\r\n  performGpuComputation: async (dataJson, computationType) => {\r\n    // 타입 검증 및 변환\r\n    const dataStr = typeof dataJson === 'object' ? JSON.stringify(dataJson) : String(dataJson);\r\n    const typeStr = String(computationType || 'matrix');\r\n    \r\n    const computeFunc = createFunctionWrapper(\r\n      'perform_gpu_computation',\r\n      () => fallbacks.performGpuComputation(dataStr, typeStr),\r\n      null,\r\n      true\r\n    );\r\n    \r\n    try {\r\n      const result = await computeFunc(dataStr, typeStr);\r\n      \r\n      // 문자열 결과 파싱\r\n      if (typeof result === 'string') {\r\n        return JSON.parse(result);\r\n      }\r\n      return result;\r\n    } catch (error) {\r\n      logger.error('GPU 계산 오류', { \r\n        error: error.message, \r\n        computationType: typeStr \r\n      });\r\n      return fallbacks.performGpuComputation(dataStr, typeStr);\r\n    }\r\n  },\r\n  \r\n  // =========== 워커 관련 함수 ===========\r\n  /**\r\n   * 워커 풀 초기화\r\n   * @param {number} threadCount 스레드 수 (0=자동)\r\n   * @returns {boolean} 성공 여부\r\n   */\r\n  initializeWorkerPool: (_threadCount = 0) => {\r\n    // 정수로 변환\r\n    const threads = Math.max(0, Math.floor(Number(_threadCount) || 0));\r\n    \r\n    return createFunctionWrapper(\r\n      'initialize_worker_pool',\r\n      () => fallbacks.initializeWorkerPool(threads),\r\n      false\r\n    )(threads);\r\n  },\r\n  \r\n  /**\r\n   * 워커 풀 종료\r\n   * @returns {boolean} 성공 여부\r\n   */\r\n  shutdownWorkerPool: createFunctionWrapper(\r\n    'shutdown_worker_pool',\r\n    fallbacks.shutdownWorkerPool,\r\n    true\r\n  ),\r\n  \r\n  /**\r\n   * 워커 풀에 작업 제출\r\n   * @param {string} taskType 작업 유형\r\n   * @param {string|Object} data 작업 데이터\r\n   * @returns {Promise<Object>} 작업 결과\r\n   */\r\n  submitTask: async (taskType, _data) => {\r\n    // 타입 검증 및 변환\r\n    const taskTypeStr = String(taskType || 'echo');\r\n    const dataStr = typeof _data === 'object' ? JSON.stringify(_data) : String(_data);\r\n    \r\n    const submitFunc = createFunctionWrapper(\r\n      'submit_task',\r\n      () => fallbacks.submitTask(taskTypeStr, dataStr),\r\n      null,\r\n      true\r\n    );\r\n    \r\n    try {\r\n      const result = await submitFunc(taskTypeStr, dataStr);\r\n      \r\n      // 문자열 결과 파싱\r\n      if (typeof result === 'string') {\r\n        return JSON.parse(result);\r\n      }\r\n      return result;\r\n    } catch (error) {\r\n      logger.error('작업 제출 오류', { \r\n        error: error.message, \r\n        taskType: taskTypeStr \r\n      });\r\n      return fallbacks.submitTask(taskTypeStr, dataStr);\r\n    }\r\n  },\r\n  \r\n  /**\r\n   * 워커 풀 통계 가져오기\r\n   * @returns {Object} 워커 풀 통계\r\n   */\r\n  getWorkerPoolStats: () => {\r\n    const statsFunc = createFunctionWrapper(\r\n      'get_worker_pool_stats',\r\n      fallbacks.getWorkerPoolStats,\r\n      null\r\n    );\r\n    \r\n    try {\r\n      const result = statsFunc();\r\n      \r\n      // 문자열 결과 파싱\r\n      if (typeof result === 'string') {\r\n        return JSON.parse(result);\r\n      }\r\n      return result;\r\n    } catch (error) {\r\n      logger.error('워커 풀 통계 가져오기 오류', { error: error.message });\r\n      return fallbacks.getWorkerPoolStats();\r\n    }\r\n  },\r\n  \r\n  // =========== 유틸리티 함수 ===========\r\n  /**\r\n   * 현재 타임스탬프 가져오기\r\n   * @returns {number} 타임스탬프 (밀리초)\r\n   */\r\n  getTimestamp: createFunctionWrapper(\r\n    'get_timestamp',\r\n    () => Date.now(),\r\n    Date.now()\r\n  ),\r\n  \r\n  /**\r\n   * 성능 지표 가져오기\r\n   * @returns {Object} 성능 지표\r\n   */\r\n  getPerformanceMetrics: () => ({ ...moduleState.metrics, timestamp: Date.now() })\r\n};\r\n\r\n// 네이티브 모듈 로드 시도\r\nloadNativeModule();\r\n\r\n// 사용하지 않는 변수 앞에 _로 시작하는 이름 사용\r\nasync function optimizeMemory(level = 2, _emergency = false) {\r\n  // u32와 boolean 타입으로 변환\r\n  const levelU32 = Math.min(Math.max(0, Math.floor(level)), 4);\r\n  const emergencyBool = Boolean(_emergency);\r\n  \r\n  const optimizeFunc = createFunctionWrapper(\r\n    'optimize_memory',\r\n    () => fallbacks.optimizeMemory(levelU32, emergencyBool),\r\n    null,\r\n    true\r\n  );\r\n  \r\n  try {\r\n    moduleState.metrics.lastGcTime = Date.now();\r\n    const result = await optimizeFunc(levelU32, emergencyBool);\r\n    \r\n    // 문자열 결과 파싱\r\n    if (typeof result === 'string') {\r\n      return JSON.parse(result);\r\n    }\r\n    return result;\r\n  } catch (error) {\r\n    logger.error('메모리 최적화 오류', { \r\n      error: error.message, \r\n      level: levelU32, \r\n      emergency: emergencyBool \r\n    });\r\n    return fallbacks.optimizeMemory(levelU32, emergencyBool);\r\n  }\r\n}\r\n\r\nfunction initializeWorkerPool(_threadCount = 0) {\r\n  // 정수로 변환\r\n  const threads = Math.max(0, Math.floor(Number(_threadCount) || 0));\r\n  \r\n  return createFunctionWrapper(\r\n    'initialize_worker_pool',\r\n    () => fallbacks.initializeWorkerPool(threads),\r\n    false\r\n  )(threads);\r\n}\r\n\r\nasync function submitTask(taskType, _data = {}) {\r\n  // 타입 검증 및 변환\r\n  const taskTypeStr = String(taskType || 'echo');\r\n  const dataStr = typeof _data === 'object' ? JSON.stringify(_data) : String(_data);\r\n  \r\n  const submitFunc = createFunctionWrapper(\r\n    'submit_task',\r\n    () => fallbacks.submitTask(taskTypeStr, dataStr),\r\n    null,\r\n    true\r\n  );\r\n  \r\n  try {\r\n    const result = await submitFunc(taskTypeStr, dataStr);\r\n    \r\n    // 문자열 결과 파싱\r\n    if (typeof result === 'string') {\r\n      return JSON.parse(result);\r\n    }\r\n    return result;\r\n  } catch (error) {\r\n    logger.error('작업 제출 오류', { \r\n      error: error.message, \r\n      taskType: taskTypeStr \r\n    });\r\n    return fallbacks.submitTask(taskTypeStr, dataStr);\r\n  }\r\n}\r\n\r\n// 외부에서 logger 다시 불러오지 않고 위에서 생성한 logger 인스턴스 사용\r\nconst loggerInfo = logInfo;\r\n// logError, logWarning은 이미 위에서 선언되었으므로 재사용\r\n\r\n// 모듈 캐싱\r\nlet nativeModule = null;\r\nlet fallbackModule = null;\r\nlet lastLoadAttempt = 0;\r\nconst LOAD_COOLDOWN = 5000; // 재시도 간격 (5초)\r\n\r\n/**\r\n * 네이티브 모듈 로드 시도\r\n * @returns {Promise<Object|null>} 네이티브 모듈 또는 null\r\n */\r\nasync function getNativeModule() {\r\n  // 캐싱된 모듈이 있으면 반환\r\n  if (nativeModule !== null) {\r\n    return nativeModule;\r\n  }\r\n  \r\n  // 마지막 시도 후 일정 시간이 지나지 않았으면 null 반환\r\n  const now = Date.now();\r\n  if (now - lastLoadAttempt < LOAD_COOLDOWN) {\r\n    return null;\r\n  }\r\n  \r\n  lastLoadAttempt = now;\r\n  \r\n  // 가능한 네이티브 모듈 경로\r\n  const possiblePaths = [\r\n    // 개발 환경 경로\r\n    path.join(process.cwd(), 'native-modules', 'target', 'release', 'typing_stats_native.node'),\r\n    path.join(process.cwd(), 'native-modules', 'target', 'debug', 'typing_stats_native.node'),\r\n    // 프로덕션 환경 경로\r\n    path.join(process.cwd(), 'node_modules', 'typing-stats-native', 'index.node'),\r\n    path.join(process.cwd(), '..', 'native-modules', 'target', 'release', 'typing_stats_native.node'),\r\n    path.join(process.cwd(), '..', 'native-modules', 'target', 'debug', 'typing_stats_native.node')\r\n  ];\r\n  \r\n  loggerInfo('네이티브 모듈 로드 시도', { paths: possiblePaths });\r\n  \r\n  // 각 경로 시도\r\n  for (const modulePath of possiblePaths) {\r\n    try {\r\n      if (fs.existsSync(modulePath)) {\r\n        const loadedModule = await import(modulePath);\r\n        nativeModule = loadedModule.default || loadedModule;\r\n        loggerInfo(`네이티브 모듈 로드 성공: ${modulePath}`);\r\n        return nativeModule;\r\n      }\r\n    } catch (error) {\r\n      logWarning(`모듈 로드 실패: ${modulePath}`, { error: error.message });\r\n    }\r\n  }\r\n  \r\n  logWarning('네이티브 모듈을 찾을 수 없음, 폴백 모듈 사용 시도');\r\n  return null;\r\n}\r\n\r\n/**\r\n * 폴백 모듈 로드 시도\r\n * @returns {Promise<Object|null>} 폴백 모듈 또는 null\r\n */\r\nasync function getNativeFallback() {\r\n  // 캐싱된 모듈이 있으면 반환\r\n  if (fallbackModule !== null) {\r\n    return fallbackModule;\r\n  }\r\n  \r\n  // 폴백 모듈 경로 - 여러 가능한 경로 시도\r\n  const possibleFallbackPaths = [\r\n    path.join(process.cwd(), 'src', 'server', 'native', 'fallback', 'index.js'),\r\n    path.join(process.cwd(), 'dist', 'server', 'native', 'fallback', 'index.js'),\r\n    path.join(__dirname, 'fallback', 'index.js'),\r\n    path.join(process.cwd(), 'src', 'server', 'native', 'fallback.js'),\r\n    path.join(process.cwd(), 'server', 'native', 'fallback.js'),\r\n    path.join(process.cwd(), '.next', 'server', 'native', 'fallback.js')\r\n  ];\r\n  \r\n  // 로그에 모든 시도 경로 기록\r\n  loggerInfo('폴백 모듈 로드 시도', { paths: possibleFallbackPaths });\r\n  \r\n  // 각 경로 시도\r\n  for (const fallbackPath of possibleFallbackPaths) {\r\n    try {\r\n      if (fs.existsSync(fallbackPath)) {\r\n        const loadedModule = await import(fallbackPath);\r\n        fallbackModule = loadedModule.default || loadedModule;\r\n        loggerInfo(`폴백 모듈 로드: ${fallbackPath}`);\r\n        return fallbackModule;\r\n      }\r\n    } catch (error) {\r\n      logWarning(`폴백 모듈 로드 실패: ${fallbackPath}`, { error: error.message });\r\n    }\r\n  }\r\n  \r\n  logError('폴백 모듈을 찾을 수 없음');\r\n  return null;\r\n}\r\n\r\n/**\r\n * 네이티브 모듈 사용 가능 여부 확인\r\n * @returns {boolean} 네이티브 모듈 사용 가능 여부\r\n */\r\nfunction isNativeModuleAvailable() {\r\n  return nativeModule !== null;\r\n}\r\n\r\n/**\r\n * 폴백 모듈 사용 가능 여부 확인\r\n * @returns {boolean} 폴백 모듈 사용 가능 여부\r\n */\r\nfunction isFallbackModuleAvailable() {\r\n  return fallbackModule !== null;\r\n}\r\n\r\n/**\r\n * 네이티브 모듈 정보 가져오기\r\n * @returns {Promise<Object>} 네이티브 모듈 정보\r\n */\r\nasync function getNativeModuleInfo() {\r\n  const module = await getNativeModule();\r\n  const fallback = module ? null : await getNativeFallback();\r\n  \r\n  return {\r\n    available: module !== null || fallback !== null,\r\n    usingNative: module !== null,\r\n    usingFallback: module === null && fallback !== null,\r\n    noModuleAvailable: module === null && fallback === null,\r\n    timestamp: Date.now()\r\n  };\r\n}\r\n\r\n/**\r\n * 네이티브 함수 래핑\r\n * 네이티브 모듈이 없으면 폴백을 사용하고, 두 모듈 모두 없으면 에러 반환\r\n * @param {string} functionName 함수 이름\r\n * @param {Array} args 함수 인자\r\n * @returns {Promise<any>} 함수 실행 결과\r\n */\r\nasync function callNativeFunction(functionName, ...args) {\r\n  // 네이티브 모듈 로드 시도\r\n  const nativeModule = await getNativeModule();\r\n  \r\n  if (nativeModule && typeof nativeModule[functionName] === 'function') {\r\n    // 네이티브 모듈 함수 호출\r\n    return nativeModule[functionName](...args);\r\n  }\r\n  \r\n  // 폴백 모듈 로드 시도\r\n  const fallbackModule = await getNativeFallback();\r\n  \r\n  if (fallbackModule && typeof fallbackModule[functionName] === 'function') {\r\n    // 폴백 모듈 함수 호출\r\n    return fallbackModule[functionName](...args);\r\n  }\r\n  \r\n  // 두 모듈 모두 사용할 수 없음 - 기본값 반환\r\n  logError(`${functionName} 함수를 네이티브 모듈과 폴백 모듈 모두에서 찾을 수 없습니다`);\r\n  \r\n  // 함수별 기본 응답 생성\r\n  return createDefaultResponse(functionName);\r\n}\r\n\r\n/**\r\n * 함수별 기본 응답 생성\r\n * @param {string} functionName 함수 이름\r\n * @returns {any} 기본 응답\r\n */\r\nfunction createDefaultResponse(functionName) {\r\n  const timestamp = Date.now();\r\n  \r\n  switch (functionName) {\r\n    case 'get_memory_info':\r\n      return JSON.stringify({\r\n        success: false,\r\n        timestamp,\r\n        heap_used: 0,\r\n        heap_total: 0,\r\n        heap_used_mb: 0,\r\n        rss: 0,\r\n        rss_mb: 0,\r\n        percent_used: 0,\r\n        error: 'Memory info not available'\r\n      });\r\n      \r\n    case 'force_garbage_collection':\r\n      return JSON.stringify({\r\n        success: false,\r\n        timestamp,\r\n        freed_memory: 0,\r\n        freed_mb: 0,\r\n        duration: 0,\r\n        error: 'Garbage collection not available'\r\n      });\r\n      \r\n    case 'optimize_memory':\r\n      return JSON.stringify({\r\n        success: false,\r\n        timestamp,\r\n        optimization_level: 'none',\r\n        freed_memory: 0,\r\n        freed_mb: 0,\r\n        duration: 0,\r\n        error: 'Memory optimization not available'\r\n      });\r\n      \r\n    case 'get_gpu_info':\r\n      return JSON.stringify({\r\n        success: false,\r\n        timestamp,\r\n        available: false,\r\n        acceleration_enabled: false,\r\n        name: 'Software Renderer',\r\n        vendor: 'None',\r\n        error: 'GPU info not available'\r\n      });\r\n      \r\n    default:\r\n      return JSON.stringify({\r\n        success: false,\r\n        timestamp,\r\n        error: `Function ${functionName} not implemented`\r\n      });\r\n  }\r\n}\r\n\r\n// 공통 네이티브 모듈 함수들\r\nconst combinedExports = {\r\n  getNativeModule,\r\n  getNativeFallback,\r\n  getNativeModuleInfo,\r\n  callNativeFunction,\r\n  isNativeModuleAvailable,\r\n  isFallbackModuleAvailable,\r\n  \r\n  // 보다 간편한 사용을 위한 일반적인 함수들\r\n  getMemoryInfo: async () => {\r\n    try {\r\n      return await callNativeFunction('get_memory_info');\r\n    } catch (error) {\r\n      logError('메모리 정보 가져오기 실패', { error: error.message });\r\n      return createDefaultResponse('get_memory_info');\r\n    }\r\n  },\r\n  \r\n  forceGarbageCollection: async () => {\r\n    try {\r\n      return await callNativeFunction('force_garbage_collection');\r\n    } catch (error) {\r\n      logError('가비지 컬렉션 수행 실패', { error: error.message });\r\n      return createDefaultResponse('force_garbage_collection');\r\n    }\r\n  },\r\n  \r\n  optimizeMemory: async (level = 'medium', emergency = false) => {\r\n    try {\r\n      return await callNativeFunction('optimize_memory', level, emergency);\r\n    } catch (error) {\r\n      logError('메모리 최적화 실패', { error: error.message });\r\n      return createDefaultResponse('optimize_memory');\r\n    }\r\n  },\r\n  \r\n  getGpuInfo: async () => {\r\n    try {\r\n      return await callNativeFunction('get_gpu_info');\r\n    } catch (error) {\r\n      logError('GPU 정보 가져오기 실패', { error: error.message });\r\n      return createDefaultResponse('get_gpu_info');\r\n    }\r\n  },\r\n  \r\n  setGpuAcceleration: async (enable) => {\r\n    try {\r\n      const functionName = enable ? 'enable_gpu_acceleration' : 'disable_gpu_acceleration';\r\n      return await callNativeFunction(functionName);\r\n    } catch (error) {\r\n      logError(`GPU 가속화 ${enable ? '활성화' : '비활성화'} 실패`, { error: error.message });\r\n      return JSON.stringify({\r\n        success: false,\r\n        timestamp: Date.now(),\r\n        enabled: false,\r\n        error: `GPU acceleration ${enable ? 'enable' : 'disable'} failed: ${error.message}`\r\n      });\r\n    }\r\n  },\r\n  \r\n  // 네이티브 모듈 API\r\n  ...nativeModuleApi,\r\n  \r\n  // 폴백 구현 함수들\r\n  getMemoryInfo,\r\n  determineOptimizationLevel,\r\n  requestGarbageCollection,\r\n  optimizeMemory,\r\n  isGpuAccelerationAvailable,\r\n  enableGpuAcceleration,\r\n  disableGpuAcceleration,\r\n  getGpuInfo,\r\n  performGpuComputation,\r\n  getNativeModuleInfo\r\n};\r\n\r\n// 단일 default export 사용\r\nexport default combinedExports;\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\types\\app-types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\types\\common.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":39,"column":4,"nodeType":"Identifier","messageId":"unusedVar","endLine":39,"endColumn":11},{"ruleId":"no-unused-vars","severity":2,"message":"'args' is defined but never used.","line":39,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":39,"endColumn":20}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 시스템에서 자주 사용하는 공통 타입 정의\r\n */\r\n\r\n/**\r\n * 범용 레코드 타입 (any 대체)\r\n */\r\nexport type GenericRecord = Record<string, unknown>;\r\n\r\n/**\r\n * 모듈 리소스 객체 타입\r\n */\r\nexport interface ModuleResource {\r\n  id: string;\r\n  name: string;\r\n  version: string;\r\n  loaded: boolean;\r\n  status: 'active' | 'inactive' | 'error';\r\n  memoryUsage?: number;\r\n  details?: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * 메모리 정보 타입\r\n */\r\nexport interface DetailedMemoryInfo {\r\n  heapUsed: number;\r\n  heapTotal: number;\r\n  external?: number;\r\n  rss?: number;\r\n  arrayBuffers?: number;\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * 시스템 이벤트 핸들러 타입\r\n */\r\nexport type EventHandlerFunction<T = unknown> = \r\n  (data: T, ...args: unknown[]) => void | Promise<void>;\r\n\r\n/**\r\n * 워커 메시지 기본 인터페이스\r\n */\r\nexport interface WorkerMessageBase {\r\n  action: string;\r\n  requestId?: string;\r\n  timestamp?: number;\r\n}\r\n\r\n/**\r\n * 통계 계산 요청 메시지\r\n */\r\nexport interface StatsCalculationMessage extends WorkerMessageBase {\r\n  action: 'calculate-stats';\r\n  data: {\r\n    keyCount: number;\r\n    typingTime: number;\r\n    content: string;\r\n    errors: number;\r\n    processingMode: string;\r\n  }\r\n}\r\n\r\n/**\r\n * 타이핑 패턴 분석 요청 메시지\r\n */\r\nexport interface PatternAnalysisMessage extends WorkerMessageBase {\r\n  action: 'analyze-typing-pattern';\r\n  data: {\r\n    keyPresses: string[];\r\n    timestamps: number[];\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\types\\global.d.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'element' is defined but never used.","line":18,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'Element' is not defined.","line":18,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":18,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'EventListener' is not defined.","line":18,"column":62,"nodeType":"Identifier","messageId":"undef","endLine":18,"endColumn":75},{"ruleId":"no-unused-vars","severity":2,"message":"'emergency' is defined but never used.","line":32,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":39},{"ruleId":"no-unused-vars","severity":2,"message":"'emergency' is defined but never used.","line":41,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":41,"endColumn":44},{"ruleId":"no-unused-vars","severity":2,"message":"'level' is defined but never used.","line":48,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":48,"endColumn":50},{"ruleId":"no-unused-vars","severity":2,"message":"'aggressive' is defined but never used.","line":52,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":52,"endColumn":44},{"ruleId":"no-unused-vars","severity":2,"message":"'interval' is defined but never used.","line":54,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":54,"endColumn":53},{"ruleId":"no-unused-vars","severity":2,"message":"'threshold' is defined but never used.","line":54,"column":55,"nodeType":"Identifier","messageId":"unusedVar","endLine":54,"endColumn":73},{"ruleId":"no-unused-vars","severity":2,"message":"'element' is defined but never used.","line":71,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":71,"endColumn":55},{"ruleId":"no-unused-vars","severity":2,"message":"'options' is defined but never used.","line":71,"column":57,"nodeType":"Identifier","messageId":"unusedVar","endLine":71,"endColumn":70},{"ruleId":"no-unused-vars","severity":2,"message":"'canvas' is defined but never used.","line":72,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":72,"endColumn":62},{"ruleId":"no-undef","severity":2,"message":"'HTMLCanvasElement' is not defined.","line":72,"column":45,"nodeType":"Identifier","messageId":"undef","endLine":72,"endColumn":62},{"ruleId":"no-unused-vars","severity":2,"message":"'preferWebGL2' is defined but never used.","line":72,"column":64,"nodeType":"Identifier","messageId":"unusedVar","endLine":72,"endColumn":86},{"ruleId":"no-undef","severity":2,"message":"'WebGLRenderingContext' is not defined.","line":72,"column":91,"nodeType":"Identifier","messageId":"undef","endLine":72,"endColumn":112},{"ruleId":"no-undef","severity":2,"message":"'WebGL2RenderingContext' is not defined.","line":72,"column":115,"nodeType":"Identifier","messageId":"undef","endLine":72,"endColumn":137},{"ruleId":"no-unused-vars","severity":2,"message":"'gl' is defined but never used.","line":73,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":73,"endColumn":81},{"ruleId":"no-undef","severity":2,"message":"'WebGLRenderingContext' is not defined.","line":73,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":73,"endColumn":56},{"ruleId":"no-undef","severity":2,"message":"'WebGL2RenderingContext' is not defined.","line":73,"column":59,"nodeType":"Identifier","messageId":"undef","endLine":73,"endColumn":81},{"ruleId":"no-unused-vars","severity":2,"message":"'resources' is defined but never used.","line":73,"column":83,"nodeType":"Identifier","messageId":"unusedVar","endLine":73,"endColumn":97},{"ruleId":"no-undef","severity":2,"message":"'EventListener' is not defined.","line":91,"column":54,"nodeType":"Identifier","messageId":"undef","endLine":91,"endColumn":67},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":101,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":101,"endColumn":48},{"ruleId":"no-unused-vars","severity":2,"message":"'callback' is defined but never used.","line":126,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":126,"endColumn":65},{"ruleId":"no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":126,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":126,"endColumn":56},{"ruleId":"no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":127,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":127,"endColumn":87},{"ruleId":"no-undef","severity":2,"message":"'HTMLImageElement' is not defined.","line":140,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":140,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'DOMStringMap' is not defined.","line":147,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":147,"endColumn":24}],"suppressedMessages":[],"errorCount":27,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 전역 타입 선언\r\n * \r\n * 타입스크립트 전역 타입 정의입니다.\r\n */\r\n\r\n// window 전역 객체 확장\r\ndeclare global {\r\n  // 메모리 최적화 관련 전역 객체\r\n  interface Window {\r\n    // Electron API\r\n    electronAPI?: ElectronAPI;\r\n    \r\n    // 개발용 전역 GC 함수 (Chrome에서 --js-flags=\"--expose-gc\" 옵션 필요)\r\n    gc?: () => void;\r\n    \r\n    // 개발자 도구에서 getEventListeners 함수\r\n    getEventListeners?: (element: Element) => Record<string, EventListener[]>;\r\n    \r\n    // 메모리 최적화 유틸리티\r\n    __memoryOptimizer?: {\r\n      // 메모리 정보 가져오기\r\n      getMemoryInfo?: () => any;\r\n      \r\n      // 메모리 사용률 가져오기\r\n      getMemoryUsagePercent?: () => Promise<number>;\r\n      \r\n      // 가비지 컬렉션 제안\r\n      suggestGarbageCollection?: () => void;\r\n      \r\n      // GC 요청\r\n      requestGC?: (emergency?: boolean) => Promise<any>;\r\n      \r\n      // 브라우저 캐시 정리\r\n      clearBrowserCaches?: () => Promise<boolean>;\r\n      \r\n      // 스토리지 캐시 정리\r\n      clearStorageCaches?: () => boolean;\r\n      \r\n      // 메모리 최적화\r\n      optimizeMemory?: (emergency?: boolean) => Promise<any>;\r\n      \r\n      // 다양한 최적화 함수들\r\n      performBasicOptimization?: () => Promise<any>;\r\n      performMediumOptimization?: () => Promise<any>;\r\n      performHighOptimization?: () => Promise<any>;\r\n      performCriticalOptimization?: () => Promise<any>;\r\n      performOptimizationByLevel?: (level: number) => Promise<any>;\r\n      emergencyMemoryRecovery?: () => Promise<boolean>;\r\n      getMemoryInfo?: () => Promise<MemoryInfo | null>;\r\n      getMemoryUsagePercentage?: () => Promise<number>;\r\n      optimizeMemory?: (aggressive: boolean) => Promise<any>;\r\n      cleanupMemory?: () => Promise<any>;\r\n      setupPeriodicOptimization?: (interval?: number, threshold?: number) => Promise<() => void>;\r\n      cleanupPeriodicOptimization?: () => void;\r\n      settings?: MemorySettings;\r\n    };\r\n    \r\n    // GPU 가속 정보\r\n    __gpuInfo?: {\r\n      isAccelerated: () => boolean;\r\n      renderer: string;\r\n      vendor: string;\r\n      getGPUTier: () => { tier: number; type: string };\r\n      isHardwareAccelerated: () => boolean;\r\n    };\r\n    \r\n    // GPU 가속 유틸리티\r\n    __gpuAccelerator?: {\r\n      detectGPUAcceleration: () => Promise<boolean>;\r\n      applyHardwareAcceleration: (element: HTMLElement, options?: any) => void;\r\n      createOptimizedWebGLContext: (canvas: HTMLCanvasElement, preferWebGL2?: boolean) => WebGLRenderingContext | WebGL2RenderingContext | null;\r\n      cleanupWebGLResources: (gl: WebGLRenderingContext | WebGL2RenderingContext, resources: any) => void;\r\n      enableGPUAcceleration: () => void;\r\n      getStatus: () => any;\r\n      settings?: GpuSettings;\r\n    };\r\n    \r\n    // 앱 복구 유틸리티\r\n    __appRecovery?: {\r\n      performEmergencyMemoryRecovery: () => Promise<boolean>;\r\n      collectMemoryDiagnostics: () => any;\r\n    };\r\n    \r\n    // 추적 중인 타이머 ID\r\n    __timeoutIds?: number[];\r\n    __intervalIds?: number[];\r\n    __animationFrameIds?: number[];\r\n    \r\n    // 추적 중인 이벤트 리스너\r\n    __eventListeners?: Record<string, Record<string, EventListener>>;\r\n    \r\n    // 메모리 캐시\r\n    __memoryCache?: Map<any, any>;\r\n    \r\n    // 버퍼 캐시\r\n    __bufferCache?: Record<string, any>;\r\n    \r\n    // 로드된 모듈 관리\r\n    __loadedModules?: Map<string, { unload?: () => void }>;\r\n    __imageCache?: Map<string, HTMLImageElement>;\r\n    _dynamicModules?: Map<string, any>;\r\n  }\r\n  \r\n  // 서버 사이드 전역 캐싱 (API 라우트에서 사용)\r\n  namespace NodeJS {\r\n    interface Global {\r\n      // 메모리 정보 캐시\r\n      __memoryInfoCache?: Map<string, { data: any; timestamp: number }>;\r\n      \r\n      // GPU 정보 캐시\r\n      __gpuInfoCache?: Map<string, { data: any; timestamp: number }>;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Electron API 인터페이스\r\n */\r\nexport interface ElectronAPI {\r\n  // 추적 시작/중지\r\n  startTracking: () => void;\r\n  stopTracking: () => void;\r\n  \r\n  // GC 이벤트\r\n  onRequestGC: (callback: (data: { emergency: boolean }) => void) => () => void;\r\n  rendererGCCompleted: (data: { timestamp: number; success: boolean; memoryInfo: any }) => void;\r\n}\r\n\r\n/**\r\n * 전역 타입 확장\r\n */\r\n\r\nimport { MemorySettings } from '../app/utils/memory-settings-manager';\r\nimport { GpuSettings } from '../app/utils/gpu-settings-bridge';\r\nimport { MemoryInfo } from '../app/utils/memory/types';\r\n\r\n// 전역 컬렉션 타입\r\ninterface GlobalCollections {\r\n  imageCache?: Map<string, HTMLImageElement>;\r\n  dataCache?: Map<string, any>;\r\n  bufferCache?: Map<string, ArrayBuffer>;\r\n}\r\n\r\n// DOM 요소 확장\r\ninterface HTMLElement {\r\n  dataset: DOMStringMap & {\r\n    keepLoaded?: string;\r\n    originalSrc?: string;\r\n    animate?: string;\r\n    scroll?: string;\r\n    chart?: string;\r\n  };\r\n}\r\n\r\nexport {};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\types\\gpu-types.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'MatrixMultiplication' is defined but never used.","line":7,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":23},{"ruleId":"no-unused-vars","severity":2,"message":"'TextAnalysis' is defined but never used.","line":8,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":15},{"ruleId":"no-unused-vars","severity":2,"message":"'PatternDetection' is defined but never used.","line":9,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'ImageProcessing' is defined but never used.","line":10,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":18},{"ruleId":"no-unused-vars","severity":2,"message":"'DataAggregation' is defined but never used.","line":11,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":18},{"ruleId":"no-unused-vars","severity":2,"message":"'TypingStatistics' is defined but never used.","line":12,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'Custom' is defined but never used.","line":13,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'Small' is defined but never used.","line":18,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":8},{"ruleId":"no-unused-vars","severity":2,"message":"'Medium' is defined but never used.","line":19,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'Large' is defined but never used.","line":20,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":8},{"ruleId":"no-unused-vars","severity":2,"message":"'ExtraLarge' is defined but never used.","line":21,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":13}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GPU 관련 타입 정의\r\n */\r\n\r\n// GPU 작업 타입\r\nexport enum GpuTaskType {\r\n  MatrixMultiplication = 'matrix',\r\n  TextAnalysis = 'text',\r\n  PatternDetection = 'pattern',\r\n  ImageProcessing = 'image',\r\n  DataAggregation = 'data',\r\n  TypingStatistics = 'typing',\r\n  Custom = 'custom'\r\n}\r\n\r\n// GPU 워크로드 크기 타입\r\nexport enum GpuWorkloadSize {\r\n  Small = 'small',\r\n  Medium = 'medium',\r\n  Large = 'large',\r\n  ExtraLarge = 'xl'\r\n}\r\n\r\n// GPU 장치 정보 인터페이스\r\nexport interface GpuDeviceInfo {\r\n  name: string;\r\n  vendor: string;\r\n  driver_info: string;\r\n  device_type: string;\r\n  backend: string;\r\n  timestamp: number;\r\n}\r\n\r\n// GPU 기능 인터페이스\r\nexport interface GpuCapabilities {\r\n  max_buffer_size: number;\r\n  max_compute_workgroups: [number, number, number];\r\n  max_invocations: number;\r\n  supports_timestamp_query: boolean;\r\n  supports_pipeline_statistics_query: boolean;\r\n  compute_supported: boolean;\r\n  shading_supported: boolean;\r\n}\r\n\r\n// GPU 계산 결과 인터페이스\r\nexport interface GpuComputationResult<T = any> {\r\n  success: boolean;\r\n  task_type: string;\r\n  duration_ms: number;\r\n  result: T;\r\n  error: string | null;\r\n  timestamp: number;\r\n  gpu_info?: {\r\n    name: string;\r\n    type: string;\r\n    backend: string;\r\n  };\r\n  used_gpu_acceleration: boolean;\r\n}\r\n\r\n/**\r\n * GPU 정보를 나타내는 인터페이스\r\n */\r\nexport interface GpuInfo {\r\n  /** GPU 장치 이름 */\r\n  deviceName: string;\r\n  \r\n  /** GPU 메모리 크기 (MB) */\r\n  memorySize?: number;\r\n  \r\n  /** 드라이버 버전 */\r\n  driverVersion?: string;\r\n  \r\n  /** 가속 가능 여부 */\r\n  accelerationAvailable: boolean;\r\n  \r\n  /** 현재 사용 여부 */\r\n  accelerationActive: boolean;\r\n  \r\n  /** GPU 가속 사용 가능한 기능 목록 */\r\n  features?: string[];\r\n  \r\n  /** 조회 시간 */\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * GPU 설정을 나타내는 인터페이스\r\n */\r\nexport interface GpuSettings {\r\n  /** GPU 가속 사용 여부 */\r\n  useHardwareAcceleration: boolean;\r\n  \r\n  /** 처리 모드 (auto, cpu, gpu) */\r\n  processingMode: 'auto' | 'cpu' | 'gpu';\r\n  \r\n  /** 가속을 적용할 작업 유형 */\r\n  acceleratedOperations?: string[];\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\types\\index.ts","messages":[{"ruleId":"no-redeclare","severity":2,"message":"'MemoryInfo' is already defined.","line":25,"column":18,"nodeType":"Identifier","messageId":"redeclared","endLine":25,"endColumn":28},{"ruleId":"no-unused-vars","severity":2,"message":"'PERIODIC_CHECK' is defined but never used.","line":186,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":186,"endColumn":17},{"ruleId":"no-unused-vars","severity":2,"message":"'PAGE_NAVIGATION' is defined but never used.","line":187,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":187,"endColumn":18},{"ruleId":"no-unused-vars","severity":2,"message":"'OPTIMIZATION' is defined but never used.","line":188,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":188,"endColumn":15},{"ruleId":"no-unused-vars","severity":2,"message":"'COMPONENT_MOUNT' is defined but never used.","line":189,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":189,"endColumn":18},{"ruleId":"no-unused-vars","severity":2,"message":"'COMPONENT_UNMOUNT' is defined but never used.","line":190,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":190,"endColumn":20},{"ruleId":"no-unused-vars","severity":2,"message":"'USER_ACTION' is defined but never used.","line":191,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":191,"endColumn":14},{"ruleId":"no-unused-vars","severity":2,"message":"'GARBAGE_COLLECTION' is defined but never used.","line":192,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":192,"endColumn":21},{"ruleId":"no-unused-vars","severity":2,"message":"'RESOURCE_LOADING' is defined but never used.","line":193,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":193,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'ERROR' is defined but never used.","line":194,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":194,"endColumn":8},{"ruleId":"no-unused-vars","severity":2,"message":"'WARNING' is defined but never used.","line":195,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":195,"endColumn":10},{"ruleId":"no-unused-vars","severity":2,"message":"'CUSTOM' is defined but never used.","line":196,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":196,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'INFO' is defined but never used.","line":197,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":197,"endColumn":7},{"ruleId":"no-unused-vars","severity":2,"message":"'GC' is defined but never used.","line":198,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":198,"endColumn":5},{"ruleId":"no-redeclare","severity":2,"message":"'OptimizationLevel' is already defined.","line":202,"column":13,"nodeType":"Identifier","messageId":"redeclared","endLine":202,"endColumn":30},{"ruleId":"no-unused-vars","severity":2,"message":"'NORMAL' is defined but never used.","line":203,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":203,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'LOW' is defined but never used.","line":204,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":204,"endColumn":6},{"ruleId":"no-unused-vars","severity":2,"message":"'MEDIUM' is defined but never used.","line":205,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":205,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'HIGH' is defined but never used.","line":206,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":206,"endColumn":7},{"ruleId":"no-unused-vars","severity":2,"message":"'CRITICAL' is defined but never used.","line":207,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":207,"endColumn":11},{"ruleId":"no-unused-vars","severity":2,"message":"'EXTREME' is defined but never used.","line":208,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":208,"endColumn":10},{"ruleId":"no-unused-vars","severity":2,"message":"'LOW' is defined but never used.","line":216,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":216,"endColumn":6},{"ruleId":"no-unused-vars","severity":2,"message":"'MEDIUM' is defined but never used.","line":217,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":217,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'HIGH' is defined but never used.","line":218,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":218,"endColumn":7},{"ruleId":"no-unused-vars","severity":2,"message":"'CRITICAL' is defined but never used.","line":219,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":219,"endColumn":11},{"ruleId":"no-redeclare","severity":2,"message":"'ProcessingMode' is already defined.","line":223,"column":13,"nodeType":"Identifier","messageId":"redeclared","endLine":223,"endColumn":27},{"ruleId":"no-unused-vars","severity":2,"message":"'MATRIX_MULTIPLICATION' is defined but never used.","line":227,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":227,"endColumn":24},{"ruleId":"no-unused-vars","severity":2,"message":"'TEXT_ANALYSIS' is defined but never used.","line":228,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":228,"endColumn":16},{"ruleId":"no-unused-vars","severity":2,"message":"'PATTERN_DETECTION' is defined but never used.","line":229,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":229,"endColumn":20},{"ruleId":"no-unused-vars","severity":2,"message":"'IMAGE_PROCESSING' is defined but never used.","line":230,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":230,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'DATA_AGGREGATION' is defined but never used.","line":231,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":231,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'TYPING_STATISTICS' is defined but never used.","line":232,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":232,"endColumn":20},{"ruleId":"no-unused-vars","severity":2,"message":"'CUSTOM' is defined but never used.","line":233,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":233,"endColumn":9},{"ruleId":"no-redeclare","severity":2,"message":"'MemoryInfo' is already defined.","line":261,"column":18,"nodeType":"Identifier","messageId":"redeclared","endLine":261,"endColumn":28},{"ruleId":"no-redeclare","severity":2,"message":"'OptimizationResult' is already defined.","line":283,"column":18,"nodeType":"Identifier","messageId":"redeclared","endLine":283,"endColumn":36},{"ruleId":"no-redeclare","severity":2,"message":"'GCResult' is already defined.","line":300,"column":18,"nodeType":"Identifier","messageId":"redeclared","endLine":300,"endColumn":26},{"ruleId":"no-redeclare","severity":2,"message":"'GpuInfo' is already defined.","line":309,"column":18,"nodeType":"Identifier","messageId":"redeclared","endLine":309,"endColumn":25},{"ruleId":"no-unused-vars","severity":2,"message":"'emergency' is defined but never used.","line":424,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":424,"endColumn":39},{"ruleId":"no-redeclare","severity":2,"message":"'OptimizationLevel' is already defined.","line":436,"column":13,"nodeType":"Identifier","messageId":"redeclared","endLine":436,"endColumn":30},{"ruleId":"no-unused-vars","severity":2,"message":"'LIGHT' is defined but never used.","line":437,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":437,"endColumn":8},{"ruleId":"no-unused-vars","severity":2,"message":"'MEDIUM' is defined but never used.","line":438,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":438,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'AGGRESSIVE' is defined but never used.","line":439,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":439,"endColumn":13},{"ruleId":"no-unused-vars","severity":2,"message":"'EMERGENCY' is defined but never used.","line":440,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":440,"endColumn":12},{"ruleId":"no-redeclare","severity":2,"message":"'OptimizationResult' is already defined.","line":444,"column":18,"nodeType":"Identifier","messageId":"redeclared","endLine":444,"endColumn":36}],"suppressedMessages":[],"errorCount":44,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 애플리케이션에서 사용하는 공통 타입 정의\r\n */\r\n\r\nimport { MemoryInfo } from './memory-types';\r\nimport { GpuInfo } from './gpu-types';\r\nimport { NativeModuleInfo, NativeModuleConfig } from './native-module';\r\n\r\n// 기존의 타입들은 유지\r\n\r\n// 네이티브 모듈 타입 재내보내기\r\nexport * from './native-module';\r\n\r\n/**\r\n * 앱 내 사용되는 타입 정의의 중앙 집중화 파일\r\n */\r\n\r\n// 기본 타입 정의들 내보내기\r\nexport * from './common';\r\nexport * from './native-module';\r\n\r\n/**\r\n * 메모리 정보 인터페이스\r\n */\r\nexport interface MemoryInfo {\r\n  heap_used: number;\r\n  heap_total: number;\r\n  heap_limit: number;\r\n  heap_used_mb: number;\r\n  percent_used: number;\r\n  rss: number;\r\n  rss_mb: number;\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * 최적화 레벨 타입\r\n */\r\nexport type OptimizationLevel = 'NORMAL' | 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n\r\n/**\r\n * 최적화 결과 인터페이스\r\n */\r\nexport interface OptimizationResult {\r\n  success: boolean;\r\n  optimizationLevel: number | OptimizationLevel;\r\n  freedMemory?: number;\r\n  freedMB?: number;\r\n  timestamp: number;\r\n  error?: string;\r\n  duration?: number;\r\n}\r\n\r\n/**\r\n * 가비지 컬렉션 결과 인터페이스\r\n */\r\nexport interface GCResult {\r\n  success: boolean;\r\n  freedMemory?: number;\r\n  freedMB?: number;\r\n  duration?: number;\r\n  timestamp: number;\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * 메모리 상태 타입\r\n */\r\nexport type MemoryState = 'normal' | 'warning' | 'critical';\r\n\r\n/**\r\n * 코드 처리 모드 타입\r\n */\r\nexport type ProcessingMode = 'auto' | 'normal' | 'cpu-intensive' | 'gpu-intensive';\r\n\r\n/**\r\n * 메모리 설정 인터페이스\r\n */\r\nexport interface MemorySettings {\r\n  preferNativeImplementation: boolean;\r\n  enableAutomaticFallback: boolean;\r\n  enableAutomaticOptimization: boolean;\r\n  optimizationThreshold: number;\r\n  optimizationInterval: number;\r\n  aggressiveGC: boolean;\r\n  enableLogging: boolean;\r\n  enablePerformanceMetrics: boolean;\r\n  useMemoryPool: boolean;\r\n  fallbackRetryDelay: number;\r\n  poolCleanupInterval: number;\r\n  processingMode: ProcessingMode;\r\n  componentSpecificSettings: {\r\n    [componentId: string]: {\r\n      optimizeOnUnmount: boolean;\r\n      aggressiveCleanup: boolean;\r\n    }\r\n  };\r\n}\r\n\r\n// 사용자 설정 관련 타입 정의\r\nexport interface UserSettings {\r\n  theme: 'light' | 'dark' | 'system';\r\n  memoryOptimization: {\r\n    autoOptimize: boolean;\r\n    threshold: number;\r\n    interval: number;\r\n  };\r\n  performance: {\r\n    usePrefetch: boolean;\r\n    usePreload: boolean;\r\n    useGpuAcceleration: boolean;\r\n    processingMode: 'auto' | 'cpu' | 'gpu' | 'balanced';\r\n  };\r\n  notifications: {\r\n    enabled: boolean;\r\n    showMemoryWarnings: boolean;\r\n    showOptimizationResults: boolean;\r\n  };\r\n}\r\n\r\n// 앱 상태 관련 타입 정의\r\nexport interface AppState {\r\n  isInitialized: boolean;\r\n  lastMemoryCheck: number | null;\r\n  memoryUsage: {\r\n    current: number;\r\n    threshold: number;\r\n  };\r\n  nativeSupport: {\r\n    available: boolean;\r\n    fallbackMode: boolean;\r\n  };\r\n  gpuAcceleration: {\r\n    enabled: boolean;\r\n    available: boolean;\r\n  };\r\n}\r\n\r\n// 로그 항목 타입 정의\r\nexport interface LogEntry {\r\n  timestamp: number;\r\n  level: 'debug' | 'info' | 'warn' | 'error';\r\n  message: string;\r\n  data?: Record<string, unknown>;\r\n}\r\n\r\n// 시스템 정보 타입 정의\r\nexport interface SystemInfo {\r\n  os: string;\r\n  arch: string;\r\n  cpus: number;\r\n  totalMemory: number;\r\n  freeMemory: number;\r\n  nodeVersion: string;\r\n}\r\n\r\n// 성능 지표 타입 정의\r\nexport interface PerformanceMetrics {\r\n  fps: number;\r\n  memory: {\r\n    jsHeapSizeLimit: number;\r\n    totalJSHeapSize: number;\r\n    usedJSHeapSize: number;\r\n  };\r\n  cpu: {\r\n    usage: number;\r\n    processes: number;\r\n  };\r\n  timestamp: number;\r\n}\r\n\r\n// 통계 데이터 타입 정의\r\nexport interface StatsData {\r\n  id?: number;\r\n  timestamp: number;\r\n  keyCount: number;\r\n  typingTime: number;\r\n  windowTitle?: string;\r\n  application?: string;\r\n  browser?: string;\r\n  appCategory?: string;\r\n}\r\n\r\n// 메모리 이벤트 타입\r\nexport enum MemoryEventType {\r\n  PERIODIC_CHECK = 'periodic_check',\r\n  PAGE_NAVIGATION = 'page_navigation',\r\n  OPTIMIZATION = 'optimization',\r\n  COMPONENT_MOUNT = 'component_mount',\r\n  COMPONENT_UNMOUNT = 'component_unmount',\r\n  USER_ACTION = 'user_action',\r\n  GARBAGE_COLLECTION = 'garbage_collection',\r\n  RESOURCE_LOADING = 'resource_loading',\r\n  ERROR = 'error',\r\n  WARNING = 'warning',\r\n  CUSTOM = 'custom',\r\n  INFO = 'info',\r\n  GC = 'gc'\r\n}\r\n\r\n// 메모리 최적화 수준 열거형\r\nexport enum OptimizationLevel {\r\n  NORMAL = 0,\r\n  LOW = 1,\r\n  MEDIUM = 2,\r\n  HIGH = 3,\r\n  CRITICAL = 4,\r\n  EXTREME = 4 // CRITICAL과 같은 값으로 설정하여 호환성 유지\r\n}\r\n\r\n// 최적화 프로필 타입\r\nexport type OptimizationProfile = 'performance' | 'balanced' | 'memory-saving' | 'custom';\r\n\r\n// 메모리 사용량 레벨 열거형\r\nexport enum MemoryUsageLevel {\r\n  LOW = 'low',\r\n  MEDIUM = 'medium',\r\n  HIGH = 'high',\r\n  CRITICAL = 'critical'\r\n}\r\n\r\n// 처리 모드 타입\r\nexport type ProcessingMode = 'normal' | 'cpu-intensive' | 'gpu-intensive' | 'memory-saving' | 'auto';\r\n\r\n// GPU 작업 타입 열거형\r\nexport enum GpuTaskType {\r\n  MATRIX_MULTIPLICATION = 'matrix',\r\n  TEXT_ANALYSIS = 'text',\r\n  PATTERN_DETECTION = 'pattern',\r\n  IMAGE_PROCESSING = 'image',\r\n  DATA_AGGREGATION = 'data',\r\n  TYPING_STATISTICS = 'typing',\r\n  CUSTOM = 'custom'\r\n}\r\n\r\n// 시스템 상태 인터페이스\r\nexport interface SystemStatus {\r\n  memory: {\r\n    percentUsed: number;\r\n    level: MemoryUsageLevel;\r\n    heapUsedMB: number;\r\n    rssMB: number;\r\n  };\r\n  processing: {\r\n    mode: ProcessingMode;\r\n    gpuEnabled: boolean;\r\n  };\r\n  optimizations: {\r\n    count: number;\r\n    lastTimestamp: number;\r\n    freedMemoryMB: number;\r\n  };\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * 공통 타입 정의\r\n */\r\n\r\n// 메모리 정보 인터페이스\r\nexport interface MemoryInfo {\r\n  timestamp: number;\r\n  heap_used: number;\r\n  heap_total: number;\r\n  heap_limit?: number;\r\n  rss?: number;\r\n  external?: number;\r\n  array_buffers?: number;\r\n  heap_used_mb: number;\r\n  rss_mb?: number;\r\n  percent_used: number;\r\n\r\n  // 선택적 별칭 추가 - 코드 호환성을 위함\r\n  heapUsed?: number;\r\n  heapTotal?: number;\r\n  heapLimit?: number;\r\n  heapUsedMB?: number;\r\n  percentUsed?: number;\r\n  rssMB?: number;\r\n}\r\n\r\n// 최적화 결과 인터페이스\r\nexport interface OptimizationResult {\r\n  success: boolean;\r\n  optimization_level: number;\r\n  memory_before?: MemoryInfo;\r\n  memory_after?: MemoryInfo;\r\n  freed_memory?: number;\r\n  freed_mb?: number;\r\n  duration?: number;\r\n  timestamp: number;\r\n  error?: string;\r\n\r\n  // 선택적 별칭 추가 - 코드 호환성을 위함\r\n  freedMemory?: number;\r\n  freedMB?: number;\r\n}\r\n\r\n// 가비지 컬렉션 결과 인터페이스\r\nexport interface GCResult {\r\n  success: boolean;\r\n  timestamp: number;\r\n  freedMemory?: number;\r\n  freedMB?: number;\r\n  error?: string;\r\n}\r\n\r\n// GPU 정보 인터페이스\r\nexport interface GpuInfo {\r\n  name: string;\r\n  vendor: string;\r\n  driver_info: string;\r\n  device_type: string;\r\n  backend: string;\r\n  available: boolean;\r\n  acceleration_enabled: boolean;\r\n  settings_enabled: boolean;\r\n  processing_mode: string;\r\n  timestamp: number;\r\n}\r\n\r\n// GPU 계산 결과 인터페이스\r\nexport interface GpuComputationResult {\r\n  success: boolean;\r\n  task_type: string;\r\n  duration_ms: number;\r\n  result: any;\r\n  error?: string;\r\n  timestamp: number;\r\n}\r\n\r\n// 태스크 결과 인터페이스\r\nexport interface TaskResult {\r\n  task_id: string;\r\n  task_type: string;\r\n  duration_ms: number;\r\n  result: any;\r\n  error?: string;\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * 머신 정보 인터페이스\r\n */\r\nexport interface MachineInfo {\r\n  /** CPU 정보 */\r\n  cpuInfo: {\r\n    /** CPU 코어 수 */\r\n    cores: number;\r\n    /** 모델 이름 */\r\n    model: string;\r\n    /** 아키텍처 */\r\n    arch: string;\r\n  };\r\n  \r\n  /** 메모리 정보 */\r\n  memoryInfo: {\r\n    /** 총 메모리 (MB) */\r\n    totalMemoryMB: number;\r\n    /** 여유 메모리 (MB) */\r\n    freeMemoryMB: number;\r\n  };\r\n  \r\n  /** 운영체제 정보 */\r\n  osInfo: {\r\n    /** 운영체제 유형 */\r\n    type: string;\r\n    /** 운영체제 플랫폼 */\r\n    platform: string;\r\n    /** 운영체제 버전 */\r\n    release: string;\r\n  };\r\n}\r\n\r\n/**\r\n * 성능 정보 인터페이스\r\n */\r\nexport interface PerformanceInfo {\r\n  /** 앱 실행 시간 (초) */\r\n  uptime: number;\r\n  \r\n  /** 평균 CPU 사용률 (%) */\r\n  avgCpuUsage: number;\r\n  \r\n  /** 현재 메모리 사용량 (MB) */\r\n  memoryUsageMB: number;\r\n  \r\n  /** 최대 메모리 사용량 (MB) */\r\n  peakMemoryUsageMB: number;\r\n  \r\n  /** 마지막 최적화 시간 */\r\n  lastOptimizationTime?: number;\r\n  \r\n  /** 최적화 횟수 */\r\n  optimizationCount: number;\r\n}\r\n\r\n/**\r\n * Electron Window Mode\r\n */\r\nexport type WindowMode = 'windowed' | 'fullscreen' | 'fullscreen-auto-hide';\r\n\r\n// 메모리 이벤트 인터페이스\r\nexport interface MemoryEvent {\r\n  type: MemoryEventType;\r\n  message: string;\r\n  timestamp: number;\r\n  data?: any;\r\n}\r\n\r\n// 메모리 최적화 옵션 인터페이스\r\nexport interface MemoryOptimizerOptions {\r\n  threshold?: number;\r\n  checkInterval?: number;\r\n  showWarnings?: boolean;\r\n  autoOptimize?: boolean;\r\n  debug?: boolean;\r\n  preferNative?: boolean;\r\n}\r\n\r\n// 메모리 최적화 유틸리티 인터페이스\r\nexport interface MemoryOptimizerUtility {\r\n  getMemoryInfo: () => MemoryInfo | null;\r\n  optimizeMemory: (emergency?: boolean) => Promise<GCResult>;\r\n}\r\n\r\n// 중앙화된 타입 내보내기\r\nexport type {\r\n  MemoryInfo,\r\n  GpuInfo,\r\n  NativeModuleInfo,\r\n  NativeModuleConfig\r\n};\r\n\r\n// 메모리 최적화 레벨 정의 (memory-optimizer.ts와 memory/optimization-utils.ts 간 공유)\r\nexport enum OptimizationLevel {\r\n  LIGHT = 'light',\r\n  MEDIUM = 'medium',\r\n  AGGRESSIVE = 'aggressive',\r\n  EMERGENCY = 'emergency'\r\n}\r\n\r\n// 메모리 최적화 결과 타입\r\nexport interface OptimizationResult {\r\n  level: OptimizationLevel;\r\n  memoryFreed: number;\r\n  timestamp: number;\r\n  success: boolean;\r\n  error?: string;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\types\\memory-types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\types\\native-module.d.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'NONE' is defined but never used.","line":33,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":33,"endColumn":7},{"ruleId":"no-unused-vars","severity":2,"message":"'LOW' is defined but never used.","line":34,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":34,"endColumn":6},{"ruleId":"no-unused-vars","severity":2,"message":"'MEDIUM' is defined but never used.","line":35,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'HIGH' is defined but never used.","line":36,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":7},{"ruleId":"no-unused-vars","severity":2,"message":"'CRITICAL' is defined but never used.","line":37,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":37,"endColumn":11},{"ruleId":"no-unused-vars","severity":2,"message":"'NORMAL' is defined but never used.","line":78,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":78,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'LOW' is defined but never used.","line":79,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":79,"endColumn":6},{"ruleId":"no-unused-vars","severity":2,"message":"'MEDIUM' is defined but never used.","line":80,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":80,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'HIGH' is defined but never used.","line":81,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":81,"endColumn":7},{"ruleId":"no-unused-vars","severity":2,"message":"'CRITICAL' is defined but never used.","line":82,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":82,"endColumn":11},{"ruleId":"no-unused-vars","severity":2,"message":"'TEXT_ANALYSIS' is defined but never used.","line":116,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":116,"endColumn":16},{"ruleId":"no-unused-vars","severity":2,"message":"'PATTERN_DETECTION' is defined but never used.","line":117,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":117,"endColumn":20},{"ruleId":"no-unused-vars","severity":2,"message":"'IMAGE_PROCESSING' is defined but never used.","line":118,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":118,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'DATA_AGGREGATION' is defined but never used.","line":119,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":119,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'TYPING_STATISTICS' is defined but never used.","line":120,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":120,"endColumn":20},{"ruleId":"no-unused-vars","severity":2,"message":"'AUTO' is defined but never used.","line":146,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":146,"endColumn":7},{"ruleId":"no-unused-vars","severity":2,"message":"'NORMAL' is defined but never used.","line":147,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":147,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'CPU_INTENSIVE' is defined but never used.","line":148,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":148,"endColumn":16},{"ruleId":"no-unused-vars","severity":2,"message":"'GPU_INTENSIVE' is defined but never used.","line":149,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":149,"endColumn":16},{"ruleId":"no-unused-vars","severity":2,"message":"'LOW_POWER' is defined but never used.","line":150,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":150,"endColumn":12}],"suppressedMessages":[],"errorCount":20,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 네이티브 모듈 타입 정의\r\n * \r\n * Rust로 작성된 네이티브 모듈과의 인터페이스를 정의합니다.\r\n */\r\n\r\n/**\r\n * 메모리 정보 인터페이스\r\n */\r\nexport interface MemoryInfo {\r\n  heapUsed: number;\r\n  heapTotal: number;\r\n  rss: number;\r\n  external?: number;\r\n  heapUsedMB: number;\r\n  rssMB: number;\r\n  percentUsed: number;\r\n  timestamp: number;\r\n  \r\n  // 하위 호환성을 위한 snake_case 버전\r\n  heap_used: number;\r\n  heap_total: number;\r\n  heap_used_mb: number;\r\n  rss_mb: number;\r\n  percent_used: number;\r\n  heap_limit?: number;\r\n}\r\n\r\n/**\r\n * 최적화 레벨 열거형\r\n */\r\nexport enum OptimizationLevel {\r\n  NONE = 0,\r\n  LOW = 1,\r\n  MEDIUM = 2,\r\n  HIGH = 3,\r\n  CRITICAL = 4\r\n}\r\n\r\n/**\r\n * 가비지 컬렉션 결과 인터페이스\r\n */\r\nexport interface GCResult {\r\n  success: boolean;\r\n  timestamp: number;\r\n  freedMemory?: number;\r\n  freedMB?: number;\r\n  duration?: number;\r\n  error?: string;\r\n  \r\n  // 하위 호환성을 위한 snake_case 버전\r\n  freed_memory?: number;\r\n  freed_mb?: number;\r\n}\r\n\r\n/**\r\n * 메모리 최적화 결과 인터페이스\r\n */\r\nexport interface OptimizationResult {\r\n  success: boolean;\r\n  optimizationLevel?: OptimizationLevel | string | number;\r\n  timestamp: number;\r\n  freedMemory?: number;\r\n  freedMB?: number;\r\n  duration?: number;\r\n  error?: string;\r\n  \r\n  // 하위 호환성을 위한 snake_case 버전\r\n  optimization_level?: string | number;\r\n  freed_memory?: number;\r\n  freed_mb?: number;\r\n}\r\n\r\n/**\r\n * 메모리 사용 단계 열거형\r\n */\r\nexport enum MemoryUsageLevel {\r\n  NORMAL = 0,\r\n  LOW = 1,\r\n  MEDIUM = 2,\r\n  HIGH = 3,\r\n  CRITICAL = 4\r\n}\r\n\r\n/**\r\n * 메모리 사용량 정보 인터페이스\r\n */\r\nexport interface MemoryUsageInfo {\r\n  heapUsed: number;\r\n  heapTotal: number;\r\n  rss: number;\r\n  heapUsedMB: number;\r\n  heapTotalMB: number;\r\n  rssMB: number;\r\n  percentUsed: number;\r\n  timestamp: number;\r\n  level?: MemoryUsageLevel;\r\n}\r\n\r\n/**\r\n * 메모리 설정 인터페이스\r\n */\r\nexport interface MemorySettings {\r\n  autoOptimize: boolean;\r\n  optimizationThreshold: number;\r\n  lowMemoryMode: boolean;\r\n  gcInterval: number;\r\n  processingMode?: string;\r\n  maxMemoryThreshold?: number;\r\n}\r\n\r\n/**\r\n * GPU 작업 타입 열거형\r\n */\r\nexport enum GpuTaskType {\r\n  TEXT_ANALYSIS = 'TextAnalysis',\r\n  PATTERN_DETECTION = 'PatternDetection',\r\n  IMAGE_PROCESSING = 'ImageProcessing',\r\n  DATA_AGGREGATION = 'DataAggregation',\r\n  TYPING_STATISTICS = 'TypingStatistics'\r\n}\r\n\r\n/**\r\n * GPU 정보 인터페이스\r\n */\r\nexport interface GpuInfo {\r\n  available: boolean;\r\n  accelerationEnabled: boolean;\r\n  driverVersion: string;\r\n  deviceName: string;\r\n  deviceType: string;\r\n  vendor: string;\r\n  timestamp: number;\r\n  \r\n  // 호환성을 위한 snake_case 버전\r\n  acceleration_enabled?: boolean;\r\n  driver_version?: string;\r\n  device_name?: string;\r\n  device_type?: string;\r\n}\r\n\r\n/**\r\n * 처리 모드 열거형\r\n */\r\nexport enum ProcessingMode {\r\n  AUTO = 'auto',\r\n  NORMAL = 'normal',\r\n  CPU_INTENSIVE = 'cpu-intensive',\r\n  GPU_INTENSIVE = 'gpu-intensive',\r\n  LOW_POWER = 'low-power'\r\n}\r\n\r\n/**\r\n * 메모리 최적화 결과 인터페이스\r\n */\r\nexport interface MemoryOptimizationResult {\r\n  success: boolean;\r\n  optimizationLevel: number;\r\n  memoryBefore?: MemoryInfo;\r\n  memoryAfter?: MemoryInfo;\r\n  freedMemory?: number;\r\n  freedMB?: number;\r\n  duration?: number;\r\n  error?: string;\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * 가비지 컬렉션 결과 인터페이스\r\n */\r\nexport interface GarbageCollectionResult {\r\n  success: boolean;\r\n  freedMemory?: number;\r\n  freedMB?: number;\r\n  duration?: number;\r\n  error?: string;\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * GPU 기능 인터페이스\r\n */\r\nexport interface GpuCapabilities {\r\n  max_buffer_size: number;\r\n  max_compute_workgroups: [number, number, number];\r\n  max_invocations: number;\r\n  supports_timestamp_query: boolean;\r\n  supports_pipeline_statistics_query: boolean;\r\n  compute_supported: boolean;\r\n  shading_supported: boolean;\r\n}\r\n\r\n/**\r\n * GPU 계산 결과 인터페이스\r\n */\r\nexport interface GpuComputationResult<T = any> {\r\n  success: boolean;\r\n  task_type: string;\r\n  duration_ms: number;\r\n  result: T;\r\n  error?: string;\r\n  timestamp: number;\r\n  gpu_info?: {\r\n    name: string;\r\n    type: string;\r\n    backend: string;\r\n  };\r\n  used_gpu_acceleration: boolean;\r\n}\r\n\r\n/**\r\n * 네이티브 모듈 정보 인터페이스\r\n */\r\nexport interface NativeModuleInfo {\r\n  name: string;\r\n  version: string;\r\n  description: string;\r\n  features: {\r\n    memory_optimization: boolean;\r\n    gpu_acceleration: boolean;\r\n    worker_threads: boolean;\r\n  };\r\n  system: {\r\n    os: string;\r\n    arch: string;\r\n    cpu_cores: number;\r\n    node_version: string;\r\n  };\r\n}\r\n\r\n/**\r\n * 네이티브 모듈 상태 인터페이스\r\n */\r\nexport interface NativeModuleStatus {\r\n  available: boolean;\r\n  fallbackMode: boolean;\r\n  version?: string;\r\n  info?: NativeModuleInfo;\r\n  features: {\r\n    memory: boolean;\r\n    gpu: boolean;\r\n    worker: boolean;\r\n  };\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * 태스크 결과 인터페이스\r\n */\r\nexport interface TaskResult {\r\n  task_id: string;\r\n  task_type: string;\r\n  duration_ms: number;\r\n  result: any;\r\n  error?: string;\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * GPU 가속 응답 인터페이스\r\n */\r\nexport interface GpuAccelerationResponse {\r\n  success: boolean;\r\n  enabled: boolean;\r\n  result: boolean;\r\n  error?: string;\r\n  timestamp: number;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\kaziz\\Desktop\\typing-stats-app\\src\\types\\native-module.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'Normal' is defined but never used.","line":7,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'Low' is defined but never used.","line":8,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":6},{"ruleId":"no-unused-vars","severity":2,"message":"'Medium' is defined but never used.","line":9,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'High' is defined but never used.","line":10,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":7},{"ruleId":"no-unused-vars","severity":2,"message":"'Critical' is defined but never used.","line":11,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":11},{"ruleId":"no-unused-vars","severity":2,"message":"'Unknown' is defined but never used.","line":63,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":63,"endColumn":10},{"ruleId":"no-unused-vars","severity":2,"message":"'Integrated' is defined but never used.","line":64,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":64,"endColumn":13},{"ruleId":"no-unused-vars","severity":2,"message":"'Discrete' is defined but never used.","line":65,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":65,"endColumn":11},{"ruleId":"no-unused-vars","severity":2,"message":"'Software' is defined but never used.","line":66,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":66,"endColumn":11},{"ruleId":"no-unused-vars","severity":2,"message":"'MatrixMultiplication' is defined but never used.","line":118,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":118,"endColumn":23},{"ruleId":"no-unused-vars","severity":2,"message":"'TextAnalysis' is defined but never used.","line":119,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":119,"endColumn":15},{"ruleId":"no-unused-vars","severity":2,"message":"'ImageProcessing' is defined but never used.","line":120,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":120,"endColumn":18},{"ruleId":"no-unused-vars","severity":2,"message":"'DataAggregation' is defined but never used.","line":121,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":121,"endColumn":18},{"ruleId":"no-unused-vars","severity":2,"message":"'PatternDetection' is defined but never used.","line":122,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":122,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'TypingStatistics' is defined but never used.","line":123,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":123,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'Custom' is defined but never used.","line":124,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":124,"endColumn":9}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 네이티브 모듈 타입 정의\r\n */\r\n\r\n// 네이티브 모듈 최적화 레벨\r\nexport enum OptimizationLevel {\r\n  Normal = 0,\r\n  Low = 1,\r\n  Medium = 2,\r\n  High = 3,\r\n  Critical = 4\r\n}\r\n\r\n// GPU 장치 정보 인터페이스\r\nexport interface GpuDeviceInfo {\r\n  name: string;\r\n  vendor: string;\r\n  driver_info: string;\r\n  device_type: string;\r\n  backend: string;\r\n  timestamp: number;\r\n}\r\n\r\n// GPU 정보 인터페이스\r\nexport interface GpuInfo {\r\n  name: string;\r\n  vendor: string;\r\n  driver_info: string;\r\n  device_type: string;\r\n  backend: string;\r\n  available: boolean;\r\n  timestamp: number;\r\n}\r\n\r\n// GPU 작업 결과 인터페이스\r\nexport interface GpuTaskResult {\r\n  task_id: string;\r\n  task_type: string;\r\n  duration_ms: number;\r\n  result: any;\r\n  timestamp: number;\r\n}\r\n\r\n// 작업 결과 인터페이스\r\nexport interface TaskResult {\r\n  task_id: string;\r\n  task_type: string;\r\n  duration_ms: number;\r\n  result: any;\r\n  timestamp: number;\r\n}\r\n\r\n// GPU 계산 결과 인터페이스\r\nexport interface GpuComputationResult {\r\n  computation_type: string;\r\n  duration_ms: number;\r\n  result: any;\r\n  timestamp: number;\r\n}\r\n\r\n// 네이티브 GPU 타입 (Rust enum과 일치)\r\nexport enum GPUType {\r\n  Unknown = 0,\r\n  Integrated = 1,\r\n  Discrete = 2,\r\n  Software = 3\r\n}\r\n\r\n// 네이티브 GPU 정보 인터페이스 (Rust struct와 일치)\r\nexport interface GPUInfo {\r\n  name: string;\r\n  vendor: string;\r\n  device_type: GPUType;\r\n  available: boolean;\r\n  acceleration_enabled: boolean;\r\n  renderer?: string;\r\n  driver_info?: string;\r\n  backend?: string;\r\n  timestamp: number;\r\n}\r\n\r\n// 워커 풀 상태 인터페이스\r\nexport interface WorkerPoolStats {\r\n  thread_count: number;\r\n  active_tasks: number;\r\n  completed_tasks: number;\r\n  active_workers: number;\r\n  idle_workers: number;\r\n  pending_tasks: number;\r\n  failed_tasks: number;\r\n  total_tasks: number;\r\n  uptime_ms: number;\r\n  timestamp: number;\r\n}\r\n\r\n// 성능 지표 인터페이스\r\nexport interface PerformanceMetrics {\r\n  calls: number;\r\n  errors: number;\r\n  avgExecutionTime: number;\r\n  lastGcTime: number;\r\n  totalExecutionTime: number;\r\n  timestamp: number;\r\n}\r\n\r\n// 네이티브 모듈 상태 인터페이스\r\nexport interface NativeModuleStatus {\r\n  available: boolean;\r\n  fallbackMode: boolean;\r\n  version: string | null;\r\n  info: any;\r\n  timestamp: number;\r\n  error?: string;\r\n}\r\n\r\n// GPU 작업 유형 열거형\r\nexport enum GpuTaskType {\r\n  MatrixMultiplication = 'matrix',\r\n  TextAnalysis = 'text',\r\n  ImageProcessing = 'image',\r\n  DataAggregation = 'data',\r\n  PatternDetection = 'pattern',\r\n  TypingStatistics = 'typing',\r\n  Custom = 'custom'\r\n}\r\n\r\n// GPU 가속 상태 인터페이스\r\nexport interface GpuAccelerationStatus {\r\n  available: boolean;\r\n  enabled: boolean;\r\n  info?: GpuInfo;\r\n}\r\n\r\n// 메모리 정보 인터페이스\r\nexport interface MemoryInfo {\r\n  heap_used: number;\r\n  heap_total: number;\r\n  heap_limit: number;\r\n  heap_used_mb: number;\r\n  rss: number;\r\n  rss_mb: number;\r\n  percent_used: number;\r\n  external: number;\r\n  timestamp: number;\r\n}\r\n\r\n// 최적화 결과 인터페이스\r\nexport interface OptimizationResult {\r\n  success: boolean;\r\n  optimization_level: number;\r\n  freed_memory?: number;\r\n  freed_mb?: number;\r\n  memory_before?: MemoryInfo;\r\n  memory_after?: MemoryInfo;\r\n  duration?: number;\r\n  timestamp: number;\r\n  error?: string;\r\n}\r\n\r\n// 가비지 컬렉션 결과 인터페이스\r\nexport interface GCResult {\r\n  success: boolean;\r\n  freed_memory: number;\r\n  freed_mb?: number;\r\n  timestamp: number;\r\n  error?: string;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]
