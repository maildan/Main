{"version":3,"file":"static/chunks/931-1056fdf47f81404e.js","mappings":"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","sources":["webpack://_N_E/./src/app/utils/memory/gc-utils.ts","webpack://_N_E/./src/app/utils/native-memory-bridge.ts","webpack://_N_E/./src/types/index.ts","webpack://_N_E/./src/app/utils/memory/memory-info.ts","webpack://_N_E/./src/types/native-module.ts","webpack://_N_E/./src/app/utils/nativeModuleClient.ts"],"sourcesContent":["/**\n * 가비지 컬렉션 유틸리티\n *\n * 메모리 정리 관련 기능을 제공합니다.\n */\n\nimport { GCResult } from '@/types';\nimport { requestNativeGarbageCollection } from '../native-memory-bridge';\n\n// 변수 및 상수 선언 추가\nlet lastGCTime = 0;\nconst MIN_GC_INTERVAL = 3000; // 3초\n\n/**\n * 브라우저 환경인지 확인하는 함수\n */\nexport const isBrowser = typeof window !== 'undefined';\n\n/**\n * 가비지 컬렉션 요청\n * 네이티브 모듈을 통해 GC를 수행합니다.\n * @returns GC 결과\n */\nexport async function requestGC(_emergency: boolean = false): Promise<GCResult | null> {\n  try {\n    return await requestNativeGarbageCollection();\n  } catch (error) {\n    console.error('가비지 컬렉션 요청 오류:', error);\n    // GCResult 인터페이스에 맞게 필수 필드 추가\n    return {\n      success: false,\n      timestamp: Date.now(),\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\n      freedMemory: 0,\n      freedMB: 0,\n    };\n  }\n}\n\n/**\n * 수동 메모리 정리 수행\n * JS 환경에서 가능한 메모리 정리 작업을 수행합니다.\n */\nexport async function cleanupMemory(): Promise<boolean> {\n  try {\n    // 브라우저 환경에서만 실행\n    if (!isBrowser) return false;\n\n    // 가능한 경우 global.gc 호출\n    if (typeof window.gc === 'function') {\n      window.gc();\n    }\n\n    // 미사용 이미지 캐시 정리\n    if (window.__imageResizeCache) {\n      window.__imageResizeCache.clear();\n    }\n\n    // 오브젝트 URL 정리\n    if (window.__objectUrls) {\n      for (const [_key, url] of window.__objectUrls) {\n        URL.revokeObjectURL(url);\n      }\n      window.__objectUrls.clear();\n    }\n\n    return true;\n  } catch (error) {\n    console.error('메모리 정리 오류:', error);\n    return false;\n  }\n}\n\n/**\n * 주기적인 메모리 정리 설정\n * @param interval 실행 간격(ms)\n * @returns 정리 함수\n */\nexport function setupPeriodicGC(interval: number = 60000): () => void {\n  const timerId = setInterval(async () => {\n    await requestGC(false);\n  }, interval);\n\n  return () => {\n    clearInterval(timerId);\n  };\n}\n\n/**\n * 가비지 컬렉션 제안 함수\n *\n * 브라우저 환경에서 가비지 컬렉션을 제안합니다.\n * window.gc가 있는 환경(크롬 --js-flags=\"--expose-gc\")에서만 작동합니다.\n */\nexport function suggestGarbageCollection(): void {\n  if (isBrowser) {\n    if (window.gc) {\n      window.gc();\n    } else {\n      // GC를 직접 호출할 수 없는 경우 간접적으로 메모리 압박을 가함\n      const now = Date.now();\n\n      // 너무 자주 호출되지 않도록 조절\n      if (now - lastGCTime < MIN_GC_INTERVAL) {\n        return;\n      }\n\n      lastGCTime = now;\n\n      // 메모리 할당 후 해제하여 GC 유도\n      try {\n        const arr = new Array(10000).fill({});\n        arr.length = 0;\n      } catch (e) {\n        console.warn('GC 간접 호출 중 오류:', e);\n      }\n    }\n  }\n}\n\n/**\n * 브라우저 캐시 정리\n */\nexport async function clearBrowserCaches(): Promise<boolean> {\n  try {\n    if (!isBrowser) return false;\n\n    // 사용 가능한 캐시 API가 있으면 정리\n    if ('caches' in window) {\n      const cacheNames = await window.caches.keys();\n      await Promise.all(cacheNames.map(cacheName => window.caches.delete(cacheName)));\n    }\n\n    return true;\n  } catch (error) {\n    console.error('브라우저 캐시 정리 오류:', error);\n    return false;\n  }\n}\n\n/**\n * 브라우저 스토리지 정리\n */\nexport function clearStorageCaches(): boolean {\n  try {\n    if (!isBrowser) return false;\n\n    // 세션 스토리지는 완전히 정리\n    if (window.sessionStorage) {\n      window.sessionStorage.clear();\n    }\n\n    // 로컬 스토리지는 임시 데이터만 정리\n    if (window.localStorage) {\n      const keysToDelete: string[] = [];\n\n      for (let i = 0; i < window.localStorage.length; i++) {\n        const key = window.localStorage.key(i);\n        // null 체크 추가\n        if (key && (key.startsWith('temp_') || key.startsWith('cache_'))) {\n          keysToDelete.push(key);\n        }\n      }\n\n      keysToDelete.forEach(key => window.localStorage.removeItem(key));\n    }\n\n    return true;\n  } catch (error) {\n    console.error('스토리지 캐시 정리 오류:', error);\n    return false;\n  }\n}\n\n/**\n * 캐시 정리 유틸리티\n */\nexport function cleanCache(cacheType: string): boolean {\n  try {\n    if (!isBrowser) return false;\n\n    switch (cacheType) {\n      case 'local':\n        return cleanLocalStorageCache();\n      case 'session':\n        sessionStorage.clear();\n        return true;\n      case 'browser':\n        clearBrowserCaches();\n        return true;\n      case 'memory':\n        return cleanMemoryCache();\n      case 'all':\n        cleanLocalStorageCache();\n        sessionStorage.clear();\n        clearBrowserCaches();\n        cleanMemoryCache();\n        return true;\n      default:\n        return false;\n    }\n  } catch (error) {\n    console.error(`캐시 정리 오류 (${cacheType}):`, error);\n    return false;\n  }\n}\n\n/**\n * 로컬 스토리지 캐시 정리\n */\nfunction cleanLocalStorageCache(): boolean {\n  try {\n    // 임시 데이터만 정리\n    const keysToRemove: string[] = [];\n\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key && (key.startsWith('cache_') || key.startsWith('temp_'))) {\n        keysToRemove.push(key);\n      }\n    }\n\n    keysToRemove.forEach(key => localStorage.removeItem(key));\n    return true;\n  } catch (error) {\n    console.error('로컬 스토리지 캐시 정리 오류:', error);\n    return false;\n  }\n}\n\n/**\n * 메모리 캐시 정리\n */\nfunction cleanMemoryCache(): boolean {\n  try {\n    // 이미지 캐시 정리\n    if (window.__imageResizeCache) {\n      window.__imageResizeCache.clear();\n    }\n\n    // 오브젝트 URL 정리\n    if (window.__objectUrls) {\n      for (const [_key, url] of window.__objectUrls) {\n        URL.revokeObjectURL(url);\n      }\n      window.__objectUrls.clear();\n    }\n\n    return true;\n  } catch (error) {\n    console.error('메모리 캐시 정리 오류:', error);\n    return false;\n  }\n}\n\n/**\n * 비활성 캐시 정리\n */\nexport function cleanInactiveCaches(): boolean {\n  try {\n    if (!isBrowser) return false;\n\n    // 접근 시간 추적을 위한 메타데이터 키\n    const CACHE_ACCESS_KEY = 'cache_last_access';\n\n    // 현재 시간\n    const now = Date.now();\n\n    // 마지막 접근 시간 정보 로드\n    let accessInfo: Record<string, number> = {};\n    try {\n      const accessInfoJson = localStorage.getItem(CACHE_ACCESS_KEY);\n      if (accessInfoJson) {\n        accessInfo = JSON.parse(accessInfoJson);\n      }\n    } catch {\n      // 파싱 오류 무시, 빈 객체 사용\n    }\n\n    // 캐시 항목 스캔\n    const keysToCheck: string[] = [];\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key && key.startsWith('cache_')) {\n        keysToCheck.push(key);\n      }\n    }\n\n    // 일정 시간 접근되지 않은 캐시 정리 (7일 이상)\n    const expiryTime = 7 * 24 * 60 * 60 * 1000; // 7일\n    const expiredKeys = keysToCheck.filter(key => {\n      const lastAccess = accessInfo[key] || 0;\n      return now - lastAccess > expiryTime;\n    });\n\n    // 만료된 키 제거\n    expiredKeys.forEach(key => {\n      localStorage.removeItem(key);\n      delete accessInfo[key];\n    });\n\n    // 접근 정보 업데이트\n    localStorage.setItem(CACHE_ACCESS_KEY, JSON.stringify(accessInfo));\n\n    return true;\n  } catch (error) {\n    console.error('비활성 캐시 정리 오류:', error);\n    return false;\n  }\n}\n\n/**\n * 모든 캐시 정리\n */\nexport function cleanAllCaches(): boolean {\n  try {\n    if (!isBrowser) return false;\n\n    // 세션 스토리지 정리\n    sessionStorage.clear();\n\n    // 로컬 스토리지에서 캐시 키 찾기\n    const cacheKeys: string[] = [];\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key && (key.startsWith('cache_') || key.startsWith('temp_') || key.includes('cache'))) {\n        cacheKeys.push(key);\n      }\n    }\n\n    // 캐시 키 제거\n    cacheKeys.forEach(key => localStorage.removeItem(key));\n\n    // 메모리 내 캐시 정리\n    cleanMemoryCache();\n\n    // 브라우저 캐시 정리\n    clearBrowserCaches();\n\n    return true;\n  } catch (error) {\n    console.error('모든 캐시 정리 오류:', error);\n    return false;\n  }\n}\n\n// 윈도우 메모리 옵티마이저 초기화 부분 수정\nif (typeof window !== 'undefined') {\n  // 타입 안전한 방식으로 속성 초기화\n  if (!window.__memoryOptimizer) {\n    (window as any).__memoryOptimizer = {\n      suggestGarbageCollection: () => {\n        // 기존 구현\n      },\n      requestGC: async (emergency?: boolean) => {\n        // 기존 구현\n        return {};\n      },\n      clearBrowserCaches: async () => {\n        // 기존 구현\n        return true;\n      },\n      clearStorageCaches: () => {\n        // 기존 구현\n        return true;\n      },\n      checkMemoryUsage: () => {\n        // 기존 구현\n        return null;\n      },\n      forceGC: () => {\n        // 기존 구현\n        return true;\n      },\n      // cleanAllCaches 메서드 추가\n      cleanAllCaches: () => {\n        // 캐시 정리 로직 구현\n        return true;\n      },\n    };\n  }\n\n  // 옵셔널 체이닝 사용 + cleanAllCaches 대신 clearStorageCaches 사용\n  window.__memoryOptimizer?.clearStorageCaches?.();\n  window.__memoryOptimizer?.suggestGarbageCollection?.();\n  window.__memoryOptimizer?.requestGC?.();\n}\n\n// 매개변수 사용되지 않음 경고 수정 (이름 앞에 _ 추가)\nasync function defaultRequestGC(_emergency?: boolean): Promise<any> {\n  return Promise.resolve();\n}\n","/**\n * 네이티브 모듈과의 통신 브릿지\n */\n\nimport { MemoryInfo, OptimizationResult, OptimizationLevel, GCResult } from '@/types';\nimport {\n  optimizeMemory,\n  forceGarbageCollection,\n  getMemoryInfo as fetchMemoryInfo,\n} from './nativeModuleClient';\n\n/**\n * 최적화 레벨 값을 안전하게 처리하는 함수\n * 유효한 최적화 레벨 범위(0-4) 내의 값으로 변환\n */\nfunction safeOptimizationLevel(level: number): number {\n  // 숫자가 아니면 기본값 반환\n  if (typeof level !== 'number' || isNaN(level)) {\n    return OptimizationLevel.MEDIUM;\n  }\n\n  // 범위 제한 (0-4)\n  return Math.max(0, Math.min(4, Math.floor(level)));\n}\n\n/**\n * 네이티브 메모리 정보 요청\n */\nexport async function requestNativeMemoryInfo(): Promise<MemoryInfo | null> {\n  // 기본적인 브라우저 환경 체크\n  if (typeof window === 'undefined') {\n    return null;\n  }\n\n  try {\n    // 백엔드 API를 통해 메모리 정보 요청\n    const response = await fetch('/api/native/memory/info');\n    if (!response.ok) {\n      throw new Error(`API 요청 실패: ${response.status}`);\n    }\n\n    const data = await response.json();\n    return data.memoryInfo;\n  } catch (error) {\n    console.error('네이티브 메모리 정보 요청 오류:', error);\n    return null;\n  }\n}\n\n// 브리지 상태\nconst bridgeState = {\n  isInitialized: false,\n  isAvailable: false,\n  lastError: null as Error | null,\n  lastCheck: 0,\n  errorCount: 0,\n};\n\n/**\n * 에러 처리 래퍼 함수\n */\nasync function withErrorHandling<T>(\n  operation: () => Promise<T | null>,\n  fallback: () => Promise<T> | T | null,\n  operationName: string\n): Promise<T | null> {\n  try {\n    // 브리지가 초기화되지 않은 경우\n    if (!bridgeState.isInitialized) {\n      // 브리지 상태 확인\n      await checkBridgeAvailability();\n    }\n\n    if (!bridgeState.isAvailable) {\n      console.warn(`Native bridge not available for ${operationName}`);\n      return fallback();\n    }\n\n    // 작업 실행\n    return await operation();\n  } catch (error) {\n    // 오류 기록\n    bridgeState.errorCount++;\n    bridgeState.lastError = error instanceof Error ? error : new Error(String(error));\n\n    console.error(`Native bridge error in ${operationName}:`, error);\n\n    // 폴백 반환\n    return fallback();\n  }\n}\n\n/**\n * 브리지 가용성 확인\n */\nasync function checkBridgeAvailability(): Promise<boolean> {\n  try {\n    // 마지막 확인 후 10초 이내면 캐시된 값 반환\n    const now = Date.now();\n    if (now - bridgeState.lastCheck < 10000 && bridgeState.isInitialized) {\n      return bridgeState.isAvailable;\n    }\n\n    // 메모리 정보 가져오기 시도로 가용성 확인\n    const response = await fetchMemoryInfo();\n\n    bridgeState.isAvailable = !!response;\n    bridgeState.isInitialized = true;\n    bridgeState.lastCheck = now;\n\n    if (!response) {\n      bridgeState.lastError = new Error('Unknown error in native bridge');\n    } else {\n      bridgeState.lastError = null;\n    }\n\n    return bridgeState.isAvailable;\n  } catch (error) {\n    bridgeState.isAvailable = false;\n    bridgeState.isInitialized = true;\n    bridgeState.lastError = error instanceof Error ? error : new Error(String(error));\n    bridgeState.lastCheck = Date.now();\n    return false;\n  }\n}\n\n/**\n * 네이티브 가비지 컬렉션 요청\n */\nexport async function requestNativeGarbageCollection(): Promise<GCResult | null> {\n  return withErrorHandling(\n    async () => {\n      const response = await forceGarbageCollection();\n\n      if (!response) {\n        throw new Error('가비지 컬렉션을 수행할 수 없습니다');\n      }\n\n      return response;\n    },\n    () => ({\n      success: false,\n      timestamp: Date.now(),\n      freedMemory: 0,\n      freedMB: 0,\n      duration: 0,\n      error: bridgeState.lastError?.message || '가비지 컬렉션을 사용할 수 없습니다',\n    }),\n    '가비지 컬렉션'\n  );\n}\n\n/**\n * 네이티브 메모리 최적화 요청\n */\nexport async function requestNativeMemoryOptimization(\n  level: number,\n  emergency = false\n): Promise<OptimizationResult | null> {\n  // 올바른 레벨 값 확보\n  const safeLevel = safeOptimizationLevel(level);\n\n  return withErrorHandling(\n    async () => {\n      const response = await optimizeMemory(safeLevel);\n\n      if (!response) {\n        throw new Error('메모리 최적화를 수행할 수 없습니다');\n      }\n\n      return response;\n    },\n    () => ({\n      success: false,\n      optimizationLevel: safeLevel,\n      timestamp: Date.now(),\n      freedMemory: 0,\n      freedMB: 0,\n      error: bridgeState.lastError?.message || '메모리 최적화를 사용할 수 없습니다',\n    }),\n    '메모리 최적화'\n  );\n}\n\n/**\n * 네이티브 브리지 상태 확인\n */\nexport async function checkNativeBridgeStatus(): Promise<{\n  available: boolean;\n  initialized: boolean;\n  lastCheck: number;\n  errorCount: number;\n  lastError: string | null;\n}> {\n  await checkBridgeAvailability();\n\n  return {\n    available: bridgeState.isAvailable,\n    initialized: bridgeState.isInitialized,\n    lastCheck: bridgeState.lastCheck,\n    errorCount: bridgeState.errorCount,\n    lastError: bridgeState.lastError?.message || null,\n  };\n}\n\n/**\n * 브리지 상태 게터 함수들\n */\nexport const getNativeBridgeState = () => ({ ...bridgeState });\nexport const isNativeBridgeAvailable = () => bridgeState.isAvailable;\nexport const getBridgeErrorCount = () => bridgeState.errorCount;\nexport const getLastBridgeError = () => bridgeState.lastError;\n","/**\r\n * 애플리케이션에서 사용하는 공통 타입 정의\r\n */\r\n\r\n/**\r\n * 메모리 사용 단계 열거형\r\n */\r\nexport enum MemoryUsageLevel {\r\n  NORMAL = 0,\r\n  LOW = 1,\r\n  MEDIUM = 2,\r\n  HIGH = 3,\r\n  CRITICAL = 4,\r\n}\r\n\r\n// 네이티브 모듈 타입은 네임스페이스로 분리\r\nexport namespace NativeModule {\r\n  export interface MemoryInfo {\r\n    heap_used: number;\r\n    heap_total: number;\r\n    // ... 기타 속성\r\n  }\r\n\r\n  export interface GPUInfo {\r\n    name: string;\r\n    vendor: string;\r\n    // ... 기타 속성\r\n  }\r\n}\r\n\r\n/**\r\n * 최적화 레벨 enum - 충돌 방지를 위해 이름 변경\r\n */\r\nexport enum AppOptimizationLevel {\r\n  NONE = 0,\r\n  LOW = 1,\r\n  MEDIUM = 2,\r\n  HIGH = 3,\r\n  AGGRESSIVE = 4,\r\n}\r\n\r\n/**\r\n * 메모리 정보 인터페이스\r\n */\r\nexport interface MemoryInfo {\r\n  timestamp: number;\r\n  heap_used: number;\r\n  heap_total: number;\r\n  heap_limit: number;\r\n  rss: number;\r\n  external?: number;\r\n  array_buffers?: number;\r\n  heap_used_mb: number;\r\n  rss_mb: number;\r\n  percent_used: number;\r\n\r\n  // 선택적 별칭 추가 - 코드 호환성을 위함\r\n  heapUsed?: number;\r\n  heapTotal?: number;\r\n  heapLimit?: number;\r\n  heapUsedMB?: number;\r\n  percentUsed?: number;\r\n  rssMB?: number;\r\n}\r\n\r\n/**\r\n * 가비지 컬렉션 결과 인터페이스 (missing type 추가)\r\n */\r\nexport interface GCResult {\r\n  success: boolean;\r\n  timestamp: number;\r\n  freedMemory: number;\r\n  freedMB: number;\r\n  duration?: number;\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * 최적화 결과 인터페이스\r\n */\r\nexport interface OptimizationResult {\r\n  success: boolean;\r\n  optimizationLevel: OptimizationLevel | string | number;\r\n  timestamp: number;\r\n  freedMemory: number; // 모든 속성 일관되게 필수로 변경\r\n  freedMB?: number;\r\n  duration?: number;\r\n  error?: string;\r\n\r\n  // 하위 호환성을 위한 snake_case 버전\r\n  optimization_level?: string | number;\r\n  freed_memory?: number;\r\n  freed_mb?: number;\r\n}\r\n\r\n/**\r\n * 처리 모드 열거형\r\n */\r\nexport enum ProcessingMode {\r\n  AUTO = 'auto',\r\n  NORMAL = 'normal',\r\n  CPU_INTENSIVE = 'cpu-intensive',\r\n  GPU_INTENSIVE = 'gpu-intensive',\r\n  MEMORY_SAVING = 'memory-saving',\r\n}\r\n\r\n/**\r\n * 메모리 이벤트 타입 열거형 (missing type 추가)\r\n */\r\nexport enum MemoryEventType {\r\n  INFO = 'info',\r\n  WARNING = 'warning',\r\n  ERROR = 'error',\r\n  GC = 'gc',\r\n  OPTIMIZATION = 'optimization',\r\n  THRESHOLD = 'threshold',\r\n  STATE_CHANGE = 'state_change',\r\n}\r\n\r\n/**\r\n * 메모리 최적화 이벤트 인터페이스\r\n * level과 memoryFreed 속성 한정자 통일 (일관성)\r\n */\r\nexport interface MemoryOptimizationEvent {\r\n  timestamp: number;\r\n  level: OptimizationLevel | string | number; // 모두 필수 속성으로 통일\r\n  memoryFreed: number; // 모두 필수 속성으로 통일\r\n  message: string;\r\n}\r\n\r\n/**\r\n * 머신 정보 인터페이스\r\n */\r\nexport interface MachineInfo {\r\n  /** CPU 정보 */\r\n  cpuInfo: {\r\n    /** CPU 코어 수 */\r\n    cores: number;\r\n    /** 모델 이름 */\r\n    model: string;\r\n    /** 아키텍처 */\r\n    arch: string;\r\n  };\r\n\r\n  /** 메모리 정보 */\r\n  memoryInfo: {\r\n    /** 총 메모리 (MB) */\r\n    totalMemoryMB: number;\r\n    /** 여유 메모리 (MB) */\r\n    freeMemoryMB: number;\r\n  };\r\n\r\n  /** 운영체제 정보 */\r\n  osInfo: {\r\n    /** 운영체제 유형 */\r\n    type: string;\r\n    /** 운영체제 플랫폼 */\r\n    platform: string;\r\n    /** 운영체제 버전 */\r\n    release: string;\r\n  };\r\n}\r\n\r\n/**\r\n * 성능 정보 인터페이스\r\n */\r\nexport interface PerformanceInfo {\r\n  /** 앱 실행 시간 (초) */\r\n  uptime: number;\r\n\r\n  /** 평균 CPU 사용률 (%) */\r\n  avgCpuUsage: number;\r\n\r\n  /** 현재 메모리 사용량 (MB) */\r\n  memoryUsageMB: number;\r\n\r\n  /** 최대 메모리 사용량 (MB) */\r\n  peakMemoryUsageMB: number;\r\n\r\n  /** 마지막 최적화 시간 */\r\n  lastOptimizationTime?: number;\r\n\r\n  /** 최적화 횟수 */\r\n  optimizationCount: number;\r\n}\r\n\r\n/**\r\n * Electron Window Mode\r\n */\r\nexport type WindowMode = 'windowed' | 'fullscreen' | 'fullscreen-auto-hide';\r\n\r\n/**\r\n * 메모리 이벤트 인터페이스\r\n */\r\nexport interface MemoryEvent {\r\n  type: MemoryEventType;\r\n  message: string;\r\n  timestamp: number;\r\n  data?: any;\r\n}\r\n\r\n/**\r\n * 메모리 최적화 옵션 인터페이스\r\n */\r\nexport interface MemoryOptimizerOptions {\r\n  threshold?: number;\r\n  checkInterval?: number;\r\n  showWarnings?: boolean;\r\n  autoOptimize?: boolean;\r\n  debug?: boolean;\r\n  preferNative?: boolean;\r\n}\r\n\r\n/**\r\n * 메모리 최적화 유틸리티 인터페이스\r\n */\r\nexport interface MemoryOptimizerUtility {\r\n  getMemoryInfo: () => MemoryInfo | null;\r\n  optimizeMemory: (emergency?: boolean) => Promise<GCResult>;\r\n}\r\n\r\n/**\r\n * 메모리 최적화 레벨 정의\r\n */\r\nexport enum OptimizationLevel {\r\n  NONE = 0,\r\n  LOW = 1,\r\n  MEDIUM = 2,\r\n  HIGH = 3,\r\n  AGGRESSIVE = 4,\r\n  // 이전 코드와 호환되도록 별칭 추가\r\n  NORMAL = 0,\r\n  CRITICAL = 4,\r\n}\r\n\r\n/**\r\n * GPU 작업 타입 열거형 (missing type 추가)\r\n */\r\nexport enum GpuTaskType {\r\n  MATRIX_MULTIPLICATION = 0,\r\n  TEXT_ANALYSIS = 1,\r\n  PATTERN_DETECTION = 2,\r\n  IMAGE_PROCESSING = 3,\r\n  DATA_AGGREGATION = 4,\r\n  TYPING_STATISTICS = 5,\r\n  CUSTOM = 6,\r\n}\r\n\r\n/**\r\n * 시스템 상태 인터페이스 (missing type 추가)\r\n */\r\nexport interface SystemStatus {\r\n  memoryUsageLevel: MemoryUsageLevel;\r\n  cpuUsage: number;\r\n  memoryInfo: MemoryInfo;\r\n  processingMode: ProcessingMode;\r\n  timestamp: number;\r\n  optimizationCount: number;\r\n  lastOptimization?: number;\r\n}\r\n\r\n/**\r\n * GPU 정보 인터페이스 (missing type 추가)\r\n */\r\nexport interface GpuInfo {\r\n  name: string;\r\n  vendor: string;\r\n  driverVersion: string;\r\n  memoryMB?: number;\r\n  available: boolean;\r\n}\r\n\r\n/**\r\n * GPU 계산 결과 인터페이스 (missing type 추가)\r\n */\r\nexport interface GpuComputationResult {\r\n  success: boolean;\r\n  executionTime: number;\r\n  result?: any;\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * 작업 결과 인터페이스 (missing type 추가)\r\n */\r\nexport interface TaskResult {\r\n  success: boolean;\r\n  timestamp: number;\r\n  executionTime: number;\r\n  taskType: string;\r\n  error?: string;\r\n  data?: any;\r\n}\r\n\r\n/**\r\n * 메모리 설정 인터페이스 (missing type 추가)\r\n */\r\nexport interface MemorySettings {\r\n  preferNativeImplementation: boolean;\r\n  enableAutomaticFallback: boolean;\r\n  enableAutomaticOptimization: boolean;\r\n  optimizationThreshold: number;\r\n  optimizationInterval: number;\r\n  aggressiveGC: boolean;\r\n  enableLogging: boolean;\r\n  enablePerformanceMetrics: boolean;\r\n  useHardwareAcceleration: boolean;\r\n  useMemoryPool: boolean;\r\n  fallbackRetryDelay: number;\r\n  poolCleanupInterval: number;\r\n  processingMode: string;\r\n  componentSpecificSettings: Record<string, any>;\r\n}\r\n","/**\n * 메모리 정보 유틸리티\n *\n * 브라우저 및 시스템 메모리 정보를 제공합니다.\n */\nimport { MemoryInfo } from '@/types';\nimport { requestNativeMemoryInfo } from '../native-memory-bridge';\n\n// 브라우저 메모리 성능 API를 위한 타입 확장\ninterface PerformanceMemory {\n  usedJSHeapSize: number;\n  totalJSHeapSize: number;\n  jsHeapSizeLimit: number;\n}\n\n/**\n * 현재 메모리 사용량 가져오기\n */\nexport async function getMemoryUsage(): Promise<MemoryInfo | null> {\n  try {\n    // 브라우저에서 사용 가능한 메모리 API 사용\n    if (typeof window === 'undefined' || !performance || !(performance as any).memory) {\n      return createEstimatedMemoryInfo();\n    }\n\n    const memory = (performance as any).memory as PerformanceMemory;\n\n    if (!memory) {\n      throw new Error('브라우저 메모리 API를 사용할 수 없습니다.');\n    }\n\n    const heap_used = memory.usedJSHeapSize;\n    const heap_total = memory.totalJSHeapSize;\n    const heap_limit = memory.jsHeapSizeLimit;\n    const percent_used = (heap_used / heap_total) * 100;\n\n    // RSS 추정 (정확한 값을 얻을 수 없으므로 힙 크기의 1.5배로 추정)\n    const rss = Math.round(heap_total * 1.5);\n\n    return {\n      heap_used,\n      heap_total,\n      heap_limit,\n      heap_used_mb: heap_used / (1024 * 1024),\n      percent_used,\n      rss,\n      rss_mb: rss / (1024 * 1024),\n      timestamp: Date.now(),\n    };\n  } catch (err) {\n    console.error('메모리 정보 가져오기 오류:', err);\n    return createEstimatedMemoryInfo();\n  }\n}\n\n/**\n * 추정 메모리 정보 생성\n * 브라우저가 메모리 API를 지원하지 않을 때 호출됩니다.\n */\nfunction createEstimatedMemoryInfo(): MemoryInfo {\n  // 추정치로 기본값 제공\n  const estimatedHeapUsed = 50 * 1024 * 1024; // 50MB\n  const estimatedHeapTotal = 100 * 1024 * 1024; // 100MB\n  const estimatedHeapLimit = estimatedHeapTotal * 2;\n  const estimatedRss = Math.round(estimatedHeapTotal * 1.5);\n\n  return {\n    heap_used: estimatedHeapUsed,\n    heap_total: estimatedHeapTotal,\n    heap_limit: estimatedHeapLimit,\n    heap_used_mb: Math.round((estimatedHeapUsed / (1024 * 1024)) * 10) / 10,\n    rss: estimatedRss,\n    rss_mb: Math.round((estimatedRss / (1024 * 1024)) * 10) / 10,\n    percent_used: 50,\n    timestamp: Date.now(),\n  };\n}\n\n/**\n * 네이티브 모듈을 통한 메모리 정보 가져오기\n */\nexport async function getNativeMemoryInfo(): Promise<MemoryInfo | null> {\n  try {\n    // 네이티브 모듈 연동 함수 호출\n    if (\n      typeof window !== 'undefined' &&\n      window.__memoryOptimizer &&\n      typeof window.__memoryOptimizer.checkMemoryUsage === 'function'\n    ) {\n      const nativeMemoryInfo = window.__memoryOptimizer.checkMemoryUsage();\n      if (nativeMemoryInfo) {\n        return normalizeMemoryInfo(nativeMemoryInfo);\n      }\n    }\n\n    // API를 통해 가져오기\n    try {\n      const memoryInfo = await requestNativeMemoryInfo();\n      if (memoryInfo) {\n        return memoryInfo;\n      }\n    } catch (apiError) {\n      console.debug('API를 통한 메모리 정보 가져오기 실패:', apiError);\n    }\n\n    // 네이티브 모듈 사용 불가능한 경우 브라우저 정보 반환\n    return getMemoryUsage();\n  } catch (error) {\n    console.error('네이티브 메모리 정보 가져오기 오류:', error);\n    return getMemoryUsage();\n  }\n}\n\n/**\n * 메모리 정보 가져오기 (MemoryMonitor 컴포넌트와의 호환성을 위한 함수)\n */\nexport async function getMemoryInfo(): Promise<MemoryInfo> {\n  // 네이티브 브리지를 통한 요청 시도\n  try {\n    if (\n      typeof window !== 'undefined' &&\n      window.__memoryOptimizer &&\n      typeof window.__memoryOptimizer.checkMemoryUsage === 'function'\n    ) {\n      const nativeMemoryInfo = window.__memoryOptimizer.checkMemoryUsage();\n      if (nativeMemoryInfo) {\n        // nativeMemoryInfo가 MemoryInfo 타입인지 확인하고, 아니라면 변환\n        return normalizeMemoryInfo(nativeMemoryInfo);\n      }\n    }\n  } catch (e) {\n    console.error('Native memory info request failed:', e);\n  }\n\n  // 실패 시 브라우저 메모리 정보 반환\n  const memoryInfo = await getMemoryUsage();\n  return memoryInfo || createEstimatedMemoryInfo();\n}\n\n/**\n * 메모리 정보 포맷팅 함수\n */\nexport function formatMemoryInfo(info: MemoryInfo): string {\n  if (!info) return 'Memory info not available';\n\n  const usedMB = info.heap_used_mb.toFixed(1);\n  const totalMB = (info.heap_total / (1024 * 1024)).toFixed(1);\n  const percent = info.percent_used.toFixed(1);\n\n  return `Memory: ${usedMB}MB / ${totalMB}MB (${percent}%)`;\n}\n\n/**\n * 메모리 상태 평가\n */\nexport function assessMemoryState(memoryInfo: MemoryInfo): 'normal' | 'warning' | 'critical' {\n  const percentUsed = memoryInfo.percent_used;\n\n  if (percentUsed > 85) {\n    return 'critical';\n  } else if (percentUsed > 70) {\n    return 'warning';\n  }\n\n  return 'normal';\n}\n\n/**\n * 메모리 정보 정규화 (필드 이름 통일)\n */\nexport function normalizeMemoryInfo(info: any): MemoryInfo {\n  if (!info) {\n    return createEstimatedMemoryInfo();\n  }\n\n  // 기존 키가 없는 경우 대체값 제공\n  return {\n    heap_used: info.heapUsed || info.heap_used || 0,\n    heapUsed: info.heapUsed || info.heap_used || 0,\n    heap_total: info.heapTotal || info.heap_total || 0,\n    heapTotal: info.heapTotal || info.heap_total || 0,\n    heap_used_mb: info.heapUsedMB || info.heap_used_mb || 0,\n    heapUsedMB: info.heapUsedMB || info.heap_used_mb || 0,\n    rss: info.rss || 0,\n    rss_mb: info.rssMB || info.rss_mb || 0,\n    rssMB: info.rssMB || info.rss_mb || 0,\n    percent_used: info.percentUsed || info.percent_used || 0,\n    percentUsed: info.percentUsed || info.percent_used || 0,\n    heap_limit: info.heapLimit || info.heap_limit || 0,\n    timestamp: info.timestamp || Date.now(),\n  };\n}\n","/**\r\n * 네이티브 모듈 타입 정의\r\n */\r\n\r\n// 네이티브 모듈 최적화 레벨\r\nexport enum OptimizationLevel {\r\n  Normal = 0,\r\n  Low = 1,\r\n  Medium = 2,\r\n  High = 3,\r\n  Critical = 4\r\n}\r\n\r\n// GPU 장치 정보 인터페이스\r\nexport interface GpuDeviceInfo {\r\n  name: string;\r\n  vendor: string;\r\n  driver_info: string;\r\n  device_type: string;\r\n  backend: string;\r\n  timestamp: number;\r\n}\r\n\r\n// GPU 정보 인터페이스\r\nexport interface GpuInfo {\r\n  name: string;\r\n  vendor: string;\r\n  driver_info: string;\r\n  device_type: string;\r\n  backend: string;\r\n  available: boolean;\r\n  timestamp: number;\r\n}\r\n\r\n// GPU 작업 결과 인터페이스\r\nexport interface GpuTaskResult {\r\n  task_id: string;\r\n  task_type: string;\r\n  duration_ms: number;\r\n  result: any;\r\n  timestamp: number;\r\n}\r\n\r\n// 작업 결과 인터페이스\r\nexport interface TaskResult {\r\n  task_id: string;\r\n  task_type: string;\r\n  duration_ms: number;\r\n  result: any;\r\n  timestamp: number;\r\n}\r\n\r\n// GPU 계산 결과 인터페이스\r\nexport interface GpuComputationResult {\r\n  computation_type: string;\r\n  duration_ms: number;\r\n  result: any;\r\n  timestamp: number;\r\n}\r\n\r\n// 네이티브 GPU 타입 (Rust enum과 일치)\r\nexport enum GPUType {\r\n  Unknown = 0,\r\n  Integrated = 1,\r\n  Discrete = 2,\r\n  Software = 3\r\n}\r\n\r\n// 네이티브 GPU 정보 인터페이스 (Rust struct와 일치)\r\nexport interface GPUInfo {\r\n  name: string;\r\n  vendor: string;\r\n  device_type: GPUType;\r\n  available: boolean;\r\n  acceleration_enabled: boolean;\r\n  renderer?: string;\r\n  driver_info?: string;\r\n  backend?: string;\r\n  timestamp: number;\r\n}\r\n\r\n// 워커 풀 상태 인터페이스\r\nexport interface WorkerPoolStats {\r\n  thread_count: number;\r\n  active_tasks: number;\r\n  completed_tasks: number;\r\n  active_workers: number;\r\n  idle_workers: number;\r\n  pending_tasks: number;\r\n  failed_tasks: number;\r\n  total_tasks: number;\r\n  uptime_ms: number;\r\n  timestamp: number;\r\n}\r\n\r\n// 성능 지표 인터페이스\r\nexport interface PerformanceMetrics {\r\n  calls: number;\r\n  errors: number;\r\n  avgExecutionTime: number;\r\n  lastGcTime: number;\r\n  totalExecutionTime: number;\r\n  timestamp: number;\r\n}\r\n\r\n// 네이티브 모듈 상태 인터페이스\r\nexport interface NativeModuleStatus {\r\n  available: boolean;\r\n  fallbackMode: boolean;\r\n  version: string | null;\r\n  info: any;\r\n  timestamp: number;\r\n  error?: string;\r\n}\r\n\r\n// GPU 작업 유형 열거형\r\nexport enum GpuTaskType {\r\n  MatrixMultiplication = 'matrix',\r\n  TextAnalysis = 'text',\r\n  ImageProcessing = 'image',\r\n  DataAggregation = 'data',\r\n  PatternDetection = 'pattern',\r\n  TypingStatistics = 'typing',\r\n  Custom = 'custom'\r\n}\r\n\r\n// GPU 가속 상태 인터페이스\r\nexport interface GpuAccelerationStatus {\r\n  available: boolean;\r\n  enabled: boolean;\r\n  info?: GpuInfo;\r\n}\r\n\r\n// 메모리 정보 인터페이스\r\nexport interface MemoryInfo {\r\n  heap_used: number;\r\n  heap_total: number;\r\n  heap_limit: number;\r\n  heap_used_mb: number;\r\n  rss: number;\r\n  rss_mb: number;\r\n  percent_used: number;\r\n  external: number;\r\n  timestamp: number;\r\n}\r\n\r\n// 최적화 결과 인터페이스\r\nexport interface OptimizationResult {\r\n  success: boolean;\r\n  optimization_level: number;\r\n  freed_memory?: number;\r\n  freed_mb?: number;\r\n  memory_before?: MemoryInfo;\r\n  memory_after?: MemoryInfo;\r\n  duration?: number;\r\n  timestamp: number;\r\n  error?: string;\r\n}\r\n\r\n// 가비지 컬렉션 결과 인터페이스\r\nexport interface GCResult {\r\n  success: boolean;\r\n  freed_memory: number;\r\n  freed_mb?: number;\r\n  timestamp: number;\r\n  error?: string;\r\n}\r\n","/**\n * 네이티브 모듈 클라이언트 API\n *\n * 프론트엔드에서 네이티브 모듈 기능을 사용하기 위한 래퍼 함수들을 제공합니다.\n */\n\nimport type {\n  MemoryInfo,\n  OptimizationResult,\n  GCResult,\n  GpuComputationResult,\n  TaskResult,\n} from '@/types';\nimport { OptimizationLevel, NativeModuleStatus } from '@/types/native-module';\n\n// 윈도우 객체에 nativeModule 확장\ndeclare global {\n  interface Window {\n    nativeModule: {\n      getGpuInfo: () => Promise<NativeResponse<GpuInfo>>;\n      setGpuAcceleration: (enabled: boolean) => Promise<NativeResponse<boolean>>;\n      getMemoryInfo: () => Promise<NativeResponse<MemoryInfo>>;\n      optimizeMemory: (level?: OptimizationLevel) => Promise<NativeResponse<OptimizationResult>>;\n      forceGarbageCollection: () => Promise<NativeResponse<GCResult>>;\n      performGpuComputation: (\n        taskType: GpuTaskType,\n        params: Record<string, any>\n      ) => Promise<NativeResponse<any>>;\n    };\n  }\n}\n\n/**\n * 네이티브 모듈 응답 인터페이스\n */\ninterface NativeResponse<T = any> {\n  success: boolean;\n  error?: string;\n  timestamp: number;\n  data?: T;\n}\n\n/**\n * GPU 정보 인터페이스\n */\nexport interface GpuInfo {\n  name: string;\n  vendor: string;\n  renderer?: string;\n  driverInfo?: string;\n  deviceType?: string;\n  backend?: string;\n  available: boolean;\n  accelerationEnabled?: boolean;\n}\n\n/**\n * GPU 가속 상태 인터페이스\n */\nexport interface GpuAccelerationStatus {\n  available: boolean;\n  enabled: boolean;\n  info?: GpuInfo;\n}\n\n/**\n * GPU 작업 유형\n */\nexport enum GpuTaskType {\n  MatrixMultiplication = 'matrix',\n  TextAnalysis = 'text',\n  ImageProcessing = 'image',\n  DataAggregation = 'data',\n  PatternDetection = 'pattern',\n  TypingStatistics = 'typing',\n  Custom = 'custom',\n}\n\n// 상태 캐시\nlet moduleStatusCache: NativeModuleStatus | null = null;\nlet lastStatusCheck = 0;\nconst STATUS_CACHE_TTL = 10000; // 10초\n\n/**\n * 메모리 정보 조회\n * @returns 메모리 사용량 정보\n */\nexport const getMemoryInfo = async (): Promise<MemoryInfo | null> => {\n  try {\n    // 네이티브 모듈을 통해 메모리 정보 요청\n    const response = await window.nativeModule.getMemoryInfo();\n\n    if (!response.success || !response.data) {\n      console.error('메모리 정보를 가져오는 데 실패했습니다:', response.error);\n      return null;\n    }\n\n    return response.data;\n  } catch (error) {\n    console.error('메모리 정보를 가져오는 중 오류 발생:', error);\n    return null;\n  }\n};\n\n/**\n * 메모리 최적화 수행\n * @param level 최적화 레벨\n * @returns 최적화 결과\n */\nexport const optimizeMemory = async (\n  level: OptimizationLevel = OptimizationLevel.Medium\n): Promise<OptimizationResult | null> => {\n  try {\n    // 네이티브 모듈을 통해 메모리 최적화 요청\n    const response = await window.nativeModule.optimizeMemory(level);\n\n    if (!response.success || !response.data) {\n      console.error('메모리 최적화에 실패했습니다:', response.error);\n      return null;\n    }\n\n    return response.data;\n  } catch (error) {\n    console.error('메모리 최적화 중 오류 발생:', error);\n    return null;\n  }\n};\n\n/**\n * 가비지 컬렉션 강제 수행\n * @returns GC 결과\n */\nexport const forceGarbageCollection = async (): Promise<GCResult | null> => {\n  try {\n    // 네이티브 모듈을 통해 GC 요청\n    const response = await window.nativeModule.forceGarbageCollection();\n\n    if (!response.success || !response.data) {\n      console.error('가비지 컬렉션에 실패했습니다:', response.error);\n      return null;\n    }\n\n    return response.data;\n  } catch (error) {\n    console.error('가비지 컬렉션 중 오류 발생:', error);\n    return null;\n  }\n};\n\n/**\n * GPU 연산 작업 수행\n * @param taskType 작업 유형\n * @param params 작업 파라미터\n * @returns 연산 결과\n */\nexport const performGpuComputation = async (\n  taskType: GpuTaskType,\n  params: Record<string, any>\n): Promise<any | null> => {\n  try {\n    // 네이티브 모듈을 통해 GPU 연산 요청\n    const response = await window.nativeModule.performGpuComputation(taskType, params);\n\n    if (!response.success || !response.data) {\n      console.error(`GPU 연산(${taskType})에 실패했습니다:`, response.error);\n      return null;\n    }\n\n    return response.data;\n  } catch (error) {\n    console.error(`GPU 연산(${taskType}) 중 오류 발생:`, error);\n    return null;\n  }\n};\n\n/**\n * GPU 정보 가져오기\n * @returns GPU 정보\n */\nexport const getGpuInfo = async (): Promise<GpuInfo | null> => {\n  try {\n    // 네이티브 모듈을 통해 GPU 정보 가져오기\n    const response = await window.nativeModule.getGpuInfo();\n\n    if (!response.success || !response.data) {\n      console.error('GPU 정보를 가져오는 데 실패했습니다:', response.error);\n      return null;\n    }\n\n    return response.data;\n  } catch (error) {\n    console.error('GPU 정보를 가져오는 중 오류 발생:', error);\n    return null;\n  }\n};\n\n/**\n * GPU 가속 설정\n * @param enabled 활성화 여부\n * @returns 설정 결과\n */\nexport const setGpuAcceleration = async (enabled: boolean): Promise<boolean> => {\n  try {\n    // 네이티브 모듈을 통해 GPU 가속 설정\n    const response = await window.nativeModule.setGpuAcceleration(enabled);\n\n    if (!response.success) {\n      console.error('GPU 가속 설정에 실패했습니다:', response.error);\n      return false;\n    }\n\n    return response.data || false;\n  } catch (error) {\n    console.error('GPU 가속 설정 중 오류 발생:', error);\n    return false;\n  }\n};\n\n/**\n * 네이티브 모듈 상태 조회\n * @returns 네이티브 모듈 상태 정보\n */\nexport async function getNativeModuleStatus(): Promise<NativeModuleStatus> {\n  // 캐시된 상태가 있으면 반환\n  if (moduleStatusCache && Date.now() - (moduleStatusCache.timestamp || 0) < 60000) {\n    return moduleStatusCache;\n  }\n\n  try {\n    // GPU 정보 요청으로 네이티브 모듈 상태 확인\n    const gpuInfo = await getGpuInfo();\n\n    // 성공적으로 응답을 받았으면 모듈이 사용 가능함\n    if (gpuInfo) {\n      // NativeResponse 형식에서 NativeModuleStatus 형식으로 변환\n      const result: NativeModuleStatus = {\n        available: true,\n        fallbackMode: false,\n        version: '1.0.0', // 네이티브 모듈 버전\n        info: gpuInfo,\n        timestamp: Date.now(),\n      };\n\n      // 상태 캐싱\n      moduleStatusCache = result;\n      return result;\n    }\n\n    // 응답 실패 시 기본 오류 상태 반환\n    const errorStatus: NativeModuleStatus = {\n      available: false,\n      fallbackMode: true,\n      version: null,\n      info: null,\n      timestamp: Date.now(),\n      error: '네이티브 모듈을 사용할 수 없습니다.',\n    };\n\n    moduleStatusCache = errorStatus;\n    return errorStatus;\n  } catch (error) {\n    console.error('네이티브 모듈 상태 조회 오류:', error);\n\n    const errorStatus: NativeModuleStatus = {\n      available: false,\n      fallbackMode: true,\n      version: null,\n      info: null,\n      timestamp: Date.now(),\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\n    };\n\n    moduleStatusCache = errorStatus;\n    return errorStatus;\n  }\n}\n\n/**\n * 네이티브 모듈 사용 가능 여부 확인\n * @returns 사용 가능 여부\n */\nexport function isNativeModuleAvailable(): boolean {\n  return typeof window !== 'undefined' && !!window.nativeModule;\n}\n"],"names":["window","requestGC","_emergency","requestNativeGarbageCollection","error","console","success","timestamp","Date","now","Error","message","freedMemory","freedMB","__memoryOptimizer","suggestGarbageCollection","emergency","clearBrowserCaches","clearStorageCaches","checkMemoryUsage","forceGC","cleanAllCaches","bridgeState","isInitialized","isAvailable","lastError","lastCheck","errorCount","withErrorHandling","operation","fallback","operationName","checkBridgeAvailability","warn","String","response","fetchMemoryInfo","forceGarbageCollection","duration","getMemoryUsage","performance","memory","createEstimatedMemoryInfo","heap_used","usedJSHeapSize","heap_total","totalJSHeapSize","heap_limit","jsHeapSizeLimit","rss","Math","round","heap_used_mb","percent_used","rss_mb","err","estimatedRss","estimatedHeapTotal","estimatedHeapUsed","estimatedHeapLimit","getMemoryInfo","nativeMemoryInfo","normalizeMemoryInfo","info","heapUsed","heapTotal","heapUsedMB","rssMB","percentUsed","heapLimit","e","memoryInfo","OptimizationLevel","nativeModule","data","level","Medium","optimizeMemory","taskType","params","performGpuComputation","getGpuInfo","enabled","setGpuAcceleration"],"sourceRoot":"","ignoreList":[]}