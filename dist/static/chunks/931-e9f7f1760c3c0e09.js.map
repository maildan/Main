{"version":3,"file":"static/chunks/931-e9f7f1760c3c0e09.js","mappings":"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","sources":["webpack://_N_E/./src/app/utils/memory/gc-utils.ts","webpack://_N_E/./src/app/utils/native-memory-bridge.ts","webpack://_N_E/./src/types/index.ts","webpack://_N_E/./src/app/utils/memory/memory-info.ts","webpack://_N_E/./src/types/optimization-level.ts","webpack://_N_E/./src/app/utils/enum-converters.ts"],"sourcesContent":["/**\r\n * 가비지 컬렉션 유틸리티\r\n * \r\n * 메모리 정리 관련 기능을 제공합니다.\r\n */\r\n\r\nimport { GCResult } from '@/types';\r\nimport { requestNativeGarbageCollection } from '../native-memory-bridge';\r\n\r\n// 변수 및 상수 선언 추가\r\nlet lastGCTime = 0;\r\nconst MIN_GC_INTERVAL = 3000; // 3초\r\n\r\n/**\r\n * 브라우저 환경인지 확인하는 함수\r\n */\r\nexport const isBrowser = typeof window !== 'undefined';\r\n\r\n/**\r\n * 가비지 컬렉션 요청\r\n * 네이티브 모듈을 통해 GC를 수행합니다.\r\n * @returns GC 결과\r\n */\r\nexport async function requestGC(_emergency: boolean = false): Promise<GCResult | null> {\r\n  try {\r\n    return await requestNativeGarbageCollection();\r\n  } catch (error) {\r\n    console.error('가비지 컬렉션 요청 오류:', error);\r\n    return {\r\n      success: false,\r\n      freedMemory: 0,\r\n      freedMB: 0,\r\n      timestamp: Date.now(),\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류'\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * 수동 메모리 정리 수행\r\n * JS 환경에서 가능한 메모리 정리 작업을 수행합니다.\r\n */\r\nexport async function cleanupMemory(): Promise<boolean> {\r\n  try {\r\n    // 브라우저 환경에서만 실행\r\n    if (!isBrowser) return false;\r\n\r\n    // 가능한 경우 global.gc 호출\r\n    if (typeof window.gc === 'function') {\r\n      window.gc();\r\n    }\r\n\r\n    // 미사용 이미지 캐시 정리\r\n    if (window.__imageResizeCache) {\r\n      window.__imageResizeCache.clear();\r\n    }\r\n\r\n    // 오브젝트 URL 정리\r\n    if (window.__objectUrls) {\r\n      for (const [_key, url] of window.__objectUrls) {\r\n        URL.revokeObjectURL(url);\r\n      }\r\n      window.__objectUrls.clear();\r\n    }\r\n\r\n    return true;\r\n  } catch (error) {\r\n    console.error('메모리 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 주기적인 메모리 정리 설정\r\n * @param interval 실행 간격(ms)\r\n * @returns 정리 함수\r\n */\r\nexport function setupPeriodicGC(interval: number = 60000): () => void {\r\n  const timerId = setInterval(async () => {\r\n    await requestGC(false);\r\n  }, interval);\r\n\r\n  return () => {\r\n    clearInterval(timerId);\r\n  };\r\n}\r\n\r\n/**\r\n * 가비지 컬렉션 제안 함수\r\n * \r\n * 브라우저 환경에서 가비지 컬렉션을 제안합니다.\r\n * window.gc가 있는 환경(크롬 --js-flags=\"--expose-gc\")에서만 작동합니다.\r\n */\r\nexport function suggestGarbageCollection(): void {\r\n  if (isBrowser) {\r\n    if (window.gc) {\r\n      window.gc();\r\n    } else {\r\n      // GC를 직접 호출할 수 없는 경우 간접적으로 메모리 압박을 가함\r\n      const now = Date.now();\r\n\r\n      // 너무 자주 호출되지 않도록 조절\r\n      if (now - lastGCTime < MIN_GC_INTERVAL) {\r\n        return;\r\n      }\r\n\r\n      lastGCTime = now;\r\n\r\n      // 메모리 할당 후 해제하여 GC 유도\r\n      try {\r\n        const arr = new Array(10000).fill({});\r\n        arr.length = 0;\r\n      } catch (e) {\r\n        console.warn('GC 간접 호출 중 오류:', e);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 브라우저 캐시 정리\r\n */\r\nexport async function clearBrowserCaches(): Promise<boolean> {\r\n  try {\r\n    if (!isBrowser) return false;\r\n\r\n    // 사용 가능한 캐시 API가 있으면 정리\r\n    if ('caches' in window) {\r\n      const cacheNames = await window.caches.keys();\r\n      await Promise.all(\r\n        cacheNames.map(cacheName => window.caches.delete(cacheName))\r\n      );\r\n    }\r\n\r\n    return true;\r\n  } catch (error) {\r\n    console.error('브라우저 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 브라우저 스토리지 정리\r\n */\r\nexport function clearStorageCaches(): boolean {\r\n  try {\r\n    if (!isBrowser) return false;\r\n\r\n    // 세션 스토리지는 완전히 정리\r\n    if (window.sessionStorage) {\r\n      window.sessionStorage.clear();\r\n    }\r\n\r\n    // 로컬 스토리지는 임시 데이터만 정리\r\n    if (window.localStorage) {\r\n      const keysToDelete: string[] = [];\r\n\r\n      for (let i = 0; i < window.localStorage.length; i++) {\r\n        const key = window.localStorage.key(i);\r\n        // null 체크 추가\r\n        if (key && (key.startsWith('temp_') || key.startsWith('cache_'))) {\r\n          keysToDelete.push(key);\r\n        }\r\n      }\r\n\r\n      keysToDelete.forEach(key => window.localStorage.removeItem(key));\r\n    }\r\n\r\n    return true;\r\n  } catch (error) {\r\n    console.error('스토리지 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 캐시 정리 유틸리티\r\n */\r\nexport function cleanCache(cacheType: string): boolean {\r\n  try {\r\n    if (!isBrowser) return false;\r\n\r\n    switch (cacheType) {\r\n      case 'local':\r\n        return cleanLocalStorageCache();\r\n      case 'session':\r\n        sessionStorage.clear();\r\n        return true;\r\n      case 'browser':\r\n        clearBrowserCaches();\r\n        return true;\r\n      case 'memory':\r\n        return cleanMemoryCache();\r\n      case 'all':\r\n        cleanLocalStorageCache();\r\n        sessionStorage.clear();\r\n        clearBrowserCaches();\r\n        cleanMemoryCache();\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  } catch (error) {\r\n    console.error(`캐시 정리 오류 (${cacheType}):`, error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 로컬 스토리지 캐시 정리\r\n */\r\nfunction cleanLocalStorageCache(): boolean {\r\n  try {\r\n    // 임시 데이터만 정리\r\n    const keysToRemove: string[] = [];\r\n\r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      if (key && (key.startsWith('cache_') || key.startsWith('temp_'))) {\r\n        keysToRemove.push(key);\r\n      }\r\n    }\r\n\r\n    keysToRemove.forEach(key => localStorage.removeItem(key));\r\n    return true;\r\n  } catch (error) {\r\n    console.error('로컬 스토리지 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 캐시 정리\r\n */\r\nfunction cleanMemoryCache(): boolean {\r\n  try {\r\n    // 이미지 캐시 정리\r\n    if (window.__imageResizeCache) {\r\n      window.__imageResizeCache.clear();\r\n    }\r\n\r\n    // 오브젝트 URL 정리\r\n    if (window.__objectUrls) {\r\n      for (const [_key, url] of window.__objectUrls) {\r\n        URL.revokeObjectURL(url);\r\n      }\r\n      window.__objectUrls.clear();\r\n    }\r\n\r\n    return true;\r\n  } catch (error) {\r\n    console.error('메모리 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 비활성 캐시 정리\r\n */\r\nexport function cleanInactiveCaches(): boolean {\r\n  try {\r\n    if (!isBrowser) return false;\r\n\r\n    // 접근 시간 추적을 위한 메타데이터 키\r\n    const CACHE_ACCESS_KEY = 'cache_last_access';\r\n\r\n    // 현재 시간\r\n    const now = Date.now();\r\n\r\n    // 마지막 접근 시간 정보 로드\r\n    let accessInfo: Record<string, number> = {};\r\n    try {\r\n      const accessInfoJson = localStorage.getItem(CACHE_ACCESS_KEY);\r\n      if (accessInfoJson) {\r\n        accessInfo = JSON.parse(accessInfoJson);\r\n      }\r\n    } catch {\r\n      // 파싱 오류 무시, 빈 객체 사용\r\n    }\r\n\r\n    // 캐시 항목 스캔\r\n    const keysToCheck: string[] = [];\r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      if (key && key.startsWith('cache_')) {\r\n        keysToCheck.push(key);\r\n      }\r\n    }\r\n\r\n    // 일정 시간 접근되지 않은 캐시 정리 (7일 이상)\r\n    const expiryTime = 7 * 24 * 60 * 60 * 1000; // 7일\r\n    const expiredKeys = keysToCheck.filter(key => {\r\n      const lastAccess = accessInfo[key] || 0;\r\n      return now - lastAccess > expiryTime;\r\n    });\r\n\r\n    // 만료된 키 제거\r\n    expiredKeys.forEach(key => {\r\n      localStorage.removeItem(key);\r\n      delete accessInfo[key];\r\n    });\r\n\r\n    // 접근 정보 업데이트\r\n    localStorage.setItem(CACHE_ACCESS_KEY, JSON.stringify(accessInfo));\r\n\r\n    return true;\r\n  } catch (error) {\r\n    console.error('비활성 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 모든 캐시 정리\r\n */\r\nexport function cleanAllCaches(): boolean {\r\n  try {\r\n    if (!isBrowser) return false;\r\n\r\n    // 세션 스토리지 정리\r\n    sessionStorage.clear();\r\n\r\n    // 로컬 스토리지에서 캐시 키 찾기\r\n    const cacheKeys: string[] = [];\r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      if (key && (\r\n        key.startsWith('cache_') ||\r\n        key.startsWith('temp_') ||\r\n        key.includes('cache')\r\n      )) {\r\n        cacheKeys.push(key);\r\n      }\r\n    }\r\n\r\n    // 캐시 키 제거\r\n    cacheKeys.forEach(key => localStorage.removeItem(key));\r\n\r\n    // 메모리 내 캐시 정리\r\n    cleanMemoryCache();\r\n\r\n    // 브라우저 캐시 정리\r\n    clearBrowserCaches();\r\n\r\n    return true;\r\n  } catch (error) {\r\n    console.error('모든 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// 윈도우 메모리 옵티마이저 초기화 부분 수정\r\nif (typeof window !== 'undefined') {\r\n  // 타입 안전한 방식으로 속성 초기화\r\n  if (!window.__memoryOptimizer) {\r\n    (window as any).__memoryOptimizer = {\r\n      suggestGarbageCollection: () => {\r\n        // 기존 구현\r\n      },\r\n      requestGC: async (emergency?: boolean) => {\r\n        // 기존 구현\r\n        return {};\r\n      },\r\n      clearBrowserCaches: async () => {\r\n        // 기존 구현\r\n        return true;\r\n      },\r\n      clearStorageCaches: () => {\r\n        // 기존 구현\r\n        return true;\r\n      },\r\n      checkMemoryUsage: () => {\r\n        // 기존 구현\r\n        return null;\r\n      },\r\n      forceGC: () => {\r\n        // 기존 구현\r\n        return true;\r\n      },\r\n      // cleanAllCaches 메서드 추가\r\n      cleanAllCaches: () => {\r\n        // 캐시 정리 로직 구현\r\n        return true;\r\n      }\r\n    };\r\n  }\r\n\r\n  // 옵셔널 체이닝 사용 + cleanAllCaches 대신 clearStorageCaches 사용\r\n  window.__memoryOptimizer?.clearStorageCaches?.();\r\n  window.__memoryOptimizer?.suggestGarbageCollection?.();\r\n  window.__memoryOptimizer?.requestGC?.();\r\n}\r\n\r\n// 매개변수 사용되지 않음 경고 수정 (이름 앞에 _ 추가)\r\nasync function _defaultRequestGC(_emergency?: boolean): Promise<any> {\r\n  return Promise.resolve();\r\n}\r\n","/**\r\n * 네이티브 메모리 모듈 브리지\r\n * \r\n * 이 모듈은 네이티브 모듈과 연결하여 메모리 관련 기능을 제공합니다.\r\n */\r\n\r\nimport { MemoryInfo, GCResult, OptimizationLevel } from '@/types';\r\nimport { toNativeOptimizationLevel } from './enum-converters';\r\n\r\n/**\r\n * 네이티브 모듈 로드\r\n * 빌드 타임에 사용 가능한 모든 메서드를 찾을 수 없어 any 타입 사용\r\n */\r\nasync function loadNativeModule(): Promise<any> {\r\n  try {\r\n    // Typescript 타입 오류 피하기 위해 dynamic import 사용\r\n    const moduleImport = await import('../../server/native').catch(() => null);\r\n\r\n    // import의 결과가 default 속성을 가지거나 직접 객체인 경우 처리\r\n    if (moduleImport) {\r\n      return 'default' in moduleImport ? moduleImport.default : moduleImport;\r\n    }\r\n\r\n    return null;\r\n  } catch (error) {\r\n    console.error('네이티브 모듈 로드 오류:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * 네이티브 메모리 정보 요청\r\n * @returns Promise<MemoryInfo | null>\r\n */\r\nexport async function requestNativeMemoryInfo(): Promise<MemoryInfo | null> {\r\n  try {\r\n    const nativeModule = await loadNativeModule();\r\n\r\n    if (!nativeModule || typeof nativeModule.getMemoryInfo !== 'function') {\r\n      return null;\r\n    }\r\n\r\n    const result = await nativeModule.getMemoryInfo();\r\n\r\n    // 결과가 문자열인 경우 JSON 파싱\r\n    if (typeof result === 'string') {\r\n      try {\r\n        return JSON.parse(result) as MemoryInfo;\r\n      } catch (e) {\r\n        console.error('메모리 정보 파싱 오류:', e);\r\n        return null;\r\n      }\r\n    }\r\n\r\n    return result as MemoryInfo;\r\n  } catch (error) {\r\n    console.error('네이티브 메모리 정보 요청 오류:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * 네이티브 가비지 컬렉션 요청\r\n * @returns Promise<GCResult | null>\r\n */\r\nexport async function requestNativeGarbageCollection(): Promise<GCResult | null> {\r\n  try {\r\n    const nativeModule = await loadNativeModule();\r\n\r\n    if (!nativeModule || typeof nativeModule.performGarbageCollection !== 'function') {\r\n      return null;\r\n    }\r\n\r\n    const result = await nativeModule.performGarbageCollection();\r\n\r\n    // 결과가 문자열인 경우 JSON 파싱\r\n    if (typeof result === 'string') {\r\n      try {\r\n        return JSON.parse(result) as GCResult;\r\n      } catch (e) {\r\n        console.error('GC 결과 파싱 오류:', e);\r\n        return null;\r\n      }\r\n    }\r\n\r\n    return result as GCResult;\r\n  } catch (error) {\r\n    console.error('네이티브 가비지 컬렉션 요청 오류:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * 네이티브 메모리 최적화 요청\r\n * @param level 최적화 레벨\r\n * @param emergency 긴급 여부\r\n * @returns Promise<any | null>\r\n */\r\nexport async function requestNativeMemoryOptimization(\r\n  level: OptimizationLevel | number,\r\n  emergency: boolean = false\r\n): Promise<any | null> {\r\n  try {\r\n    const nativeModule = await loadNativeModule();\r\n\r\n    if (!nativeModule || typeof nativeModule.optimizeMemory !== 'function') {\r\n      return null;\r\n    }\r\n\r\n    // 네이티브 최적화 레벨로 변환\r\n    const nativeLevel = typeof level === 'number'\r\n      ? toNativeOptimizationLevel(level as OptimizationLevel)\r\n      : toNativeOptimizationLevel(level);\r\n\r\n    const result = await nativeModule.optimizeMemory(nativeLevel, emergency);\r\n\r\n    // 결과가 문자열인 경우 JSON 파싱\r\n    if (typeof result === 'string') {\r\n      try {\r\n        return JSON.parse(result);\r\n      } catch (e) {\r\n        console.error('최적화 결과 파싱 오류:', e);\r\n        return null;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('네이티브 메모리 최적화 요청 오류:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * 네이티브 모듈 상태 확인\r\n * @returns Promise<{ available: boolean, version: string }>\r\n */\r\nexport async function getNativeModuleStatus(): Promise<{\r\n  available: boolean;\r\n  version: string;\r\n  fallbackMode: boolean;\r\n}> {\r\n  try {\r\n    const nativeModule = await loadNativeModule();\r\n\r\n    if (!nativeModule) {\r\n      return { available: false, version: 'unavailable', fallbackMode: true };\r\n    }\r\n\r\n    let version = 'unknown';\r\n    if (typeof nativeModule.getNativeModuleVersion === 'function') {\r\n      try {\r\n        version = await nativeModule.getNativeModuleVersion();\r\n      } catch (e) {\r\n        console.warn('네이티브 모듈 버전 확인 오류:', e);\r\n      }\r\n    }\r\n\r\n    let fallbackMode = false;\r\n    if (typeof nativeModule.isFallbackMode === 'function') {\r\n      try {\r\n        fallbackMode = await nativeModule.isFallbackMode();\r\n      } catch (e) {\r\n        console.warn('네이티브 모듈 폴백 모드 확인 오류:', e);\r\n        fallbackMode = true;\r\n      }\r\n    }\r\n\r\n    return {\r\n      available: true,\r\n      version,\r\n      fallbackMode\r\n    };\r\n  } catch (error) {\r\n    console.error('네이티브 모듈 상태 확인 오류:', error);\r\n    return {\r\n      available: false,\r\n      version: 'error',\r\n      fallbackMode: true\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 정보 가져오기\r\n */\r\nexport async function getGpuInfo(): Promise<any> {\r\n  try {\r\n    const nativeModule = await loadNativeModule();\r\n\r\n    if (!nativeModule || typeof nativeModule.getGpuInfo !== 'function') {\r\n      return { success: false, error: 'GPU 정보 함수 사용 불가' };\r\n    }\r\n\r\n    return await nativeModule.getGpuInfo();\r\n  } catch (error) {\r\n    console.error('GPU 정보 가져오기 오류:', error);\r\n    return { success: false, error: String(error) };\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 가속화 설정\r\n * @param enable 활성화 여부\r\n */\r\nexport async function setGpuAcceleration(enable: boolean): Promise<any> {\r\n  try {\r\n    const nativeModule = await loadNativeModule();\r\n\r\n    if (!nativeModule || typeof nativeModule.setGpuAcceleration !== 'function') {\r\n      return { success: false, error: 'GPU 가속화 함수 사용 불가' };\r\n    }\r\n\r\n    return await nativeModule.setGpuAcceleration(enable);\r\n  } catch (error) {\r\n    console.error('GPU 가속화 설정 오류:', error);\r\n    return { success: false, error: String(error) };\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 계산 수행\r\n * @param data 계산 데이터\r\n * @param taskType 작업 유형\r\n */\r\nexport async function performGpuComputation<T = unknown>(\r\n  data: unknown,\r\n  taskType: string\r\n): Promise<{ success: boolean; result?: T; error?: string }> {\r\n  try {\r\n    const nativeModule = await loadNativeModule();\r\n\r\n    if (!nativeModule || typeof nativeModule.performGpuComputation !== 'function') {\r\n      return { success: false, error: 'GPU 계산 함수 사용 불가' };\r\n    }\r\n\r\n    const result = await nativeModule.performGpuComputation(data, taskType);\r\n    return result;\r\n  } catch (error) {\r\n    console.error('GPU 계산 오류:', error);\r\n    return { success: false, error: String(error) };\r\n  }\r\n}\r\n","/**\r\n * 애플리케이션에서 사용하는 공통 타입 정의\r\n */\r\n\r\n/**\r\n * 메모리 사용 단계 열거형\r\n */\r\nexport enum MemoryUsageLevel {\r\n  NORMAL = 0,\r\n  LOW = 1,\r\n  MEDIUM = 2,\r\n  HIGH = 3,\r\n  CRITICAL = 4\r\n}\r\n\r\n// 네이티브 모듈 타입은 네임스페이스로 분리\r\nexport namespace NativeModule {\r\n  export interface MemoryInfo {\r\n    heap_used: number;\r\n    heap_total: number;\r\n    // ... 기타 속성\r\n  }\r\n\r\n  export interface GPUInfo {\r\n    name: string;\r\n    vendor: string;\r\n    // ... 기타 속성\r\n  }\r\n}\r\n\r\n/**\r\n * 최적화 레벨 enum - 충돌 방지를 위해 이름 변경\r\n */\r\nexport enum AppOptimizationLevel {\r\n  NONE = 0,\r\n  LOW = 1,\r\n  MEDIUM = 2,\r\n  HIGH = 3,\r\n  AGGRESSIVE = 4\r\n}\r\n\r\n/**\r\n * 메모리 정보 인터페이스\r\n */\r\nexport interface MemoryInfo {\r\n  timestamp: number;\r\n  heap_used: number;\r\n  heap_total: number;\r\n  heap_limit: number;\r\n  rss: number;\r\n  external?: number;\r\n  array_buffers?: number;\r\n  heap_used_mb: number;\r\n  rss_mb: number;\r\n  percent_used: number;\r\n\r\n  // 선택적 별칭 추가 - 코드 호환성을 위함\r\n  heapUsed?: number;\r\n  heapTotal?: number;\r\n  heapLimit?: number;\r\n  heapUsedMB?: number;\r\n  percentUsed?: number;\r\n  rssMB?: number;\r\n}\r\n\r\n/**\r\n * 가비지 컬렉션 결과 인터페이스 (missing type 추가)\r\n */\r\nexport interface GCResult {\r\n  success: boolean;\r\n  timestamp: number;\r\n  freedMemory: number;\r\n  freedMB: number;\r\n  duration?: number;\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * 최적화 결과 인터페이스\r\n */\r\nexport interface OptimizationResult {\r\n  success: boolean;\r\n  optimizationLevel: OptimizationLevel | string | number;\r\n  timestamp: number;\r\n  freedMemory: number; // 모든 속성 일관되게 필수로 변경\r\n  freedMB?: number;\r\n  duration?: number;\r\n  error?: string;\r\n\r\n  // 하위 호환성을 위한 snake_case 버전\r\n  optimization_level?: string | number;\r\n  freed_memory?: number;\r\n  freed_mb?: number;\r\n}\r\n\r\n/**\r\n * 처리 모드 열거형\r\n */\r\nexport enum ProcessingMode {\r\n  AUTO = 'auto',\r\n  NORMAL = 'normal',\r\n  CPU_INTENSIVE = 'cpu-intensive',\r\n  GPU_INTENSIVE = 'gpu-intensive',\r\n  MEMORY_SAVING = 'memory-saving'\r\n}\r\n\r\n/**\r\n * 메모리 이벤트 타입 열거형 (missing type 추가)\r\n */\r\nexport enum MemoryEventType {\r\n  INFO = 'info',\r\n  WARNING = 'warning',\r\n  ERROR = 'error',\r\n  GC = 'gc',\r\n  OPTIMIZATION = 'optimization',\r\n  THRESHOLD = 'threshold',\r\n  STATE_CHANGE = 'state_change'\r\n}\r\n\r\n/**\r\n * 메모리 최적화 이벤트 인터페이스\r\n * level과 memoryFreed 속성 한정자 통일 (일관성)\r\n */\r\nexport interface MemoryOptimizationEvent {\r\n  timestamp: number;\r\n  level: OptimizationLevel | string | number; // 모두 필수 속성으로 통일\r\n  memoryFreed: number; // 모두 필수 속성으로 통일\r\n  message: string;\r\n}\r\n\r\n/**\r\n * 머신 정보 인터페이스\r\n */\r\nexport interface MachineInfo {\r\n  /** CPU 정보 */\r\n  cpuInfo: {\r\n    /** CPU 코어 수 */\r\n    cores: number;\r\n    /** 모델 이름 */\r\n    model: string;\r\n    /** 아키텍처 */\r\n    arch: string;\r\n  };\r\n\r\n  /** 메모리 정보 */\r\n  memoryInfo: {\r\n    /** 총 메모리 (MB) */\r\n    totalMemoryMB: number;\r\n    /** 여유 메모리 (MB) */\r\n    freeMemoryMB: number;\r\n  };\r\n\r\n  /** 운영체제 정보 */\r\n  osInfo: {\r\n    /** 운영체제 유형 */\r\n    type: string;\r\n    /** 운영체제 플랫폼 */\r\n    platform: string;\r\n    /** 운영체제 버전 */\r\n    release: string;\r\n  };\r\n}\r\n\r\n/**\r\n * 성능 정보 인터페이스\r\n */\r\nexport interface PerformanceInfo {\r\n  /** 앱 실행 시간 (초) */\r\n  uptime: number;\r\n\r\n  /** 평균 CPU 사용률 (%) */\r\n  avgCpuUsage: number;\r\n\r\n  /** 현재 메모리 사용량 (MB) */\r\n  memoryUsageMB: number;\r\n\r\n  /** 최대 메모리 사용량 (MB) */\r\n  peakMemoryUsageMB: number;\r\n\r\n  /** 마지막 최적화 시간 */\r\n  lastOptimizationTime?: number;\r\n\r\n  /** 최적화 횟수 */\r\n  optimizationCount: number;\r\n}\r\n\r\n/**\r\n * Electron Window Mode\r\n */\r\nexport type WindowMode = 'windowed' | 'fullscreen' | 'fullscreen-auto-hide';\r\n\r\n/**\r\n * 메모리 이벤트 인터페이스\r\n */\r\nexport interface MemoryEvent {\r\n  type: MemoryEventType;\r\n  message: string;\r\n  timestamp: number;\r\n  data?: any;\r\n}\r\n\r\n/**\r\n * 메모리 최적화 옵션 인터페이스\r\n */\r\nexport interface MemoryOptimizerOptions {\r\n  threshold?: number;\r\n  checkInterval?: number;\r\n  showWarnings?: boolean;\r\n  autoOptimize?: boolean;\r\n  debug?: boolean;\r\n  preferNative?: boolean;\r\n}\r\n\r\n/**\r\n * 메모리 최적화 유틸리티 인터페이스\r\n */\r\nexport interface MemoryOptimizerUtility {\r\n  getMemoryInfo: () => MemoryInfo | null;\r\n  optimizeMemory: (emergency?: boolean) => Promise<GCResult>;\r\n}\r\n\r\n/**\r\n * 메모리 최적화 레벨 정의\r\n */\r\nexport enum OptimizationLevel {\r\n  NONE = 0,\r\n  LOW = 1,\r\n  MEDIUM = 2,\r\n  HIGH = 3,\r\n  AGGRESSIVE = 4,\r\n  // 이전 코드와 호환되도록 별칭 추가\r\n  NORMAL = 0,\r\n  CRITICAL = 4\r\n}\r\n","/**\r\n * 메모리 정보 수집 및 처리 유틸리티\r\n */\r\n\r\nimport { MemoryInfo } from '@/types';\r\nimport { requestNativeMemoryInfo } from '../native-memory-bridge';\r\n\r\n/**\r\n * 현재 메모리 사용량 정보를 가져옵니다.\r\n * @returns Promise<MemoryInfo | null> 메모리 정보 또는 null\r\n */\r\nexport async function getMemoryUsage(): Promise<MemoryInfo | null> {\r\n  try {\r\n    // 네이티브 모듈에서 메모리 정보 가져오기 시도\r\n    const nativeInfo = await requestNativeMemoryInfo();\r\n\r\n    if (nativeInfo) {\r\n      return formatMemoryInfo(nativeInfo);\r\n    }\r\n\r\n    // 네이티브 정보가 없으면 브라우저 API 사용\r\n    return getBrowserMemoryInfo();\r\n  } catch (error) {\r\n    console.error('메모리 정보 가져오기 오류:', error);\r\n\r\n    // 오류 시 브라우저 API 시도\r\n    return getBrowserMemoryInfo();\r\n  }\r\n}\r\n\r\n/**\r\n * 브라우저 API를 사용하여 메모리 정보 가져오기\r\n * @returns MemoryInfo | null\r\n */\r\nfunction getBrowserMemoryInfo(): MemoryInfo | null {\r\n  // 브라우저 환경이 아니면 null 반환\r\n  if (typeof window === 'undefined' || typeof performance === 'undefined') {\r\n    return null;\r\n  }\r\n\r\n  try {\r\n    // Chrome의 performance.memory API 사용 시도\r\n    const memoryInfo = (performance as any).memory;\r\n\r\n    if (!memoryInfo) {\r\n      return createEmptyMemoryInfo();\r\n    }\r\n\r\n    const heapUsed = memoryInfo.usedJSHeapSize || 0;\r\n    const heapTotal = memoryInfo.totalJSHeapSize || 0;\r\n    const heapLimit = memoryInfo.jsHeapSizeLimit || 0;\r\n\r\n    return {\r\n      heap_used: heapUsed,\r\n      heapUsed,\r\n      heap_total: heapTotal,\r\n      heapTotal,\r\n      heap_limit: heapLimit,\r\n      heapLimit,\r\n      rss: 0, // 브라우저에서는 이 정보를 가져올 수 없음\r\n      external: 0,\r\n      array_buffers: 0,\r\n      heap_used_mb: heapUsed / (1024 * 1024),\r\n      heapUsedMB: heapUsed / (1024 * 1024),\r\n      rss_mb: 0,\r\n      rssMB: 0,\r\n      percent_used: heapTotal > 0 ? (heapUsed / heapTotal) * 100 : 0,\r\n      percentUsed: heapTotal > 0 ? (heapUsed / heapTotal) * 100 : 0,\r\n      timestamp: Date.now()\r\n    };\r\n  } catch (error) {\r\n    console.warn('브라우저 메모리 정보 가져오기 오류:', error);\r\n    return createEmptyMemoryInfo();\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 정보 가져오기 (별칭 - getMemoryUsage)\r\n */\r\nexport const getMemoryInfo = getMemoryUsage;\r\n\r\n/**\r\n * 빈 메모리 정보 객체 생성\r\n */\r\nfunction createEmptyMemoryInfo(): MemoryInfo {\r\n  return {\r\n    heap_used: 0,\r\n    heapUsed: 0,\r\n    heap_total: 0,\r\n    heapTotal: 0,\r\n    heap_limit: 0,\r\n    heapLimit: 0,\r\n    rss: 0,\r\n    heap_used_mb: 0,\r\n    heapUsedMB: 0,\r\n    rss_mb: 0,\r\n    rssMB: 0,\r\n    percent_used: 0,\r\n    percentUsed: 0,\r\n    timestamp: Date.now()\r\n  };\r\n}\r\n\r\n/**\r\n * 메모리 정보 포맷팅\r\n * @param info 메모리 정보\r\n */\r\nexport function formatMemoryInfo(info: any): MemoryInfo {\r\n  if (!info) return createEmptyMemoryInfo();\r\n\r\n  // snake_case와 camelCase 필드 모두 처리\r\n  const heapUsed = info.heap_used !== undefined ? info.heap_used : (info.heapUsed || 0);\r\n  const heapTotal = info.heap_total !== undefined ? info.heap_total : (info.heapTotal || 0);\r\n  const heapLimit = info.heap_limit !== undefined ? info.heap_limit : (info.heapLimit || 0);\r\n  const rss = info.rss || 0;\r\n\r\n  // MB 단위 계산\r\n  const heapUsedMB = info.heap_used_mb !== undefined ?\r\n    info.heap_used_mb : (info.heapUsedMB !== undefined ?\r\n      info.heapUsedMB : heapUsed / (1024 * 1024));\r\n\r\n  const rssMB = info.rss_mb !== undefined ?\r\n    info.rss_mb : (info.rssMB !== undefined ?\r\n      info.rssMB : rss / (1024 * 1024));\r\n\r\n  // 백분율 계산\r\n  const percentUsed = info.percent_used !== undefined ?\r\n    info.percent_used : (info.percentUsed !== undefined ?\r\n      info.percentUsed : (heapTotal > 0 ? (heapUsed / heapTotal) * 100 : 0));\r\n\r\n  return {\r\n    heap_used: heapUsed,\r\n    heapUsed: heapUsed,\r\n    heap_total: heapTotal,\r\n    heapTotal: heapTotal,\r\n    heap_limit: heapLimit,\r\n    heapLimit: heapLimit,\r\n    rss: rss,\r\n    heap_used_mb: heapUsedMB,\r\n    heapUsedMB: heapUsedMB,\r\n    rss_mb: rssMB,\r\n    rssMB: rssMB,\r\n    percent_used: percentUsed,\r\n    percentUsed: percentUsed,\r\n    timestamp: info.timestamp || Date.now()\r\n  };\r\n}\r\n\r\n/**\r\n * 메모리 상태 평가\r\n * @param info 메모리 정보\r\n */\r\nexport function assessMemoryState(info: MemoryInfo | null): {\r\n  level: 'low' | 'medium' | 'high' | 'critical';\r\n  message: string;\r\n  needsOptimization: boolean;\r\n} {\r\n  if (!info) {\r\n    return {\r\n      level: 'medium',\r\n      message: '메모리 정보를 가져올 수 없음',\r\n      needsOptimization: false\r\n    };\r\n  }\r\n\r\n  const percent = info.percent_used || 0;\r\n\r\n  if (percent > 90) {\r\n    return {\r\n      level: 'critical',\r\n      message: '메모리 사용량이 매우 높음 (최적화 필요)',\r\n      needsOptimization: true\r\n    };\r\n  } else if (percent > 75) {\r\n    return {\r\n      level: 'high',\r\n      message: '메모리 사용량이 높음 (최적화 권장)',\r\n      needsOptimization: true\r\n    };\r\n  } else if (percent > 60) {\r\n    return {\r\n      level: 'medium',\r\n      message: '메모리 사용량이 보통',\r\n      needsOptimization: false\r\n    };\r\n  } else {\r\n    return {\r\n      level: 'low',\r\n      message: '메모리 사용량이 낮음',\r\n      needsOptimization: false\r\n    };\r\n  }\r\n}\r\n","/**\r\n * 메모리 최적화 레벨 정의 (enum으로 변경하여 값으로 사용 가능)\r\n */\r\nexport enum OptimizationLevel {\r\n    NONE = 0,\r\n    LOW = 1,\r\n    MEDIUM = 2,\r\n    HIGH = 3,\r\n    AGGRESSIVE = 4,\r\n    // 이전 코드와 호환되도록 별칭 추가\r\n    NORMAL = 0,\r\n    CRITICAL = 4,\r\n    // EXTREME 추가 (CRITICAL과 동일한 값 사용)\r\n    EXTREME = 4\r\n}\r\n\r\n// 네이티브 모듈을 위한 최적화 레벨 enum\r\nexport enum NativeOptimizationLevel {\r\n    Normal = 0,\r\n    Low = 1,\r\n    Medium = 2,\r\n    High = 3,\r\n    Critical = 4\r\n}\r\n\r\n// 최적화 레벨 설명\r\nexport const OPTIMIZATION_LEVEL_DESCRIPTIONS: Record<OptimizationLevel, string> = {\r\n    [OptimizationLevel.NONE]: '없음',\r\n    [OptimizationLevel.LOW]: '낮음',\r\n    [OptimizationLevel.MEDIUM]: '중간',\r\n    [OptimizationLevel.HIGH]: '높음',\r\n    [OptimizationLevel.AGGRESSIVE]: '적극적'\r\n    // NORMAL, CRITICAL, EXTREME은 각각 NONE, AGGRESSIVE와 동일한 값을 가지므로 제거\r\n};\r\n\r\n// 최적화 레벨 매핑 - 중복된 속성 문제 해결\r\n// OptimizationLevel.NORMAL, OptimizationLevel.CRITICAL, OptimizationLevel.EXTREME이\r\n// 각각 OptimizationLevel.NONE, OptimizationLevel.AGGRESSIVE와 같은 값이므로\r\n// 시각적으로만 분리하여 주석으로 표시\r\nexport const APP_TO_NATIVE_LEVEL_MAP: Record<number, NativeOptimizationLevel> = {\r\n    // 기본 매핑\r\n    [OptimizationLevel.NONE]: NativeOptimizationLevel.Normal,\r\n    [OptimizationLevel.LOW]: NativeOptimizationLevel.Low,\r\n    [OptimizationLevel.MEDIUM]: NativeOptimizationLevel.Medium,\r\n    [OptimizationLevel.HIGH]: NativeOptimizationLevel.High,\r\n    [OptimizationLevel.AGGRESSIVE]: NativeOptimizationLevel.Critical,\r\n    // 아래 별칭들은 중복 속성이므로 주석 처리 (숫자 값이 같으므로 실제로는 위의 매핑과 같음)\r\n    // OptimizationLevel.NORMAL -> OptimizationLevel.NONE과 동일 (값: 0)\r\n    // OptimizationLevel.CRITICAL -> OptimizationLevel.AGGRESSIVE와 동일 (값: 4)\r\n    // OptimizationLevel.EXTREME -> OptimizationLevel.AGGRESSIVE와 동일 (값: 4)\r\n};\r\n\r\nexport const NATIVE_TO_APP_LEVEL_MAP: Record<NativeOptimizationLevel, OptimizationLevel> = {\r\n    [NativeOptimizationLevel.Normal]: OptimizationLevel.NORMAL,\r\n    [NativeOptimizationLevel.Low]: OptimizationLevel.LOW,\r\n    [NativeOptimizationLevel.Medium]: OptimizationLevel.MEDIUM,\r\n    [NativeOptimizationLevel.High]: OptimizationLevel.HIGH,\r\n    [NativeOptimizationLevel.Critical]: OptimizationLevel.CRITICAL\r\n};","/**\r\n * 최적화 레벨 열거형 변환 유틸리티\r\n */\r\nimport {\r\n  OptimizationLevel\r\n} from '@/types';\r\nimport {\r\n  NativeOptimizationLevel,\r\n  APP_TO_NATIVE_LEVEL_MAP,\r\n  NATIVE_TO_APP_LEVEL_MAP\r\n} from '@/types/optimization-level';\r\nimport { MemoryUsageLevel } from '@/types';\r\n\r\n// MemoryEventType 열거형 선언\r\nexport enum MemoryEventType {\r\n  PERIODIC_CHECK = 'periodic_check',\r\n  PAGE_NAVIGATION = 'page_navigation',\r\n  OPTIMIZATION = 'optimization',\r\n  COMPONENT_MOUNT = 'component_mount',\r\n  COMPONENT_UNMOUNT = 'component_unmount',\r\n  USER_ACTION = 'user_action',\r\n  GARBAGE_COLLECTION = 'garbage_collection',\r\n  RESOURCE_LOADING = 'resource_loading',\r\n  ERROR = 'error',\r\n  WARNING = 'warning',\r\n  CUSTOM = 'custom'\r\n}\r\n\r\n// GpuTaskType 열거형 선언\r\nexport enum GpuTaskType {\r\n  MATRIX_MULTIPLICATION = 0,\r\n  TEXT_ANALYSIS = 1,\r\n  PATTERN_DETECTION = 2,\r\n  IMAGE_PROCESSING = 3,\r\n  DATA_AGGREGATION = 4,\r\n  TYPING_STATISTICS = 5,\r\n  CUSTOM = 6\r\n}\r\n\r\n/**\r\n * 최적화 레벨 문자열을 열거형으로 변환\r\n * @param level 레벨 문자열 또는 숫자\r\n */\r\nexport function parseOptimizationLevel(level: string | number): OptimizationLevel {\r\n  if (typeof level === 'number') {\r\n    if (level >= 0 && level <= 4) {\r\n      return level as OptimizationLevel;\r\n    }\r\n    return OptimizationLevel.NORMAL;\r\n  }\r\n\r\n  switch (level.toLowerCase()) {\r\n    case 'normal':\r\n      return OptimizationLevel.NORMAL;\r\n    case 'low':\r\n      return OptimizationLevel.LOW;\r\n    case 'medium':\r\n      return OptimizationLevel.MEDIUM;\r\n    case 'high':\r\n      return OptimizationLevel.HIGH;\r\n    case 'critical':\r\n      return OptimizationLevel.CRITICAL;\r\n    default:\r\n      // 숫자 문자열인 경우 변환 시도\r\n      const num = parseInt(level, 10);\r\n      if (!isNaN(num) && num >= 0 && num <= 4) {\r\n        return num as OptimizationLevel;\r\n      }\r\n      return OptimizationLevel.NORMAL;\r\n  }\r\n}\r\n\r\n/**\r\n * 최적화 레벨을 사람이 읽기 쉬운 문자열로 변환\r\n * @param level 최적화 레벨\r\n */\r\nexport function formatOptimizationLevel(level: OptimizationLevel): string {\r\n  switch (level) {\r\n    case OptimizationLevel.NORMAL:\r\n      return '일반';\r\n    case OptimizationLevel.LOW:\r\n      return '낮음';\r\n    case OptimizationLevel.MEDIUM:\r\n      return '중간';\r\n    case OptimizationLevel.HIGH:\r\n      return '높음';\r\n    case OptimizationLevel.CRITICAL:\r\n      return '위험';\r\n    default:\r\n      return '알 수 없음';\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 이벤트 타입 포맷팅\r\n */\r\nexport function formatMemoryEventType(eventType: MemoryEventType): string {\r\n  switch (eventType) {\r\n    case MemoryEventType.PERIODIC_CHECK:\r\n      return '주기적 확인';\r\n    case MemoryEventType.PAGE_NAVIGATION:\r\n      return '페이지 탐색';\r\n    case MemoryEventType.OPTIMIZATION:\r\n      return '최적화';\r\n    case MemoryEventType.COMPONENT_MOUNT:\r\n      return '컴포넌트 마운트';\r\n    case MemoryEventType.COMPONENT_UNMOUNT:\r\n      return '컴포넌트 언마운트';\r\n    case MemoryEventType.USER_ACTION:\r\n      return '사용자 액션';\r\n    case MemoryEventType.GARBAGE_COLLECTION:\r\n      return '가비지 컬렉션';\r\n    case MemoryEventType.RESOURCE_LOADING:\r\n      return '리소스 로딩';\r\n    case MemoryEventType.ERROR:\r\n      return '오류';\r\n    case MemoryEventType.WARNING:\r\n      return '경고';\r\n    case MemoryEventType.CUSTOM:\r\n      return '사용자 정의';\r\n    default:\r\n      return '알 수 없음';\r\n  }\r\n}\r\n\r\n/**\r\n * GPU 작업 타입 정규화\r\n */\r\nexport function normalizeGpuTaskType(taskType: string | GpuTaskType): string {\r\n  if (typeof taskType === 'number') {\r\n    // 열거형에서 문자열로 변환\r\n    switch (taskType) {\r\n      case GpuTaskType.MATRIX_MULTIPLICATION:\r\n        return 'matrix';\r\n      case GpuTaskType.TEXT_ANALYSIS:\r\n        return 'text';\r\n      case GpuTaskType.PATTERN_DETECTION:\r\n        return 'pattern';\r\n      case GpuTaskType.IMAGE_PROCESSING:\r\n        return 'image';\r\n      case GpuTaskType.DATA_AGGREGATION:\r\n        return 'data';\r\n      case GpuTaskType.TYPING_STATISTICS:\r\n        return 'typing';\r\n      case GpuTaskType.CUSTOM:\r\n        return 'custom';\r\n      default:\r\n        return 'matrix'; // 기본값\r\n    }\r\n  }\r\n\r\n  // 이미 문자열인 경우 표준화\r\n  switch (taskType.toLowerCase()) {\r\n    case 'matrix':\r\n    case 'matrixmultiplication':\r\n    case 'matrix-multiplication':\r\n      return 'matrix';\r\n    case 'text':\r\n    case 'textanalysis':\r\n    case 'text-analysis':\r\n      return 'text';\r\n    case 'pattern':\r\n    case 'patterndetection':\r\n    case 'pattern-detection':\r\n      return 'pattern';\r\n    case 'image':\r\n    case 'imageprocessing':\r\n    case 'image-processing':\r\n      return 'image';\r\n    case 'data':\r\n    case 'dataaggregation':\r\n    case 'data-aggregation':\r\n      return 'data';\r\n    case 'typing':\r\n    case 'typingstatistics':\r\n    case 'typing-statistics':\r\n      return 'typing';\r\n    case 'custom':\r\n      return 'custom';\r\n    default:\r\n      return 'matrix'; // 기본값\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 사용량 레벨 가져오기\r\n */\r\nexport function getMemoryUsageLevel(percentUsed: number): MemoryUsageLevel {\r\n  if (percentUsed >= 90) {\r\n    return MemoryUsageLevel.CRITICAL;\r\n  } else if (percentUsed >= 70) {\r\n    return MemoryUsageLevel.HIGH;\r\n  } else if (percentUsed >= 50) {\r\n    return MemoryUsageLevel.MEDIUM;\r\n  } else {\r\n    return MemoryUsageLevel.LOW;\r\n  }\r\n}\r\n\r\n/**\r\n * 애플리케이션 OptimizationLevel을 네이티브 OptimizationLevel로 변환\r\n */\r\nexport function toNativeOptimizationLevel(level: OptimizationLevel): NativeOptimizationLevel {\r\n  // 매핑 테이블에서 바로 조회 (더 안전하고 직관적임)\r\n  const nativeLevel = APP_TO_NATIVE_LEVEL_MAP[level];\r\n\r\n  // 매핑 테이블에 없는 경우 기본값 반환\r\n  if (nativeLevel === undefined) {\r\n    console.warn(`알 수 없는 최적화 레벨 (${level}), 기본값 사용`);\r\n    return NativeOptimizationLevel.Medium;\r\n  }\r\n\r\n  return nativeLevel;\r\n}\r\n\r\n/**\r\n * 네이티브 OptimizationLevel을 애플리케이션 OptimizationLevel로 변환\r\n */\r\nexport function toAppOptimizationLevel(level: NativeOptimizationLevel): OptimizationLevel {\r\n  // 매핑 테이블에서 바로 조회 (더 안전하고 직관적임)\r\n  const appLevel = NATIVE_TO_APP_LEVEL_MAP[level];\r\n\r\n  // 매핑 테이블에 없는 경우 기본값 반환\r\n  if (appLevel === undefined) {\r\n    console.warn(`알 수 없는 네이티브 최적화 레벨 (${level}), 기본값 사용`);\r\n    return OptimizationLevel.MEDIUM;\r\n  }\r\n\r\n  return appLevel as OptimizationLevel;\r\n}\r\n\r\n/**\r\n * 숫자를 적절한 최적화 레벨로 안전하게 변환\r\n */\r\nexport function safeOptimizationLevel(level: number): OptimizationLevel {\r\n  switch (level) {\r\n    case 0: return OptimizationLevel.NORMAL;\r\n    case 1: return OptimizationLevel.LOW;\r\n    case 2: return OptimizationLevel.MEDIUM;\r\n    case 3: return OptimizationLevel.HIGH;\r\n    case 4: return OptimizationLevel.CRITICAL;\r\n    default:\r\n      console.warn(`유효하지 않은 최적화 레벨 (${level}), 기본값 사용`);\r\n      return OptimizationLevel.MEDIUM;\r\n  }\r\n}\r\n\r\n/**\r\n * 타입 변환 유틸리티 - 네이티브 메모리 정보를 앱 메모리 정보로 변환\r\n */\r\nexport function convertNativeMemoryInfo(nativeInfo: any): any {\r\n  if (!nativeInfo) return null;\r\n\r\n  return {\r\n    timestamp: nativeInfo.timestamp || Date.now(),\r\n    heap_used: nativeInfo.heap_used,\r\n    heapUsed: nativeInfo.heap_used,\r\n    heap_total: nativeInfo.heap_total,\r\n    heapTotal: nativeInfo.heap_total,\r\n    heap_used_mb: nativeInfo.heap_used_mb,\r\n    heapUsedMB: nativeInfo.heap_used_mb,\r\n    rss: nativeInfo.rss,\r\n    rss_mb: nativeInfo.rss_mb,\r\n    rssMB: nativeInfo.rss_mb,\r\n    percent_used: nativeInfo.percent_used,\r\n    percentUsed: nativeInfo.percent_used,\r\n    heap_limit: nativeInfo.heap_limit,\r\n    heapLimit: nativeInfo.heap_limit\r\n  };\r\n}\r\n\r\n/**\r\n * 타입 변환 유틸리티 - 네이티브 GC 결과를 앱 GC 결과로 변환\r\n */\r\nexport function convertNativeGCResult(nativeResult: any): any {\r\n  if (!nativeResult) return null;\r\n\r\n  return {\r\n    success: nativeResult.success,\r\n    timestamp: nativeResult.timestamp || Date.now(),\r\n    freedMemory: nativeResult.freed_memory,\r\n    freed_memory: nativeResult.freed_memory,\r\n    freedMB: nativeResult.freed_mb,\r\n    freed_mb: nativeResult.freed_mb,\r\n    error: nativeResult.error\r\n  };\r\n}\r\n\r\n/**\r\n * 최적화 레벨 변환 함수들\r\n */\r\nexport function getOptimizationLevelFromNumber(level: number): OptimizationLevel {\r\n  switch (level) {\r\n    case 0:\r\n      return OptimizationLevel.NONE;\r\n    case 1:\r\n      return OptimizationLevel.LOW;\r\n    case 2:\r\n      return OptimizationLevel.MEDIUM;\r\n    case 3:\r\n      return OptimizationLevel.HIGH;\r\n    case 4:\r\n      return OptimizationLevel.AGGRESSIVE;\r\n    default:\r\n      return OptimizationLevel.MEDIUM;\r\n  }\r\n}\r\n\r\nexport function getOptimizationLevelFromString(level: string): OptimizationLevel {\r\n  switch (level.toLowerCase()) {\r\n    case 'none':\r\n      return OptimizationLevel.NONE;\r\n    case 'low':\r\n      return OptimizationLevel.LOW;\r\n    case 'medium':\r\n      return OptimizationLevel.MEDIUM;\r\n    case 'high':\r\n      return OptimizationLevel.HIGH;\r\n    case 'aggressive':\r\n      return OptimizationLevel.AGGRESSIVE;\r\n    default:\r\n      return OptimizationLevel.MEDIUM;\r\n  }\r\n}\r\n\r\n// 인덱스 식이 'number' 형식이 아니므로 발생하는 오류 수정\r\nexport function getOptimizationLevelName(level: OptimizationLevel): string {\r\n  const names: Record<OptimizationLevel, string> = {\r\n    [OptimizationLevel.NONE]: '없음',\r\n    [OptimizationLevel.LOW]: '낮음',\r\n    [OptimizationLevel.MEDIUM]: '중간',\r\n    [OptimizationLevel.HIGH]: '높음',\r\n    [OptimizationLevel.AGGRESSIVE]: '적극적'\r\n  };\r\n\r\n  return names[level] || '중간';\r\n}\r\n"],"names":["window","requestGC","_emergency","requestNativeGarbageCollection","error","console","success","freedMemory","freedMB","timestamp","Date","now","Error","message","__memoryOptimizer","suggestGarbageCollection","emergency","clearBrowserCaches","clearStorageCaches","checkMemoryUsage","forceGC","cleanAllCaches","loadNativeModule","moduleImport","catch","default","requestNativeMemoryInfo","nativeModule","getMemoryInfo","result","JSON","parse","e","performGarbageCollection","getBrowserMemoryInfo","performance","memoryInfo","memory","createEmptyMemoryInfo","heapUsed","usedJSHeapSize","heapTotal","totalJSHeapSize","heapLimit","jsHeapSizeLimit","heap_used","heap_total","heap_limit","rss","external","array_buffers","heap_used_mb","heapUsedMB","rss_mb","rssMB","percent_used","percentUsed","warn","getMemoryUsage","nativeInfo","formatMemoryInfo","info","undefined"],"sourceRoot":"","ignoreList":[]}