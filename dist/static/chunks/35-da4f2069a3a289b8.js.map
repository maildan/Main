{"version":3,"file":"static/chunks/35-da4f2069a3a289b8.js","mappings":"gHAoYEA,EAAAA,EACAA,EAAAA,EACAA,EAAAA,YA/WK,eAAeC,IAAUC,UAAAA,MAAAA,CAAAA,GAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,EAAAA,SAAAA,CAAAA,EAAAA,CAC9B,EADoD,CAChD,CACF,OAAO,MAAMC,CAAAA,EAAAA,EAAAA,EAAAA,CAA8BA,EAC7C,CAAE,MAAOC,EAAO,CAEd,OADAC,QAAQD,KAAK,CAAC,iBAAkBA,GACzB,CACLE,SAAS,EACTC,UAAWC,KAAKC,GAAG,GACnBC,YAAa,EACbC,QAAS,EACTP,MAAOA,aAAiBQ,MAAQR,EAAMS,OAAO,CAAG,WAClD,CACF,CACF,CA8TOb,OAAOc,iBAAiB,EAAE,CAC5Bd,OAAec,iBAAiB,CAAG,CAClCC,yBAA0B,KAE1B,EACAd,UAAW,MAAOe,GAET,GAAC,EAEVC,mBAAoB,UAEX,EAETC,mBAAoB,KAEX,EAETC,iBAAkB,IAET,KAETC,QAAS,KAEA,EAGTC,eAAgB,KAEP,EAEX,EAIsB,QAAxBrB,EAAAA,OAAOc,iBAAAA,GAAPd,KAAAA,IAAAA,GAAAA,QAAAA,EAAAA,EAA0BkB,kBAAAA,GAA1BlB,KAAAA,OAAAA,EAAAA,IAAAA,CAAAA,GACwB,QAAxBA,EAAAA,OAAOc,iBAAAA,GAAPd,KAAAA,IAAAA,GAAAA,QAAAA,EAAAA,EAA0Be,wBAAAA,GAA1Bf,KAAAA,IAAAA,GAAAA,EAAAA,IAAAA,CAAAA,GACwB,QAAxBA,EAAAA,OAAOc,iBAAiB,GAAxBd,KAAAA,IAAAA,GAAAA,QAAAA,EAAAA,EAA0BC,SAAAA,GAA1BD,KAAAA,IAAAA,GAAAA,EAAAA,IAAAA,CAAAA,mDC/VF,IAAMsB,EAAc,CAClBC,eAAe,EACfC,YAAa,GACbC,UAAW,KACXC,UAAW,EACXC,WAAY,CACd,EAKA,eAAeC,EACbC,CAA2B,CAC3BC,CAAqC,CACrCC,CAAqB,EAErB,GAAI,CAOF,GALKT,EAAYC,aAAa,EAAE,MAExBS,IAGJ,CAACV,EAAYE,WAAW,CAE1B,CAF4B,MAC5BnB,QAAQ4B,IAAI,CAAC,mCAAiD,OAAdF,IACzCD,IAIT,OAAO,MAAMD,GACf,CAAE,MAAOzB,EAAO,CAUd,OARAkB,EAAYK,UAAU,GACtBL,EAAYG,SAAS,CAAGrB,aAAiBQ,MACrCR,EACA,MAAU8B,OAAO9B,IAErBC,QAAQD,KAAK,CAAC,0BAAwC,OAAd2B,EAAc,KAAI3B,GAGnD0B,GACT,CACF,CAKA,eAAeE,IACb,GAAI,CAEF,IAAMvB,EAAMD,KAAKC,GAAG,GACpB,GAAIA,EAAMa,EAAYI,SAAS,CAAG,KAASJ,EAAYC,aAAa,CAClE,CADoE,MAC7DD,EAAYE,WAAW,CAIhC,IAAMW,EAAW,MAAMC,CAAAA,EAAAA,EAAAA,EAAAA,CAAeA,GAYtC,OAVAd,EAAYE,WAAW,CAAGW,EAAS7B,OAAO,CAC1CgB,EAAYC,aAAa,EAAG,EAC5BD,EAAYI,SAAS,CAAGjB,EAEnB0B,EAAS7B,OAAO,CAGnBgB,CAHqB,CAGTG,SAAS,CAAG,KAFxBH,EAAYG,SAAS,CAAOb,MAAMuB,EAAS/B,KAAK,EAAI,kCAK/CkB,EAAYE,WAAW,CAC9B,MAAOpB,EAAO,CAOd,OANAkB,EAAYE,WAAW,EAAG,EAC1BF,EAAYC,aAAa,CAAG,GAC5BD,EAAYG,SAAS,CAAGrB,aAAiBQ,MACrCR,EACA,MAAU8B,OAAO9B,IACrBkB,EAAYI,SAAS,CAAGlB,KAAKC,GAAG,IACzB,CACT,CACF,CAKO,eAAeN,IACpB,OAAOyB,EACL,UACE,IAAMO,EAAW,MAAME,CAAAA,EAAAA,EAAAA,EAAAA,CAAsBA,GAE7C,GAAIF,EAAS7B,OAAO,EAAI6B,EAASG,MAAM,CACrC,CADuC,MAChCH,EAASG,MAAM,OAGd1B,MAAMuB,EAAS/B,KAAK,EAAI,sBACpC,EACA,SAMSkB,QANF,CACLhB,SAAS,EACTC,UAAWC,KAAKC,GAAG,GACnBC,YAAa,EACbC,QAAS,EACT4B,SAAU,EACVnC,MAAOkB,CAAAA,QAAAA,EAAAA,EAAYG,SAAAA,GAAZH,KAAAA,IAAAA,EAAAA,KAAAA,EAAAA,EAAuBT,OAAAA,GAAW,qBAC3C,GACA,UAEJ,mCE7HO,eAAe2B,IACpB,GAAI,CAEF,GAAI,KAA6B,SAAoB,CAAC,YAAqBC,MAAM,CAC/E,CADiF,MAC1EC,IAGT,IAAMD,EAAS,YAAqBA,MAAM,CAEpCE,EAAYF,EAAOG,cAAc,CACjCC,EAAaJ,EAAOK,eAAe,CACnCC,EAAaN,EAAOO,eAAe,CAInCC,EAAMC,KAAKC,KAAK,CAAc,IAAbN,GAEvB,MAAO,WACLF,aACAE,EACAE,aACAK,aAAcT,EAAa,OAAO,CAClCU,EAD2B,CAAU,UATlB,EAAaR,EAAc,QAW9CI,EACAK,OAAQL,EAAO,OAAO,CACtB1C,GADyB,OACdC,KAAKC,GAAG,EACrB,CACF,CAAE,MAAO8C,EAAK,CAEZ,OADAlD,QAAQD,KAAK,CAAC,kBAAmBmD,GAC1Bb,GACT,CACF,CAMA,SAASA,IAKP,MAAO,CACLC,UAJwB,CAIba,IAJkB,KAK7BX,EALoC,MAAM,GACjB,CAIbY,GALqC,EAClB,IAK/BV,GALsC,MAAM,EAKhCU,MALwC,IAMpDL,WADiC,EACnBF,KAAKC,KAAK,CAACK,KAA0C,GACnEP,IAAKC,KAAKC,GADoC,EAC/B,CAACM,KADqC,IAAG,EAExDH,EAF6D,KAErDJ,GAD6B,EACxBC,KAAK,CAACM,MAAiD,GACpEJ,YADwC,CAC1B,GACd9C,EAF+C,QAAO,IAAG,CAEzCE,GAF8C,EAGhE,CACF,CAoCO,eAAeiD,IAEpB,GAAI,CACF,GAAqC1D,CAAjC,GAA6B,GAAWc,iBAAiB,EAAyD,YAArD,OAAOd,OAAOc,iBAAiB,CAACK,gBAAgB,CAAiB,CAChI,IAAMwC,EAAmB3D,OAAOc,iBAAiB,CAACK,gBAAgB,GAClE,GAAIwC,EAGF,OAAOC,SA2DNC,CAA6B,EACpC,MAAO,CACLlB,UAAWmB,EAAKC,QAAQ,EAAID,EAAKnB,SAAS,EAAI,EAC9CoB,SAAUD,EAAKC,QAAQ,EAAID,EAAKnB,SAAS,EAAI,EAC7CE,WAAYiB,EAAKE,SAAS,EAAIF,EAAKjB,UAAU,EAAI,EACjDmB,UAAWF,EAAKE,SAAS,EAAIF,EAAKjB,UAAU,EAAI,EAChDO,aAAcU,EAAKG,UAAU,EAAIH,EAAKV,YAAY,EAAI,EACtDa,WAAYH,EAAKG,UAAU,EAAIH,EAAKV,YAAY,EAAI,EACpDH,IAAKa,EAAKb,GAAG,EAAI,EACjBK,OAAQQ,EAAKI,KAAK,EAAIJ,EAAKR,MAAM,EAAI,EACrCY,MAAOJ,EAAKI,KAAK,EAAIJ,EAAKR,MAAM,EAAI,EACpCD,aAAcS,EAAKK,WAAW,EAAIL,EAAKT,YAAY,EAAI,EACvDc,YAAaL,EAAKK,WAAW,EAAIL,EAAKT,YAAY,EAAI,EACtDN,WAAYe,EAAKM,SAAS,EAAIN,EAAKf,UAAU,EAAI,EACjDxC,UAAWuD,EAAKvD,SAAS,EAAIC,KAAKC,GAAG,EACvC,CACF,EA5E2DkD,EAGvD,CACF,CAAE,MAAOU,EAAG,CACVhE,QAAQD,KAAK,CAAC,qCAAsCiE,EACtD,CAIA,OADmB,MAAM7B,KACJE,GACvB,0GCjGA,eAAe4B,EAAcC,CAAW,MAAEC,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAuB,CAAC,EAChE,GAAI,CASF,OARiB,MAAMC,MAAMF,EAAK,CAChC,GAAGC,CAAO,CACVE,QAAS,CACP,eAAgB,mBAChB,GAAGF,EAAQE,OAAO,CAEtB,EAGF,CAAE,MAAOtE,EAAO,CAEd,MADAC,QAAQD,KAAK,CAAC,gBAAoB,OAAJmE,EAAI,MAAKnE,GACjCA,CACR,CACF,CAKO,eAAesD,IAKpB,GAAI,CACF,IAAMvB,EAAW,MAAMmC,EAAc,sBAErC,GAAI,CAACnC,EAASwC,EAAE,CACd,CADgB,KACV,MAAU,uBAAuC,OAAhBxC,EAASyC,MAAM,GAGxD,OAAO,MAAMzC,EAAS0C,IAAI,EAC5B,CAAE,MAAOzE,EAAO,CAEd,OADAC,QAAQD,KAAK,CAAC,kBAAmBA,GAC1B,CACLE,SAAS,EACTF,MAAOA,aAAiBQ,MAAQR,EAAMS,OAAO,CAAG,WAClD,CACF,CACF,CAKO,eAAeiE,QAAeC,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAQ,EAAG/D,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,EAAAA,SAAAA,CAAAA,EAAAA,CAC9C,EAD0D,CACtD,CACF,IAAMmB,EAAW,MAAMmC,EAAc,qBAAsB,CACzDU,OAAQ,MACRC,KAAMC,KAAKC,SAAS,CAAC,CACnBC,KAAM,WACNL,MAAOA,EAAMM,QAAQ,aACrBrE,CACF,EACF,GAEA,GAAI,CAACmB,EAASwC,EAAE,CACd,CADgB,KACV,MAAU,uBAAuC,OAAhBxC,EAASyC,MAAM,GAGxD,OAAO,MAAMzC,EAAS0C,IAAI,EAC5B,CAAE,MAAOzE,EAAO,CAEd,OADAC,QAAQD,KAAK,CAAC,cAAeA,GACtB,CACLE,SAAS,EACTF,MAAOA,aAAiBQ,MAAQR,EAAMS,OAAO,CAAG,WAClD,CACF,CACF,CAKO,eAAewB,IACpB,GAAI,CAEF,IAAMiD,EAAOJ,KAAKC,SAAS,CAAC,CAC1BC,KAAM,IACR,GAGA,GAAI,CACF,IAAMjD,EAAW,MAAMmC,EAAc,qBAAsB,CACzDU,OAAQ,OACRC,KAAMK,CACR,GAEA,GAAInD,EAASwC,EAAE,CACb,CADe,MACR,MAAMxC,EAAS0C,IAAI,GAI5BxE,QAAQ4B,IAAI,CAAC,kCACf,CAAE,MAAO7B,EAAO,CACdC,QAAQ4B,IAAI,CAAC,kCAAmC7B,EAClD,CAGA,IAAM+B,EAAW,MAAMmC,EAAc,qBAAsB,CACzDU,OAAQ,MACRC,KAAMK,CACR,GAEA,GAAI,CAACnD,EAASwC,EAAE,CAGd,CAHgB,KAEhBtE,QAAQD,KAAK,CAAC,kBAAqC+B,MAAAA,CAAnBA,EAASyC,MAAM,CAAC,KAAuB,OAApBzC,EAASoD,UAAU,GAChE,MAAU,uBAAuC,OAAhBpD,EAASyC,MAAM,GAGxD,OAAO,MAAMzC,EAAS0C,IAAI,EAC5B,CAAE,MAAOzE,EAAO,CACdC,QAAQD,KAAK,CAAC,cAAeA,GAG7B,GAAI,CACF,GAA0D,CAAtD,KAA6B,MAAI,OAAOJ,OAAOwF,EAAE,CAGnD,OAFAxF,OAAOwF,EAAE,GACTnF,QAAQoF,GAAG,CAAC,iBACL,CACLnF,SAAS,EACTO,QAAS,mBACTN,UAAWC,KAAKC,GAAG,EACrB,CAEJ,CAAE,MAAOiF,EAAe,CACtBrF,QAAQ4B,IAAI,CAAC,kBAAmByD,EAClC,CAEA,MAAO,CACLpF,SAAS,EACTF,MAAOA,aAAiBQ,MAAQR,EAAMS,OAAO,CAAG,YAChDN,UAAWC,KAAKC,GAAG,EACrB,CACF,CACF,CAKO,eAAekF,IACpB,GAAI,CAOF,GAAI,CAAC3F,OAAO4F,SAAS,CACnB,CADqB,MACdC,EAAsB,0BAG/B,GAAI,CACF,IAAM1D,EAAW,MAAMmC,EAAc,mBAEvC,GAAI,CAACnC,EAASwC,EAAE,CAEZ,CAFc,MACdtE,QAAQ4B,IAAI,CAAC,iBAAiC,OAAhBE,EAASyC,MAAM,CAAC,mBACvCiB,EAAsB,cAA8B,OAAhB1D,EAASyC,MAAM,GAG5D,IAAMtC,EAAS,MAAMH,EAAS0C,IAAI,GAGlC,GAAIvC,GAAUA,EAAOhC,OAAO,CAC1B,CAD4B,MACrBgC,EAGP,OADAjC,QAAQ4B,IAAI,CAAC,2CAA4CK,GAClDuD,EAAsB,iBAEjC,CAAE,MAAOC,EAAY,CAEnB,OADAzF,QAAQD,KAAK,CAAC,kBAAmB0F,GAC1BD,EAAsBC,aAAsBlF,MAAQkF,EAAWjF,OAAO,CAAG,UAClF,CACF,CAAE,MAAOT,EAAO,CAEd,OADAC,QAAQD,KAAK,CAAC,8BAA+BA,GACtCyF,EAAsB,YAC/B,CACF,CAKA,SAASA,EAAsBE,CAAc,EAE3C,IAAIC,GAAiB,EACjBC,EAAa,SAEjB,GAAI,CACiC,CACjC,IAAMC,EAASC,SAASC,aAAa,CAAC,UAChCC,EAAKH,EAAOI,UAAU,CAAC,UAAYJ,EAAOI,UAAU,CAAC,sBAE3D,GAAID,EAAI,CACNL,GAAiB,EACjB,IAAMO,EAAYF,EAAGG,YAAY,CAAC,6BAElC,GAAID,EAAW,CACb,IAAME,EAASJ,EAAGK,YAAY,CAACH,EAAUI,qBAAqB,GAAK,SAC7DC,EAAWP,EAAGK,YAAY,CAACH,EAAUM,uBAAuB,GAAK,SACvEZ,EAAa,GAAcW,MAAAA,CAAXH,EAAO,MAAa,OAATG,EAAS,IACtC,CACF,CACF,CACF,CAAE,MAAOvC,EAAG,CACVhE,QAAQ4B,IAAI,CAAC,oBAAqBoC,EACpC,CAEA,MAAO,CACL/D,SAAS,EACTwG,UAAWd,EACXlE,SAAU,GACViF,QAAS,CACPC,KAAM,UACNP,OAAQR,EACRa,UAAWd,EACXiB,qBAAqB,EACrBC,WAAY,WACZC,cAAe,QACfC,eAAgBrB,CAClB,EACExF,UAAWC,KAAKC,GAAG,EACrB,CACJ,CAMO,eAAe4G,EAAmBC,CAAe,EACtD,GAAI,CAEF,IAAMC,EAAcrC,KAAKC,SAAS,CAAC,QACjCmC,CACF,GAGMnF,EAAW,MAAMmC,EAAc,+BAAgC,CACnEU,OAAQ,MACRC,KAAMsC,CACR,GAGA,GAAI,CAACpF,EAASwC,EAAE,CACd,CADgB,KACV,MAAU,oBAAoC,OAAhBxC,EAASyC,MAAM,GAGrD,OAAO,MAAMzC,EAAS0C,IAAI,EAC5B,CAAE,MAAOzE,EAAO,CAEd,OADAC,QAAQD,KAAK,CAAC,gBAAiBA,GACxB,CACLE,SAAS,EACTkH,SAAS,EACTlF,QAAQ,EACRlC,MAAOA,aAAiBQ,MAAQR,EAAMS,OAAO,CAAG,YAChDN,UAAWC,KAAKC,GAAG,EACrB,CACF,CACF,CAOO,eAAegH,EAAmCnC,CAAa,CAAEoC,CAAuB,EAC7F,GAAI,CAEF,IAAMH,EAAcrC,KAAKC,SAAS,CAAC,MACjCG,kBACAoC,CACF,GAGMvF,EAAW,MAAMmC,EAAc,kBAAmB,CACtDU,OAAQ,OACRC,KAAMsC,CACR,GAGA,GAAI,CAACpF,EAASwC,EAAE,CACd,CADgB,KACV,MAAU,iBAAiC,OAAhBxC,EAASyC,MAAM,GAGlD,OAAO,MAAMzC,EAAS0C,IAAI,EAC5B,CAAE,MAAOzE,EAAO,CAEd,OADAC,QAAQD,KAAK,CAAC,aAAcA,GACrB,CACLE,SAAS,EACTF,MAAOA,aAAiBQ,MAAQR,EAAMS,OAAO,CAAG,YAChDN,UAAWC,KAAKC,GAAG,EACrB,CACF,CACF","sources":["webpack://_N_E/./src/app/utils/memory/gc-utils.ts","webpack://_N_E/./src/app/utils/native-memory-bridge.ts","webpack://_N_E/./src/types/index.ts","webpack://_N_E/./src/app/utils/memory/memory-info.ts","webpack://_N_E/./src/app/utils/nativeModuleClient.ts"],"sourcesContent":["/**\r\n * 가비지 컬렉션 유틸리티\r\n * \r\n * 메모리 정리 관련 기능을 제공합니다.\r\n */\r\n\r\nimport { GCResult } from '@/types';\r\nimport { requestNativeGarbageCollection } from '../native-memory-bridge';\r\n\r\n// 변수 및 상수 선언 추가\r\nlet lastGCTime = 0;\r\nconst MIN_GC_INTERVAL = 3000; // 3초\r\n\r\n/**\r\n * 브라우저 환경인지 확인하는 함수\r\n */\r\nexport const isBrowser = typeof window !== 'undefined';\r\n\r\n/**\r\n * 가비지 컬렉션 요청\r\n * 네이티브 모듈을 통해 GC를 수행합니다.\r\n * @returns GC 결과\r\n */\r\nexport async function requestGC(_emergency: boolean = false): Promise<GCResult | null> {\r\n  try {\r\n    return await requestNativeGarbageCollection();\r\n  } catch (error) {\r\n    console.error('가비지 컬렉션 요청 오류:', error);\r\n    return {\r\n      success: false,\r\n      timestamp: Date.now(),\r\n      freedMemory: 0,\r\n      freedMB: 0,\r\n      error: error instanceof Error ? error.message : '알 수 없는 오류'\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * 수동 메모리 정리 수행\r\n * JS 환경에서 가능한 메모리 정리 작업을 수행합니다.\r\n */\r\nexport async function cleanupMemory(): Promise<boolean> {\r\n  try {\r\n    // 브라우저 환경에서만 실행\r\n    if (!isBrowser) return false;\r\n    \r\n    // 가능한 경우 global.gc 호출\r\n    if (typeof window.gc === 'function') {\r\n      window.gc();\r\n    }\r\n    \r\n    // 미사용 이미지 캐시 정리\r\n    if (window.__imageResizeCache) {\r\n      window.__imageResizeCache.clear();\r\n    }\r\n    \r\n    // 오브젝트 URL 정리\r\n    if (window.__objectUrls) {\r\n      for (const [_key, url] of window.__objectUrls) {\r\n        URL.revokeObjectURL(url);\r\n      }\r\n      window.__objectUrls.clear();\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('메모리 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 주기적인 메모리 정리 설정\r\n * @param interval 실행 간격(ms)\r\n * @returns 정리 함수\r\n */\r\nexport function setupPeriodicGC(interval: number = 60000): () => void {\r\n  const timerId = setInterval(async () => {\r\n    await requestGC(false);\r\n  }, interval);\r\n  \r\n  return () => {\r\n    clearInterval(timerId);\r\n  };\r\n}\r\n\r\n/**\r\n * 가비지 컬렉션 제안 함수\r\n * \r\n * 브라우저 환경에서 가비지 컬렉션을 제안합니다.\r\n * window.gc가 있는 환경(크롬 --js-flags=\"--expose-gc\")에서만 작동합니다.\r\n */\r\nexport function suggestGarbageCollection(): void {\r\n  if (isBrowser) {\r\n    if (window.gc) {\r\n      window.gc();\r\n    } else {\r\n      // GC를 직접 호출할 수 없는 경우 간접적으로 메모리 압박을 가함\r\n      const now = Date.now();\r\n      \r\n      // 너무 자주 호출되지 않도록 조절\r\n      if (now - lastGCTime < MIN_GC_INTERVAL) {\r\n        return;\r\n      }\r\n      \r\n      lastGCTime = now;\r\n      \r\n      // 메모리 할당 후 해제하여 GC 유도\r\n      try {\r\n        const arr = new Array(10000).fill({});\r\n        arr.length = 0;\r\n      } catch (e) {\r\n        console.warn('GC 간접 호출 중 오류:', e);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 브라우저 캐시 정리\r\n */\r\nexport async function clearBrowserCaches(): Promise<boolean> {\r\n  try {\r\n    if (!isBrowser) return false;\r\n    \r\n    // 사용 가능한 캐시 API가 있으면 정리\r\n    if ('caches' in window) {\r\n      const cacheNames = await window.caches.keys();\r\n      await Promise.all(\r\n        cacheNames.map(cacheName => window.caches.delete(cacheName))\r\n      );\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('브라우저 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 브라우저 스토리지 정리\r\n */\r\nexport function clearStorageCaches(): boolean {\r\n  try {\r\n    if (!isBrowser) return false;\r\n    \r\n    // 세션 스토리지는 완전히 정리\r\n    if (window.sessionStorage) {\r\n      window.sessionStorage.clear();\r\n    }\r\n    \r\n    // 로컬 스토리지는 임시 데이터만 정리\r\n    if (window.localStorage) {\r\n      const keysToDelete: string[] = [];\r\n      \r\n      for (let i = 0; i < window.localStorage.length; i++) {\r\n        const key = window.localStorage.key(i);\r\n        // null 체크 추가\r\n        if (key && (key.startsWith('temp_') || key.startsWith('cache_'))) {\r\n          keysToDelete.push(key);\r\n        }\r\n      }\r\n      \r\n      keysToDelete.forEach(key => window.localStorage.removeItem(key));\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('스토리지 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 캐시 정리 유틸리티\r\n */\r\nexport function cleanCache(cacheType: string): boolean {\r\n  try {\r\n    if (!isBrowser) return false;\r\n\r\n    switch (cacheType) {\r\n      case 'local':\r\n        return cleanLocalStorageCache();\r\n      case 'session':\r\n        sessionStorage.clear();\r\n        return true;\r\n      case 'browser':\r\n        clearBrowserCaches();\r\n        return true;\r\n      case 'memory':\r\n        return cleanMemoryCache();\r\n      case 'all':\r\n        cleanLocalStorageCache();\r\n        sessionStorage.clear();\r\n        clearBrowserCaches();\r\n        cleanMemoryCache();\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  } catch (error) {\r\n    console.error(`캐시 정리 오류 (${cacheType}):`, error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 로컬 스토리지 캐시 정리\r\n */\r\nfunction cleanLocalStorageCache(): boolean {\r\n  try {\r\n    // 임시 데이터만 정리\r\n    const keysToRemove: string[] = [];\r\n    \r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      if (key && (key.startsWith('cache_') || key.startsWith('temp_'))) {\r\n        keysToRemove.push(key);\r\n      }\r\n    }\r\n    \r\n    keysToRemove.forEach(key => localStorage.removeItem(key));\r\n    return true;\r\n  } catch (error) {\r\n    console.error('로컬 스토리지 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 캐시 정리\r\n */\r\nfunction cleanMemoryCache(): boolean {\r\n  try {\r\n    // 이미지 캐시 정리\r\n    if (window.__imageResizeCache) {\r\n      window.__imageResizeCache.clear();\r\n    }\r\n    \r\n    // 오브젝트 URL 정리\r\n    if (window.__objectUrls) {\r\n      for (const [_key, url] of window.__objectUrls) {\r\n        URL.revokeObjectURL(url);\r\n      }\r\n      window.__objectUrls.clear();\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('메모리 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 비활성 캐시 정리\r\n */\r\nexport function cleanInactiveCaches(): boolean {\r\n  try {\r\n    if (!isBrowser) return false;\r\n    \r\n    // 접근 시간 추적을 위한 메타데이터 키\r\n    const CACHE_ACCESS_KEY = 'cache_last_access';\r\n    \r\n    // 현재 시간\r\n    const now = Date.now();\r\n    \r\n    // 마지막 접근 시간 정보 로드\r\n    let accessInfo: Record<string, number> = {};\r\n    try {\r\n      const accessInfoJson = localStorage.getItem(CACHE_ACCESS_KEY);\r\n      if (accessInfoJson) {\r\n        accessInfo = JSON.parse(accessInfoJson);\r\n      }\r\n    } catch {\r\n      // 파싱 오류 무시, 빈 객체 사용\r\n    }\r\n    \r\n    // 캐시 항목 스캔\r\n    const keysToCheck: string[] = [];\r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      if (key && key.startsWith('cache_')) {\r\n        keysToCheck.push(key);\r\n      }\r\n    }\r\n    \r\n    // 일정 시간 접근되지 않은 캐시 정리 (7일 이상)\r\n    const expiryTime = 7 * 24 * 60 * 60 * 1000; // 7일\r\n    const expiredKeys = keysToCheck.filter(key => {\r\n      const lastAccess = accessInfo[key] || 0;\r\n      return now - lastAccess > expiryTime;\r\n    });\r\n    \r\n    // 만료된 키 제거\r\n    expiredKeys.forEach(key => {\r\n      localStorage.removeItem(key);\r\n      delete accessInfo[key];\r\n    });\r\n    \r\n    // 접근 정보 업데이트\r\n    localStorage.setItem(CACHE_ACCESS_KEY, JSON.stringify(accessInfo));\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('비활성 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 모든 캐시 정리\r\n */\r\nexport function cleanAllCaches(): boolean {\r\n  try {\r\n    if (!isBrowser) return false;\r\n    \r\n    // 세션 스토리지 정리\r\n    sessionStorage.clear();\r\n    \r\n    // 로컬 스토리지에서 캐시 키 찾기\r\n    const cacheKeys: string[] = [];\r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      if (key && (\r\n        key.startsWith('cache_') || \r\n        key.startsWith('temp_') || \r\n        key.includes('cache')\r\n      )) {\r\n        cacheKeys.push(key);\r\n      }\r\n    }\r\n    \r\n    // 캐시 키 제거\r\n    cacheKeys.forEach(key => localStorage.removeItem(key));\r\n    \r\n    // 메모리 내 캐시 정리\r\n    cleanMemoryCache();\r\n    \r\n    // 브라우저 캐시 정리\r\n    clearBrowserCaches();\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('모든 캐시 정리 오류:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// 윈도우 메모리 옵티마이저 초기화 부분 수정\r\nif (typeof window !== 'undefined') {\r\n  // 타입 안전한 방식으로 속성 초기화\r\n  if (!window.__memoryOptimizer) {\r\n    (window as any).__memoryOptimizer = {\r\n      suggestGarbageCollection: () => {\r\n        // 기존 구현\r\n      },\r\n      requestGC: async (emergency?: boolean) => {\r\n        // 기존 구현\r\n        return {};\r\n      },\r\n      clearBrowserCaches: async () => {\r\n        // 기존 구현\r\n        return true;\r\n      },\r\n      clearStorageCaches: () => {\r\n        // 기존 구현\r\n        return true;\r\n      },\r\n      checkMemoryUsage: () => {\r\n        // 기존 구현\r\n        return null;\r\n      },\r\n      forceGC: () => {\r\n        // 기존 구현\r\n        return true;\r\n      },\r\n      // cleanAllCaches 메서드 추가\r\n      cleanAllCaches: () => {\r\n        // 캐시 정리 로직 구현\r\n        return true;\r\n      }\r\n    };\r\n  }\r\n  \r\n  // 옵셔널 체이닝 사용 + cleanAllCaches 대신 clearStorageCaches 사용\r\n  window.__memoryOptimizer?.clearStorageCaches?.();\r\n  window.__memoryOptimizer?.suggestGarbageCollection?.();\r\n  window.__memoryOptimizer?.requestGC?.();\r\n}\r\n\r\n// 매개변수 사용되지 않음 경고 수정 (이름 앞에 _ 추가)\r\nasync function defaultRequestGC(_emergency?: boolean): Promise<any> {\r\n  return Promise.resolve();\r\n}\r\n","/**\r\n * 네이티브 모듈과의 통신 브릿지\r\n */\r\n\r\nimport { MemoryInfo, OptimizationResult, OptimizationLevel, GCResult } from '@/types';\r\n\r\n// 최적화 레벨을 안전하게 변환하는 함수\r\nfunction safeOptimizationLevel(level: number): OptimizationLevel {\r\n  const validLevel = level >= 0 && level <= 5 ? level : 2; // 범위 외 값은 MEDIUM(2)로 기본 설정\r\n  return validLevel as OptimizationLevel;\r\n}\r\n\r\n/**\r\n * 네이티브 메모리 정보 요청\r\n */\r\nexport async function requestNativeMemoryInfo(): Promise<MemoryInfo | null> {\r\n  // 기본적인 브라우저 환경 체크\r\n  if (typeof window === 'undefined') {\r\n    return null;\r\n  }\r\n\r\n  try {\r\n    // 백엔드 API를 통해 메모리 정보 요청\r\n    const response = await fetch('/api/native/memory/info');\r\n    if (!response.ok) {\r\n      throw new Error(`API 요청 실패: ${response.status}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n    return data.memoryInfo;\r\n  } catch (error) {\r\n    console.error('네이티브 메모리 정보 요청 오류:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nimport { optimizeMemory, forceGarbageCollection, getMemoryInfo as fetchMemoryInfo } from './nativeModuleClient';\r\n\r\n// 브리지 상태\r\nconst bridgeState = {\r\n  isInitialized: false,\r\n  isAvailable: false,\r\n  lastError: null as Error | null,\r\n  lastCheck: 0,\r\n  errorCount: 0\r\n};\r\n\r\n/**\r\n * 에러 처리 래퍼 함수\r\n */\r\nasync function withErrorHandling<T>(\r\n  operation: () => Promise<T>, // 타입 오류 수정\r\n  fallback: () => Promise<T> | T | null,\r\n  operationName: string\r\n): Promise<T | null> {\r\n  try {\r\n    // 브리지가 초기화되지 않은 경우\r\n    if (!bridgeState.isInitialized) {\r\n      // 브리지 상태 확인\r\n      await checkBridgeAvailability();\r\n    }\r\n\r\n    if (!bridgeState.isAvailable) {\r\n      console.warn(`Native bridge not available for ${operationName}`);\r\n      return fallback();\r\n    }\r\n\r\n    // 작업 실행\r\n    return await operation();\r\n  } catch (error) {\r\n    // 오류 기록\r\n    bridgeState.errorCount++;\r\n    bridgeState.lastError = error instanceof Error\r\n      ? error\r\n      : new Error(String(error));\r\n\r\n    console.error(`Native bridge error in ${operationName}:`, error);\r\n\r\n    // 폴백 반환\r\n    return fallback();\r\n  }\r\n}\r\n\r\n/**\r\n * 브리지 가용성 확인\r\n */\r\nasync function checkBridgeAvailability(): Promise<boolean> {\r\n  try {\r\n    // 마지막 확인 후 10초 이내면 캐시된 값 반환\r\n    const now = Date.now();\r\n    if (now - bridgeState.lastCheck < 10000 && bridgeState.isInitialized) {\r\n      return bridgeState.isAvailable;\r\n    }\r\n\r\n    // 메모리 정보 가져오기 시도로 가용성 확인\r\n    const response = await fetchMemoryInfo();\r\n\r\n    bridgeState.isAvailable = response.success;\r\n    bridgeState.isInitialized = true;\r\n    bridgeState.lastCheck = now;\r\n\r\n    if (!response.success) {\r\n      bridgeState.lastError = new Error(response.error || 'Unknown error in native bridge');\r\n    } else {\r\n      bridgeState.lastError = null;\r\n    }\r\n\r\n    return bridgeState.isAvailable;\r\n  } catch (error) {\r\n    bridgeState.isAvailable = false;\r\n    bridgeState.isInitialized = true;\r\n    bridgeState.lastError = error instanceof Error\r\n      ? error\r\n      : new Error(String(error));\r\n    bridgeState.lastCheck = Date.now();\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 네이티브 가비지 컬렉션 요청\r\n */\r\nexport async function requestNativeGarbageCollection(): Promise<GCResult | null> {\r\n  return withErrorHandling(\r\n    async () => {\r\n      const response = await forceGarbageCollection();\r\n\r\n      if (response.success && response.result) {\r\n        return response.result;\r\n      }\r\n\r\n      throw new Error(response.error || '가비지 컬렉션을 수행할 수 없습니다');\r\n    },\r\n    () => ({\r\n      success: false,\r\n      timestamp: Date.now(),\r\n      freedMemory: 0,\r\n      freedMB: 0,\r\n      duration: 0,\r\n      error: bridgeState.lastError?.message || '가비지 컬렉션을 사용할 수 없습니다'\r\n    }),\r\n    '가비지 컬렉션'\r\n  );\r\n}\r\n\r\n/**\r\n * 네이티브 메모리 최적화 요청\r\n */\r\nexport async function requestNativeMemoryOptimization(\r\n  level: number,\r\n  emergency = false\r\n): Promise<OptimizationResult | null> {\r\n  // 올바른 레벨 값 확보\r\n  const safeLevel = safeOptimizationLevel(level);\r\n\r\n  return withErrorHandling(\r\n    async () => {\r\n      const response = await optimizeMemory(safeLevel, emergency);\r\n\r\n      if (response.success && response.result) {\r\n        return response.result;\r\n      }\r\n\r\n      throw new Error(response.error || '메모리 최적화를 수행할 수 없습니다');\r\n    },\r\n    () => ({\r\n      success: false,\r\n      optimizationLevel: safeLevel,\r\n      timestamp: Date.now(),\r\n      freedMemory: 0,\r\n      freedMB: 0,\r\n      error: bridgeState.lastError?.message || '메모리 최적화를 사용할 수 없습니다'\r\n    }),\r\n    '메모리 최적화'\r\n  );\r\n}\r\n\r\n/**\r\n * 네이티브 브리지 상태 확인\r\n */\r\nexport async function checkNativeBridgeStatus(): Promise<{\r\n  available: boolean;\r\n  initialized: boolean;\r\n  lastCheck: number;\r\n  errorCount: number;\r\n  lastError: string | null;\r\n}> {\r\n  await checkBridgeAvailability();\r\n\r\n  return {\r\n    available: bridgeState.isAvailable,\r\n    initialized: bridgeState.isInitialized,\r\n    lastCheck: bridgeState.lastCheck,\r\n    errorCount: bridgeState.errorCount,\r\n    lastError: bridgeState.lastError?.message || null\r\n  };\r\n}\r\n\r\n/**\r\n * 브리지 상태 게터 함수들\r\n */\r\nexport const getNativeBridgeState = () => ({ ...bridgeState });\r\nexport const isNativeBridgeAvailable = () => bridgeState.isAvailable;\r\nexport const getBridgeErrorCount = () => bridgeState.errorCount;\r\nexport const getLastBridgeError = () => bridgeState.lastError;\r\n","/**\r\n * 애플리케이션에서 사용하는 공통 타입 정의\r\n */\r\n\r\n/**\r\n * 메모리 사용 단계 열거형\r\n */\r\nexport enum MemoryUsageLevel {\r\n  NORMAL = 0,\r\n  LOW = 1,\r\n  MEDIUM = 2,\r\n  HIGH = 3,\r\n  CRITICAL = 4\r\n}\r\n\r\n// 네이티브 모듈 타입은 네임스페이스로 분리\r\nexport namespace NativeModule {\r\n  export interface MemoryInfo {\r\n    heap_used: number;\r\n    heap_total: number;\r\n    // ... 기타 속성\r\n  }\r\n\r\n  export interface GPUInfo {\r\n    name: string;\r\n    vendor: string;\r\n    // ... 기타 속성\r\n  }\r\n}\r\n\r\n/**\r\n * 최적화 레벨 enum - 충돌 방지를 위해 이름 변경\r\n */\r\nexport enum AppOptimizationLevel {\r\n  NONE = 0,\r\n  LOW = 1,\r\n  MEDIUM = 2,\r\n  HIGH = 3,\r\n  AGGRESSIVE = 4\r\n}\r\n\r\n/**\r\n * 메모리 정보 인터페이스\r\n */\r\nexport interface MemoryInfo {\r\n  timestamp: number;\r\n  heap_used: number;\r\n  heap_total: number;\r\n  heap_limit: number;\r\n  rss: number;\r\n  external?: number;\r\n  array_buffers?: number;\r\n  heap_used_mb: number;\r\n  rss_mb: number;\r\n  percent_used: number;\r\n\r\n  // 선택적 별칭 추가 - 코드 호환성을 위함\r\n  heapUsed?: number;\r\n  heapTotal?: number;\r\n  heapLimit?: number;\r\n  heapUsedMB?: number;\r\n  percentUsed?: number;\r\n  rssMB?: number;\r\n}\r\n\r\n/**\r\n * 가비지 컬렉션 결과 인터페이스 (missing type 추가)\r\n */\r\nexport interface GCResult {\r\n  success: boolean;\r\n  timestamp: number;\r\n  freedMemory: number;\r\n  freedMB: number;\r\n  duration?: number;\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * 최적화 결과 인터페이스\r\n */\r\nexport interface OptimizationResult {\r\n  success: boolean;\r\n  optimizationLevel: OptimizationLevel | string | number;\r\n  timestamp: number;\r\n  freedMemory: number; // 모든 속성 일관되게 필수로 변경\r\n  freedMB?: number;\r\n  duration?: number;\r\n  error?: string;\r\n\r\n  // 하위 호환성을 위한 snake_case 버전\r\n  optimization_level?: string | number;\r\n  freed_memory?: number;\r\n  freed_mb?: number;\r\n  \r\n  // 타입 확장: 메모리 정보 및 레벨 필드\r\n  memory_before?: MemoryInfo;\r\n  memory_after?: MemoryInfo;\r\n  level?: OptimizationLevel | string | number;\r\n}\r\n\r\n/**\r\n * 처리 모드 열거형\r\n */\r\nexport enum ProcessingMode {\r\n  AUTO = 'auto',\r\n  NORMAL = 'normal',\r\n  CPU_INTENSIVE = 'cpu-intensive',\r\n  GPU_INTENSIVE = 'gpu-intensive',\r\n  MEMORY_SAVING = 'memory-saving'\r\n}\r\n\r\n/**\r\n * 메모리 이벤트 타입 열거형 (missing type 추가)\r\n */\r\nexport enum MemoryEventType {\r\n  INFO = 'info',\r\n  WARNING = 'warning',\r\n  ERROR = 'error',\r\n  GC = 'gc',\r\n  OPTIMIZATION = 'optimization',\r\n  THRESHOLD = 'threshold',\r\n  STATE_CHANGE = 'state_change',\r\n  // 추가된 이벤트 타입들\r\n  PERIODIC_CHECK = 'periodic_check',\r\n  PAGE_NAVIGATION = 'page_navigation',\r\n  COMPONENT_MOUNT = 'component_mount',\r\n  GARBAGE_COLLECTION = 'garbage_collection',\r\n  // 추가 누락된 이벤트 타입들\r\n  COMPONENT_UNMOUNT = 'component_unmount',\r\n  USER_ACTION = 'user_action',\r\n  RESOURCE_LOADING = 'resource_loading',\r\n  CUSTOM = 'custom'\r\n}\r\n\r\n/**\r\n * 메모리 최적화 이벤트 인터페이스\r\n * level과 memoryFreed 속성 한정자 통일 (일관성)\r\n */\r\nexport interface MemoryOptimizationEvent {\r\n  timestamp: number;\r\n  level: OptimizationLevel | string | number; // 모두 필수 속성으로 통일\r\n  memoryFreed: number; // 모두 필수 속성으로 통일\r\n  message: string;\r\n}\r\n\r\n/**\r\n * 머신 정보 인터페이스\r\n */\r\nexport interface MachineInfo {\r\n  /** CPU 정보 */\r\n  cpuInfo: {\r\n    /** CPU 코어 수 */\r\n    cores: number;\r\n    /** 모델 이름 */\r\n    model: string;\r\n    /** 아키텍처 */\r\n    arch: string;\r\n  };\r\n\r\n  /** 메모리 정보 */\r\n  memoryInfo: {\r\n    /** 총 메모리 (MB) */\r\n    totalMemoryMB: number;\r\n    /** 여유 메모리 (MB) */\r\n    freeMemoryMB: number;\r\n  };\r\n\r\n  /** 운영체제 정보 */\r\n  osInfo: {\r\n    /** 운영체제 유형 */\r\n    type: string;\r\n    /** 운영체제 플랫폼 */\r\n    platform: string;\r\n    /** 운영체제 버전 */\r\n    release: string;\r\n  };\r\n}\r\n\r\n/**\r\n * 성능 정보 인터페이스\r\n */\r\nexport interface PerformanceInfo {\r\n  /** 앱 실행 시간 (초) */\r\n  uptime: number;\r\n\r\n  /** 평균 CPU 사용률 (%) */\r\n  avgCpuUsage: number;\r\n\r\n  /** 현재 메모리 사용량 (MB) */\r\n  memoryUsageMB: number;\r\n\r\n  /** 최대 메모리 사용량 (MB) */\r\n  peakMemoryUsageMB: number;\r\n\r\n  /** 마지막 최적화 시간 */\r\n  lastOptimizationTime?: number;\r\n\r\n  /** 최적화 횟수 */\r\n  optimizationCount: number;\r\n}\r\n\r\n/**\r\n * Electron Window Mode\r\n */\r\nexport type WindowMode = 'windowed' | 'fullscreen' | 'fullscreen-auto-hide';\r\n\r\n/**\r\n * 메모리 이벤트 인터페이스\r\n */\r\nexport interface MemoryEvent {\r\n  type: MemoryEventType;\r\n  message: string;\r\n  timestamp: number;\r\n  data?: unknown;\r\n}\r\n\r\n/**\r\n * 메모리 최적화 옵션 인터페이스\r\n */\r\nexport interface MemoryOptimizerOptions {\r\n  threshold?: number;\r\n  checkInterval?: number;\r\n  showWarnings?: boolean;\r\n  autoOptimize?: boolean;\r\n  debug?: boolean;\r\n  preferNative?: boolean;\r\n}\r\n\r\n/**\r\n * 메모리 최적화 유틸리티 인터페이스\r\n */\r\nexport interface MemoryOptimizerUtility {\r\n  getMemoryInfo: () => MemoryInfo | null;\r\n  optimizeMemory: (emergency?: boolean) => Promise<GCResult>;\r\n}\r\n\r\n/**\r\n * 메모리 최적화 레벨 정의\r\n */\r\nexport enum OptimizationLevel {\r\n  NONE = 0,\r\n  NORMAL = 0, // NONE의 별칭으로 추가\r\n  LOW = 1,\r\n  MEDIUM = 2,\r\n  HIGH = 3,\r\n  AGGRESSIVE = 4,\r\n  CRITICAL = 4, // AGGRESSIVE의 별칭으로 추가\r\n  EXTREME = 5 // 추가: 극단적인 최적화 레벨\r\n}\r\n\r\n/**\r\n * GPU 작업 타입 열거형\r\n */\r\nexport enum GpuTaskType {\r\n  MATRIX_MULTIPLICATION = 0,\r\n  TEXT_ANALYSIS = 1,\r\n  PATTERN_DETECTION = 2,\r\n  IMAGE_PROCESSING = 3, \r\n  DATA_AGGREGATION = 4,\r\n  TYPING_STATISTICS = 5,\r\n  CUSTOM = 6\r\n}\r\n\r\n/**\r\n * 시스템 상태 인터페이스\r\n */\r\nexport interface SystemStatus {\r\n  cpuUsage: number;\r\n  memoryUsage: number;\r\n  memoryUsageMB: number;\r\n  totalMemoryMB: number;\r\n  memoryLevel: MemoryUsageLevel;\r\n  processingMode: ProcessingMode;\r\n  isOptimizing: boolean;\r\n  lastOptimizationTime?: number;\r\n  uptime: number;\r\n  \r\n  // 확장 필드\r\n  memory?: {\r\n    percentUsed: number;\r\n    level: MemoryUsageLevel;\r\n    heapUsedMB: number;\r\n    rssMB: number;\r\n  };\r\n  \r\n  processing?: {\r\n    mode: string;\r\n    gpuEnabled: boolean;\r\n  };\r\n  \r\n  optimizations?: {\r\n    count: number;\r\n    lastTime: number;\r\n  };\r\n}\r\n\r\n/**\r\n * 네이티브 최적화 레벨 열거형\r\n */\r\nexport enum NativeOptimizationLevel {\r\n  Normal = 0,\r\n  Low = 1,\r\n  Medium = 2,\r\n  High = 3,\r\n  Critical = 4\r\n}\r\n\r\n/**\r\n * 메모리 설정 인터페이스\r\n */\r\nexport interface MemorySettings {\r\n  // 자동 최적화 설정\r\n  enableAutoOptimization: boolean;\r\n  // 호환성을 위한 별칭\r\n  enableAutomaticOptimization?: boolean;\r\n  autoOptimizationInterval: number;\r\n  // 호환성을 위한 별칭\r\n  optimizationInterval?: number;\r\n  memoryThreshold: number;\r\n  // 호환성을 위한 별칭\r\n  optimizationThreshold?: number;\r\n  aggressiveCleanup: boolean;\r\n  // 호환성을 위한 별칭\r\n  aggressiveGC?: boolean;\r\n  \r\n  // 컴포넌트 최적화 설정\r\n  optimizeOnUnmount: boolean;\r\n  releaseResourcesOnHide: boolean;\r\n  \r\n  // 캐시 설정\r\n  cacheLifetime: number;\r\n  maxCacheSize: number;\r\n  \r\n  // 네이티브 통합 설정\r\n  enableNativeOptimization: boolean;\r\n  preferNativeImplementation?: boolean;\r\n  processingMode: ProcessingMode;\r\n  \r\n  // 고급 설정\r\n  enableLogging: boolean;\r\n  debugMode: boolean;\r\n  \r\n  // 추가 필드\r\n  componentSpecificSettings?: Record<string, any>;\r\n  enablePerformanceMetrics?: boolean;\r\n  useMemoryPool?: boolean;\r\n  fallbackRetryDelay?: number;\r\n  poolCleanupInterval?: number;\r\n  enableAutomaticFallback?: boolean;\r\n}\r\n\r\n/**\r\n * 최적화 레벨 매핑\r\n */\r\nexport const APP_TO_NATIVE_LEVEL_MAP = {\r\n  [OptimizationLevel.NONE]: NativeOptimizationLevel.Normal,\r\n  // NORMAL은 NONE과 같은 값이므로 중복 매핑 방지\r\n  [OptimizationLevel.LOW]: NativeOptimizationLevel.Low,\r\n  [OptimizationLevel.MEDIUM]: NativeOptimizationLevel.Medium,\r\n  [OptimizationLevel.HIGH]: NativeOptimizationLevel.High,\r\n  [OptimizationLevel.AGGRESSIVE]: NativeOptimizationLevel.Critical,\r\n  // CRITICAL은 AGGRESSIVE와 같은 값이므로 중복 매핑 방지\r\n  [OptimizationLevel.EXTREME]: NativeOptimizationLevel.Critical\r\n} as Record<number, NativeOptimizationLevel>;\r\n\r\n// 모든 최적화 레벨에 대해 안전하게 네이티브 레벨을 가져오는 함수\r\nexport function getNativeLevelForOptimizationLevel(level: OptimizationLevel): NativeOptimizationLevel {\r\n  return APP_TO_NATIVE_LEVEL_MAP[level] || NativeOptimizationLevel.Medium;\r\n}\r\n\r\n/**\r\n * 네이티브 레벨을 앱 레벨로 변환하는 매핑\r\n */\r\nexport const NATIVE_TO_APP_LEVEL_MAP: Record<NativeOptimizationLevel, OptimizationLevel> = {\r\n  [NativeOptimizationLevel.Normal]: OptimizationLevel.NONE,\r\n  [NativeOptimizationLevel.Low]: OptimizationLevel.LOW,\r\n  [NativeOptimizationLevel.Medium]: OptimizationLevel.MEDIUM,\r\n  [NativeOptimizationLevel.High]: OptimizationLevel.HIGH,\r\n  [NativeOptimizationLevel.Critical]: OptimizationLevel.AGGRESSIVE\r\n};\r\n\r\n/**\r\n * GPU 계산 결과 인터페이스\r\n */\r\nexport interface GpuComputationResult {\r\n  success: boolean;\r\n  data?: unknown;\r\n  error?: string;\r\n  executionTime: number;\r\n  taskType: GpuTaskType;\r\n}\r\n\r\n/**\r\n * 작업 결과 인터페이스\r\n */\r\nexport interface TaskResult {\r\n  success: boolean;\r\n  data?: unknown;\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * GPU 정보 인터페이스\r\n */\r\nexport interface GpuInfo {\r\n  vendor: string;\r\n  renderer: string;\r\n  version: string;\r\n  shadingLanguageVersion: string;\r\n  isHardwareAccelerated: boolean;\r\n  maxTextureSize: number;\r\n  extensions: string[];\r\n  capabilities: {\r\n    webgl2: boolean;\r\n    webgl: boolean;\r\n    floatTextures: boolean;\r\n    instancedArrays: boolean;\r\n    drawBuffers: boolean;\r\n  };\r\n}\r\n","/**\r\n * 메모리 정보 유틸리티\r\n * \r\n * 브라우저 및 시스템 메모리 정보를 제공합니다.\r\n */\r\nimport { MemoryInfo } from '@/types';\r\nimport { requestNativeMemoryInfo } from '../native-memory-bridge';\r\n\r\n// 브라우저 메모리 성능 API를 위한 타입 확장\r\ninterface PerformanceMemory {\r\n  usedJSHeapSize: number;\r\n  totalJSHeapSize: number;\r\n  jsHeapSizeLimit: number;\r\n}\r\n\r\n/**\r\n * 현재 메모리 사용량 가져오기\r\n */\r\nexport async function getMemoryUsage(): Promise<MemoryInfo | null> {\r\n  try {\r\n    // 브라우저에서 사용 가능한 메모리 API 사용\r\n    if (typeof window === 'undefined' || !performance || !(performance as any).memory) {\r\n      return createEstimatedMemoryInfo();\r\n    }\r\n    \r\n    const memory = (performance as any).memory as PerformanceMemory;\r\n    \r\n    const heap_used = memory.usedJSHeapSize;\r\n    const heap_total = memory.totalJSHeapSize;\r\n    const heap_limit = memory.jsHeapSizeLimit;\r\n    const percent_used = (heap_used / heap_total) * 100;\r\n    \r\n    // RSS 추정 (정확한 값을 얻을 수 없으므로 힙 크기의 1.5배로 추정)\r\n    const rss = Math.round(heap_total * 1.5);\r\n    \r\n    return {\r\n      heap_used,\r\n      heap_total,\r\n      heap_limit,\r\n      heap_used_mb: heap_used / (1024 * 1024),\r\n      percent_used,\r\n      rss,\r\n      rss_mb: rss / (1024 * 1024),\r\n      timestamp: Date.now()\r\n    };\r\n  } catch (err) {\r\n    console.error('메모리 정보 가져오기 오류:', err);\r\n    return createEstimatedMemoryInfo();\r\n  }\r\n}\r\n\r\n/**\r\n * 추정 메모리 정보 생성\r\n * 브라우저가 메모리 API를 지원하지 않을 때 호출됩니다.\r\n */\r\nfunction createEstimatedMemoryInfo(): MemoryInfo {\r\n  // 추정치로 기본값 제공\r\n  const estimatedHeapUsed = 50 * 1024 * 1024; // 50MB\r\n  const estimatedHeapTotal = 100 * 1024 * 1024; // 100MB\r\n  \r\n  return {\r\n    heap_used: estimatedHeapUsed,\r\n    heap_total: estimatedHeapTotal,\r\n    heap_limit: estimatedHeapTotal * 2,\r\n    heap_used_mb: Math.round(estimatedHeapUsed / (1024 * 1024) * 10) / 10,\r\n    rss: Math.round(estimatedHeapTotal * 1.5),\r\n    rss_mb: Math.round(estimatedHeapTotal * 1.5 / (1024 * 1024) * 10) / 10,\r\n    percent_used: 50,\r\n    timestamp: Date.now()\r\n  };\r\n}\r\n\r\n/**\r\n * 네이티브 모듈을 통한 메모리 정보 가져오기\r\n */\r\nexport async function getNativeMemoryInfo(): Promise<MemoryInfo | null> {\r\n  try {\r\n    // 네이티브 모듈 연동 함수 호출\r\n    if (typeof window !== 'undefined' && window.__memoryOptimizer && typeof window.__memoryOptimizer.checkMemoryUsage === 'function') {\r\n      const nativeMemoryInfo = window.__memoryOptimizer.checkMemoryUsage();\r\n      if (nativeMemoryInfo) {\r\n        return normalizeMemoryInfo(nativeMemoryInfo);\r\n      }\r\n    }\r\n    \r\n    // API를 통해 가져오기\r\n    try {\r\n      const memoryInfo = await requestNativeMemoryInfo();\r\n      if (memoryInfo) {\r\n        return memoryInfo;\r\n      }\r\n    } catch (apiError) {\r\n      console.debug('API를 통한 메모리 정보 가져오기 실패:', apiError);\r\n    }\r\n    \r\n    // 네이티브 모듈 사용 불가능한 경우 브라우저 정보 반환\r\n    return getMemoryUsage();\r\n  } catch (error) {\r\n    console.error('네이티브 메모리 정보 가져오기 오류:', error);\r\n    return getMemoryUsage();\r\n  }\r\n}\r\n\r\n/**\r\n * 메모리 정보 가져오기 (MemoryMonitor 컴포넌트와의 호환성을 위한 함수)\r\n */\r\nexport async function getMemoryInfo(): Promise<MemoryInfo> {\r\n  // 네이티브 브리지를 통한 요청 시도\r\n  try {\r\n    if (typeof window !== 'undefined' && window.__memoryOptimizer && typeof window.__memoryOptimizer.checkMemoryUsage === 'function') {\r\n      const nativeMemoryInfo = window.__memoryOptimizer.checkMemoryUsage();\r\n      if (nativeMemoryInfo) {\r\n        // nativeMemoryInfo가 MemoryInfo 타입인지 확인하고, 아니라면 변환\r\n        const memoryInfo: MemoryInfo = normalizeMemoryInfo(nativeMemoryInfo);\r\n        return memoryInfo;\r\n      }\r\n    }\r\n  } catch (e) {\r\n    console.error('Native memory info request failed:', e);\r\n  }\r\n\r\n  // 실패 시 브라우저 메모리 정보 반환\r\n  const memoryInfo = await getMemoryUsage();\r\n  return memoryInfo || createEstimatedMemoryInfo();\r\n}\r\n\r\n/**\r\n * 메모리 정보 포맷팅 함수\r\n */\r\nexport function formatMemoryInfo(info: MemoryInfo): string {\r\n  if (!info) return 'Memory info not available';\r\n  \r\n  const usedMB = info.heap_used_mb.toFixed(1);\r\n  const totalMB = (info.heap_total / (1024 * 1024)).toFixed(1);\r\n  const percent = info.percent_used.toFixed(1);\r\n  \r\n  return `Memory: ${usedMB}MB / ${totalMB}MB (${percent}%)`;\r\n}\r\n\r\n/**\r\n * 메모리 상태 평가\r\n */\r\nexport function assessMemoryState(memoryInfo: MemoryInfo): 'normal' | 'warning' | 'critical' {\r\n  const percentUsed = memoryInfo.percent_used;\r\n  \r\n  if (percentUsed > 85) {\r\n    return 'critical';\r\n  } else if (percentUsed > 70) {\r\n    return 'warning';\r\n  }\r\n  \r\n  return 'normal';\r\n}\r\n\r\n/**\r\n * 네이티브 메모리 정보를 앱 형식으로 변환\r\n */\r\nexport function convertNativeMemoryInfo(nativeInfo: any): MemoryInfo {\r\n  return {\r\n    heap_used: nativeInfo.heap_used || 0,\r\n    heap_total: nativeInfo.heap_total || 0,\r\n    heap_limit: nativeInfo.heap_limit || 0,\r\n    heap_used_mb: nativeInfo.heap_used_mb || 0,\r\n    percent_used: nativeInfo.percent_used || 0,\r\n    rss: nativeInfo.rss || 0,\r\n    rss_mb: nativeInfo.rss_mb || 0,\r\n    timestamp: nativeInfo.timestamp || Date.now()\r\n  };\r\n}\r\n\r\n/**\r\n * 메모리 정보 정규화 (필드 이름 통일)\r\n */\r\nfunction normalizeMemoryInfo(info: any): MemoryInfo {\r\n  return {\r\n    heap_used: info.heapUsed || info.heap_used || 0,\r\n    heapUsed: info.heapUsed || info.heap_used || 0,\r\n    heap_total: info.heapTotal || info.heap_total || 0,\r\n    heapTotal: info.heapTotal || info.heap_total || 0,\r\n    heap_used_mb: info.heapUsedMB || info.heap_used_mb || 0,\r\n    heapUsedMB: info.heapUsedMB || info.heap_used_mb || 0,\r\n    rss: info.rss || 0,\r\n    rss_mb: info.rssMB || info.rss_mb || 0,\r\n    rssMB: info.rssMB || info.rss_mb || 0,\r\n    percent_used: info.percentUsed || info.percent_used || 0,\r\n    percentUsed: info.percentUsed || info.percent_used || 0,\r\n    heap_limit: info.heapLimit || info.heap_limit || 0,\r\n    timestamp: info.timestamp || Date.now()\r\n  };\r\n}\r\n","/**\n * 네이티브 모듈 클라이언트 API\n * \n * 프론트엔드에서 네이티브 모듈 기능을 사용하기 위한 래퍼 함수들을 제공합니다.\n */\n\nimport type { \n  MemoryInfo, \n  OptimizationResult, \n  GCResult, \n  GpuInfo,\n  GpuComputationResult,\n  TaskResult\n} from '@/types';\nimport { OptimizationLevel } from '@/types/native-module';\n\n// 상태 캐시\nlet moduleStatusCache: any = null;\nlet lastStatusCheck = 0;\nconst STATUS_CACHE_TTL = 10000; // 10초\n\n// 브라우저 환경인지 확인 - 상수로 변경\nconst isBrowser = typeof window !== 'undefined';\n\n/**\n * fetch 요청을 래핑하는 함수\n */\nasync function enhancedFetch(url: string, options: RequestInit = {}): Promise<Response> {\n  try {\n    const response = await fetch(url, {\n      ...options,\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers,\n      },\n    });\n    \n    return response;\n  } catch (error) {\n    console.error(`Fetch 요청 실패 (${url}):`, error);\n    throw error;\n  }\n}\n\n/**\n * 메모리 정보 가져오기\n */\nexport async function getMemoryInfo() {\n  if (!isBrowser) {\n    return { success: false, error: 'Server environment', timestamp: Date.now() };\n  }\n  \n  try {\n    const response = await enhancedFetch('/api/native/memory');\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('메모리 정보 가져오기 실패:', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\n    };\n  }\n}\n\n/**\n * 메모리 최적화 수행\n */\nexport async function optimizeMemory(level = 2, emergency = false) {\n  try {\n    const response = await enhancedFetch('/api/native/memory', {\n      method: 'PUT',\n      body: JSON.stringify({\n        type: 'optimize',\n        level: level.toString(),\n        emergency\n      }),\n    });\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('메모리 최적화 실패:', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\n    };\n  }\n}\n\n/**\n * 가비지 컬렉션 강제 수행\n */\nexport async function forceGarbageCollection() {\n  try {\n    // 요청 데이터 준비\n    const data = JSON.stringify({\n      type: 'gc'\n    });\n    \n    // 먼저 POST 메서드로 시도\n    try {\n      const response = await enhancedFetch('/api/native/memory', {\n        method: 'POST',\n        body: data,\n      });\n      \n      if (response.ok) {\n        return await response.json();\n      }\n      \n      // POST가 실패하면 PUT 메서드 시도\n      console.warn('POST 메서드 실패, PUT 메서드로 다시 시도합니다.');\n    } catch (error) {\n      console.warn('POST 메서드 실패, PUT 메서드로 다시 시도합니다.', error);\n    }\n    \n    // PUT 메서드 시도\n    const response = await enhancedFetch('/api/native/memory', {\n      method: 'PUT',\n      body: data,\n    });\n    \n    if (!response.ok) {\n      // 더 상세한 오류 로깅\n      console.error(`가비지 컬렉션 요청 실패: ${response.status} ${response.statusText}`);\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('가비지 컬렉션 실패:', error);\n    \n    // 가비지 컬렉션이 실패하더라도 폴백 구현으로 기본 가비지 컬렉션 시도\n    try {\n      if (typeof window !== 'undefined' && typeof window.gc === 'function') {\n        window.gc();\n        console.log('브라우저 GC 폴백 사용');\n        return {\n          success: true,\n          message: '브라우저 GC 폴백으로 실행됨',\n          timestamp: Date.now()\n        };\n      }\n    } catch (fallbackError) {\n      console.warn('브라우저 GC 폴백도 실패:', fallbackError);\n    }\n    \n    return {\n      success: false,\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\n      timestamp: Date.now()\n    };\n  }\n}\n\n/**\n * GPU 정보 가져오기\n */\nexport async function getGpuInfo() {\n  try {\n    // 브라우저 환경인지 확인\n    if (!isBrowser) {\n      return createFallbackGpuInfo('서버 환경에서 실행 중');\n    }\n    \n    // 먼저 간단한 상태 확인\n    if (!window.navigator) {\n      return createFallbackGpuInfo('navigator 객체를 사용할 수 없음');\n    }\n    \n    try {\n      const response = await enhancedFetch('/api/native/gpu');\n    \n    if (!response.ok) {\n        console.warn(`GPU 정보 요청 실패: ${response.status}. 폴백 GPU 정보 반환`);\n        return createFallbackGpuInfo(`API 응답 오류: ${response.status}`);\n      }\n      \n      const result = await response.json();\n      \n      // 결과 검증\n      if (result && result.success) {\n        return result;\n      } else {\n        console.warn('GPU 정보 요청은 성공했지만 유효한 데이터가 없습니다. 폴백 정보 반환', result);\n        return createFallbackGpuInfo('유효하지 않은 응답 데이터');\n      }\n    } catch (fetchError) {\n      console.error('GPU 정보 요청 중 오류:', fetchError);\n      return createFallbackGpuInfo(fetchError instanceof Error ? fetchError.message : '네트워크 오류');\n    }\n  } catch (error) {\n    console.error('GPU 정보 가져오기 처리 중 예상치 못한 오류:', error);\n    return createFallbackGpuInfo('예상치 못한 오류');\n  }\n}\n\n/**\n * 폴백 GPU 정보 생성\n */\nfunction createFallbackGpuInfo(reason: string) {\n  // 브라우저 WebGL 지원 확인 시도\n  let webglAvailable = false;\n  let vendorInfo = '알 수 없음';\n  \n  try {\n    if (typeof window !== 'undefined') {\n      const canvas = document.createElement('canvas');\n      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl') as WebGLRenderingContext | null;\n      \n      if (gl) {\n        webglAvailable = true;\n        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');\n        \n        if (debugInfo) {\n          const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || '알 수 없음';\n          const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || '알 수 없음';\n          vendorInfo = `${vendor} (${renderer})`;\n        }\n      }\n    }\n  } catch (e) {\n    console.warn('WebGL 지원 확인 중 오류:', e);\n  }\n  \n  return {\n    success: true, // 폴백 정보이지만 클라이언트 코드를 중단시키지 않기 위해 success:true 반환\n    available: webglAvailable,\n    fallback: true, // 이것이 폴백 데이터임을 표시\n    gpuInfo: {\n      name: '브라우저 폴백',\n      vendor: vendorInfo,\n      available: webglAvailable,\n      accelerationEnabled: false,\n      deviceType: 'Software',\n      driverVersion: '폴백 구현',\n      fallbackReason: reason\n    },\n      timestamp: Date.now()\n    };\n}\n\n/**\n * GPU 가속 활성화/비활성화\n * @param enable 활성화 여부\n */\nexport async function setGpuAcceleration(enable: boolean) {\n  try {\n    // 요청 데이터 준비\n    const requestBody = JSON.stringify({\n      enable\n    });\n    \n    // 요청 보내기\n    const response = await enhancedFetch('/api/native/gpu/acceleration', {\n      method: 'PUT',\n      body: requestBody\n    });\n    \n    // 응답 처리\n    if (!response.ok) {\n      throw new Error(`GPU 가속 설정 요청 실패: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('GPU 가속 설정 오류:', error);\n    return {\n      success: false,\n      enabled: false,\n      result: false,\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\n      timestamp: Date.now()\n    };\n  }\n}\n\n/**\n * GPU 계산 수행\n * @param data 계산에 사용할 데이터\n * @param computationType 계산 유형\n */\nexport async function performGpuComputation<T = unknown>(data: unknown, computationType: string) {\n  try {\n    // 요청 데이터 준비\n    const requestBody = JSON.stringify({\n      data,\n      computationType\n    });\n    \n    // 요청 보내기\n    const response = await enhancedFetch('/api/native/gpu', {\n      method: 'POST',\n      body: requestBody\n    });\n    \n    // 응답 처리\n    if (!response.ok) {\n      throw new Error(`GPU 계산 요청 실패: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('GPU 계산 오류:', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\n      timestamp: Date.now()\n    };\n  }\n}\n\n/**\n * 네이티브 모듈 상태 확인\n */\nexport async function getNativeModuleStatus() {\n  if (!isBrowser) {\n    return { success: false, error: 'Server environment', timestamp: Date.now() };\n  }\n  \n  // 캐시된 상태가 있고 TTL 내라면 캐시된 값 반환\n  const now = Date.now();\n  if (moduleStatusCache && now - lastStatusCheck < STATUS_CACHE_TTL) {\n    return moduleStatusCache;\n  }\n  \n  try {\n    const response = await enhancedFetch('/api/native/status');\n    \n    if (!response.ok) {\n      throw new Error(`네이티브 모듈 상태 요청 실패: ${response.status}`);\n    }\n    \n    const result = await response.json();\n    \n    // 캐시 업데이트\n    moduleStatusCache = result;\n    lastStatusCheck = now;\n    \n    return result;\n  } catch (error) {\n    console.error('네이티브 모듈 상태 확인 실패:', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : '알 수 없는 오류',\n    };\n  }\n}\n"],"names":["window","requestGC","_emergency","requestNativeGarbageCollection","error","console","success","timestamp","Date","now","freedMemory","freedMB","Error","message","__memoryOptimizer","suggestGarbageCollection","emergency","clearBrowserCaches","clearStorageCaches","checkMemoryUsage","forceGC","cleanAllCaches","bridgeState","isInitialized","isAvailable","lastError","lastCheck","errorCount","withErrorHandling","operation","fallback","operationName","checkBridgeAvailability","warn","String","response","fetchMemoryInfo","forceGarbageCollection","result","duration","getMemoryUsage","memory","createEstimatedMemoryInfo","heap_used","usedJSHeapSize","heap_total","totalJSHeapSize","heap_limit","jsHeapSizeLimit","rss","Math","round","heap_used_mb","percent_used","rss_mb","err","estimatedHeapUsed","estimatedHeapTotal","getMemoryInfo","nativeMemoryInfo","memoryInfo","normalizeMemoryInfo","info","heapUsed","heapTotal","heapUsedMB","rssMB","percentUsed","heapLimit","e","enhancedFetch","url","options","fetch","headers","ok","status","json","optimizeMemory","level","method","body","JSON","stringify","type","toString","data","statusText","gc","log","fallbackError","getGpuInfo","navigator","createFallbackGpuInfo","fetchError","reason","webglAvailable","vendorInfo","canvas","document","createElement","gl","getContext","debugInfo","getExtension","vendor","getParameter","UNMASKED_VENDOR_WEBGL","renderer","UNMASKED_RENDERER_WEBGL","available","gpuInfo","name","accelerationEnabled","deviceType","driverVersion","fallbackReason","setGpuAcceleration","enable","requestBody","enabled","performGpuComputation","computationType"],"sourceRoot":"","ignoreList":[]}